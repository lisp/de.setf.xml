<html><head><title>functional-accessors.lisp</title><style type='text/css'>body {background-color: #f4f4f8;}div.source {background-color: #f6f6fa; width: 75%; white-space: pre;            margin-left: 1em; margin-top: .5ex; margin-bottom: .5ex; padding-left: 1em;            border: solid; border-width: 1px;            border-top-color: #e0e0e0; border-left-color: #e0e0e0;            border-right-color: #ffffff; border-bottom-color: #ffffff;}</style></head><body><div class='source'><b>(in-package :web-user)</b></div><h2>CL-XML: How To: Access Document Components</h2><p>20040209  <br/><a href='mailto:James.Anderson@setf.de'>james anderson</a> (c)2004, </p><hr/><br/><table border='1' cellpadding='0' cellspacing='0' width='100%'>  <tr>   <td align='center'>    [<a href='./load.html'>loading</a>]    [<a href='./parse.html'>parsing</a>]    [<a href='#Accessors'>accessor functions</a>]    [<a href='./path-accessors.html'>paths</a>]    [<a href='./combined-methods.html'>combinations</a>]    [<a href='./transformations'>transformations</a>]    <a name='TOP'/></td></tr>  </table><a name='Accessors'><hr/></a><h2>functional accessors</h2><div class='source'><b>(defVar *dm*)</b></div><p>here is how to use cl-xml to get at components in documents. to begin one needs a document</p><div class='source'><b>(setq *dm* (parse-document #4P"xml:documentation;howto;howto.xml"))</b></div><p>once the document is parsed, one can use standard common-lisp operators as well as the document component access functions to extract components. for example, in order to print all attributes with the identifier "name" in the element children of the document's root element, one combines standard operators to iterate over the child list, select the element children and ignore the character data, and find the attributes named "name".</p><div class='source'><b>(dolist (child (children (root *dm*))) (typecase child  (elem-node (print (find '||::name (attributes child) :key #'name)))))</b></div><p>in order to print the attribute value, rather than the node itself, the <code>value</code> operator extracts the value from the attribute nodes.</p><div class='source'><b>(dolist (element (children (root *dm*))) (typecase element  (elem-node   (print (value (find '||::name (attributes element) :key #'name))))))</b></div><p>cl-xml defines several kinds of functions which facilitate this kind of access to document components.the simplest are utility functions which combine traversal, type restrictions, and matching. these include the operators<ul> <li><code>./</code>returns the first element child with a matching name</li> <li><code>./*</code> collects all element children with a matching name</li> <li><code>.//*</code> collects all element descendants with a matching name</li> </ul>for example, since the root element of the <i>howto</i> document is named <code>{}inventory</code>,</p><div class='source'><b>(name (./ *dm* '||::inventory))</b></div><div>== <code>||::|inventory|</code> <br/>the top-level children can be enumerated by selecting with a wild-card name, as in</div><div class='source'><b>(mapcar #'name (./* (./ *dm* '||::inventory) '||::*))</b></div><div>== <code>(||::section ||::section)</code>,</div><p>and all of the elements in the document are collected by  </p><div class='source'><b>(mapcar #'name (.//* *dm* '||::*))</b></div><div>== <code>(||::inventory ||::section ||::item ||::name ||::price ||::description          ||::item ||::name ||::price ||::description ||::section ||::item          ||::name ||::price ||::description ||::item ||::name ||::price          ||::description)</code><br/>if one needed a list of all of the name or upc attribute values in the document, one could combine a selection filter with the the navigation operation</div><div class='source'><b>(remove "" (mapcar #'(lambda (e) (./@-string e '||::name)) (.//* *dm* '||::*)) :test #'equal)</b></div><div>== <code>("health" "food")</code></div><div class='source'><b>(remove "" (mapcar #'(lambda (e) (./@-string e '||::upc)) (.//* *dm* '||::*)) :test #'equal)</b></div><div>== <code>("123456789" "445322344" "485672034" "132957764")</code></div><p>for more complex selection and combination operations, one can use binding macros, like <a href='./destructure.lisp'><code>destructure-element</code></a> to designate components by name, position or relation and bind them to variables. this approach can be used to implement simple filters, for example, to transform the original <i>howto</i> document intoa simple account of the items in each section,</p><div class='source'><b>(pprint (destructure-element ((root-gi ((||::title title))) &amp;rest root-children)  (root *dm*)  (LIST* (LIST* root-gi (LIST (LIST* '||::title (value title))))         (mapcar          #'(lambda (section)             (destructure-element              ((section-gi ((||::name name))) &amp;rest section-children) section              (LIST* (LIST* section-gi (LIST (LIST* '||::name (value name))))                     (mapcar                      #'(lambda (item)                         (destructure-element ((gi ((||::upc upc)))) item                          (LIST* gi (LIST (value upc)))))                      (remove-if #'stringp section-children)))))          (remove-if #'stringp root-children)))))</b></div><div><pre>== <code>((||::inventory (||::title . "OmniCorp Store #45x10^3"))          ((||::section (||::name . "health")) (||::item "123456789")           (||::item "445322344"))          ((||::section (||::name . "food")) (||::item "485672034")           (||::item "132957764")))</code></pre></div><code>:eof</code><hr /><div class='copyright'>&#169; setf.de 20031028T430013 = <a href='./functional-accessors.lisp'>functional-accessors.lisp</a></div></body></html>