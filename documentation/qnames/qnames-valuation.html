<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>

<HEAD>
	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">
	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.3">
	<TITLE>QName Semantics</TITLE>
</HEAD>

<BODY TEXT="#000000" BGCOLOR="#FFFFFF">

<P>This section describes the process which interprets instance documents in terms
of an abstract document model. The process has two stages. First, several initial
lexical transformations normalize forms in the instance document and arrange the
declarations in contexts. Then a collection of valuation operators generate the respective
abstract document model.</P>
<H4>Lexical Transformations</H4>
<P>The interpretation process presumes several primitive lexical transforms between
an instance document, which appears in the simplified concrete syntax, and the instance
document as expressed in the abstract syntax.</P>

<P>unprefixed generic identifiers and attribute names are transformed into qualified
names with null prefixes</P>

<P>NCName ==&gt; (qn: null LocalPart dci<SUB>0</SUB>)</P>

<P>The exceptional case of the default namespace prefix is transformed into a qualified
name with that as the prefix and anull local part</P>

<P>xmlns ==&gt; (qn: xmlns null dci<SUB>0</SUB>)</P>

<P>declarations are collected into declaration context tree. The root of the tree
is the internal subset. Each external entity adds a declaration context as a branch
to this tree. This is true of both the external subset and any entity incorporated
through an external parameter entity, Nested parameter entity references introduce
further branches which extend from the context in which they are referenced. Each
declaration context is extended with a context identifier which is generated by appending
a per-context index to the identifer of its containing context. The root context
identifier is '0'. Qualified names are extended with the respective declaration context
identifier. For example</P>

<P>&lt;!DOCTYPE doc [ &lt;!ELEMENT x ANY&gt; &lt;!ATTLIST x a CDATA &quot;s&quot;&gt;
]&gt;<BR>
&lt;x/&gt;</P>

<P>==&gt;</P>

<P>(:doc (:qn null 'doc')<BR>
(:dcl (:ed (:qn null 'x' '0') ANY) (:ad (:qn null 'x' '0') (:a (:qn null 'a' '0')))))<BR>
(:e (:qn null 'x' '0') () () ()))</P>

<P>Were a parameter entity involved, the abstract expression would exhibit nested
declaration contexts</P>

<P>&lt;!DOCTYPE doc [ &lt;!ELEMENT x ANY&gt; <BR>
&lt;!ENTITY %p SYSTEM &quot;data:,&lt;!ATTLIST x a CDATA 's'&gt;&quot;&gt;<BR>
%p;<BR>
]&gt;<BR>
&lt;x/&gt;</P>

<P>==&gt;</P>

<P>(:doc (:qn null 'doc')<BR>
(:dcl (:ed (:qn null 'x' '0') ANY) (:dcl (:ad (:qn null 'x' '0.0') (:a (:qn null
'a' '0.0'))))))<BR>
(:e (:qn null 'x' '0') () () ()))</P>

<P></P>
<H4>Valuation Operators</H4>
<P>The valuation operators depend on several primitives.</P>

<DL>
	<DT>declaration context equivalence</DT>
	<DD>
	<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="30%">
		<TR>
			<TD WIDTH="100%">
				<CENTER>
				<P>dci<SUB>0</SUB> ==<SUB>l</SUB> (dci<SUB>1</SUB> + Character*)
<HR>

</CENTER>
			</TD>
		</TR>
		<TR>
			<TD WIDTH="100%">
				<P ALIGN="CENTER">dci<SUB>0</SUB> &lt; dci<SUB>1</SUB>
			</TD>
		</TR>
	</TABLE>

	<DT>qualified name equality</DT>
	<DD>
	<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="50%">
		<TR>
			<TD WIDTH="100%">p<SUB>0</SUB> ==<SUB>l</SUB> p<SUB>1</SUB>, l<SUB>0</SUB> ==<SUB>l</SUB> l<SUB>1</SUB>,
				( dci<SUB>0</SUB> &lt; dci<SUB>1</SUB> |  dci<SUB>1</SUB> &lt; dci<SUB>0</SUB>)
<HR SIZE="1">
			</TD>
		</TR>
		<TR>
			<TD WIDTH="100%">(:qn p<SUB>0</SUB> l<SUB>0</SUB> dci<SUB>0</SUB>) ==<SUB>p</SUB> (:qn p<SUB>1</SUB>
				l<SUB>1</SUB> dci<SUB>1</SUB>)</TD>
		</TR>
	</TABLE>
<BR>
	
</DL>

<P>
<TABLE BORDER="0" CELLSPACING="0" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">Where the encoding <B><CODE>xmlns</CODE></B> appears as an attribute value, the valuation
			is the qualified name with the <I>xmlns</I> prefix and a local part <I>null</I>.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B><CODE> (:qn <B>null</B> <B>xmlns</B> )</CODE> <B>]]</B></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">(<I>qn:</I> <I>xmlns</I>, <I>null</I> )</TD>
	</TR>
</TABLE>
<BR>

<TABLE BORDER="0" CELLSPACING="0" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">All other encoded names evaluate to qualified names</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B><CODE> (:qn <B>null</B> l )</CODE> <B>]]</B></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">(<I>qn:</I> <I>null, l</I> )</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B><CODE> (:qn p l )</CODE> <B>]]</B></TD>
	</TR>
	<TR>
		<TD WIDTH="20">==&gt;</TD>
		<TD WIDTH="50%">(<I>qn:</I> <I>p, l</I> )</TD>
	</TR>
</TABLE>
</P>

<P><BR>
[[<B>&lt;!ATTLIST</B> (<I>p</I><SUB>i</SUB> <I>l</I><SUB>i</SUB> <I>v</I><SUB>i</SUB>),
(<B>xmlns</B>, <I>p</I><SUB>j</SUB>), u)<B>&gt;</B> (<B>ED</B>, (pi, li, u) EU)]]
==&gt; EU' = (EU, (pi, u)) in (TEu (I[[(pi, li)]], EU') (TAu, (I[[(pi, li)]], EU'),
(I[[(xmlns, li, u)]], EU') )</P>

<P>nse0 = ( (xmlns {xmlns}), (xml {}), (|| {}) )</P>

<P>intern DTD : ID == ( DoctypeDecl NamespaceEnvironment ) ==&gt; Schema</P>

<P><BR>

<TABLE BORDER="0" CELLPADDING="2" CELLSPACING="0" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">Document valuation transforms a concrete document instance into a abstract instance
			by transforming the declarations into a schema, interning the document name in the
			context of the schema, and transforming the document element in the context of the
			schema.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>DOC[[</B> (:doc q<SUB>0</SUB> dcl<SUB>0</SUB> e<SUB>0</SUB>) <B>]] </B><I>s</I><SUB>0</SUB>
			<I>nse</I><SUB>0</SUB> 
<HR>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><I>s</I><SUB>1</SUB> == <B>S[[</B> dcl<SUB>0</SUB><B> ]] </B><I>s</I><SUB>0</SUB>
			<I>nse</I><SUB>0</SUB><BR>
			(<I>doc</I> (<B>U<SUB>d</SUB>[[</B> q<SUB>0</SUB><B>]]</B> <I>s</I><SUB>1 </SUB><I>nse</I><SUB>0</SUB>),
			<I>s</I><SUB>1</SUB>, (<B>E[[</B> e<SUB>0</SUB> <B>]]</B> <I>s</I><SUB>1 </SUB><I>nse</I><SUB>0</SUB>)
			)</TD>
	</TR>
</TABLE>
</P>

<P><BR>

<TABLE BORDER="0" CELLPADDING="2" CELLSPACING="0" WIDTH="100%">
	<TR>
		<TD COLSPAN="2"><B>UN</B> ::= (<I>QualifiedName</I> X <I>Schema</I> X <I>NamespaceEnvironment</I>)
			==&gt; <I>UniversalName</I> 
<HR>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">The qualified document type name is transformed in the context of the global namespace
			environment and the document schema. If the prefix is bound globally, the respective
			universal name applies. otherwise the universal name identifier of that element for
			which the original qualified name matches is used.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>UN<SUB>d</SUB>[[</B> (:qn p<SUB>0</SUB> l<SUB>0</SUB>) <B>]]</B> (<I>s</I> (<I>ed</I>
			(<I>un</I> <I>nsn</I><SUB>0</SUB> <I>l</I><SUB>0</SUB> <I>p</I><SUB>0</SUB>) <I>em</I><SUB>0</SUB>)
			. <I>ed</I>*) <I>nse</I><SUB>0</SUB> 
<HR>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">let u0 == resolveQName( (:qn p<SUB>0</SUB> l<SUB>0</SUB>) <I>nse</I><SUB>0</SUB>)<BR>
			in isNull(u0) -&gt;<BR>
			let ed0 == findElementDeclaration( (:qn p<SUB>0</SUB> l<SUB>0</SUB>) s0)<BR>
			in cases (ed0) isNull(ed0) -&gt; |/ [] isElementDeclaration( u1, em0, u* ) -&gt;
			u1 end<BR>
			[] u0</TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="0" CELLPADDING="2" CELLSPACING="0" WIDTH="100%">
	<TR>
		<TD COLSPAN="2"><B>S</B> ::= (<CODE>DeclarationContext X <I>Schema</I> X <I>NamespaceEnvironment</I>)
			==&gt; <I>Schema</I></CODE> 
<HR>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">The document type declaration is transformed by coalescing attribute declarations
			with the matching element declarations, recognizing namespace bindings and propagating
			these bindings through the imputed element content hierarchy.<BR>
<BR>
The terminal valuation completes the process once all concrete declarations have
			been translated.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>S[[</B> dcx<SUB>0</SUB><B> ]] </B><I>s</I><SUB>0</SUB> <I>nse</I><SUB>0</SUB>
			
<HR>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><I>s</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">multiple element declarations with the same qualified name identifier are an error
					</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">qn<SUB>0</SUB> == qn<SUB>1<BR>
			|-<BR>
			</SUB><B>S[[</B> ( (:ed<B> </B>qn<SUB>0</SUB> qn*), (:ed<B> </B>qn<SUB>1</SUB> qn*)
			.  dcl*)]] <I>sc</I> <I>nse</I> </TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">error</TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">A new element declaration instance is introduce by the presence of an element declaration
			form. The element identifier remains initially a qualified name.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>S[[ </B>(:dcx (:ed<B> </B>qn<SUB>0</SUB> qn*) .  dcl*) <B>]]</B> (<I>sc</I>, <I>md</I>*)
			<I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B> (:dcx (:ed<B> </B>qn<SUB>0</SUB> qn*) .  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>,
			<B>QN[[</B>qn<SUB>0</SUB><B>]]</B>, (), (), <I>nse</I><SUB>0</SUB> ) . <I>md</I>*
			)  <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">An exhausted element declaration form disappears.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB> |-<BR>
			<B>S[[</B> (:dcx (:ed<B> </B>qn<SUB>0</SUB> ()) .  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>,
			<I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB>
			) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B>  (:dcx dcl*) <B>]]</B>  (<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>,
			<I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB> ) . <I>md</I>*
			)  <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">The model of an existing element declaration instance is augmented based on the names
			in the model of an element declaration form.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB> |-<BR>
			<B>S[[</B> ( (:ed<B> </B>qn<SUB>0</SUB> (qn<SUB>2</SUB> . qn*) .  dcl*) <B>]]</B>
			(<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>,
			<I>nse</I><SUB>0</SUB> ) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B> ( (:ed<B> </B>qn<SUB>0</SUB>  qn* .  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>,
			n<SUB>1</SUB>, (<B>QN[[</B> <I>qn</I><SUB>2</SUB> <B>]]</B> . <I>n</I>*<SUB>0</SUB>),
			<I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB> ) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">An existing element declaration is augmented based on an attribute declaration.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB> |-<BR>
			<B>S[[</B> ( (:ad<B> </B>qn<SUB>0</SUB> (qn<SUB>2</SUB> . qn*) .  dcl*) <B>]]</B>
			(<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>,
			<I>nse</I><SUB>0</SUB> ) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B> ( (:ad<B> </B>qn<SUB>0</SUB>  qn* .  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>,
			n<SUB>1</SUB>, <I>n</I>*<SUB>0 </SUB>(<B>QN[[</B> <I>qn</I><SUB>2</SUB> <B>]]</B>
			. <I>n</I>*<SUB>1</SUB>), <I>nse</I><SUB>0</SUB> ) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">In the absence of a matching element declaration an attribute declaration is ignored.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">!E <B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB> |-<BR>
			<B>S[[</B> (:dcx dci ((:ad<B> </B>qn<SUB>0</SUB> ep ) .  dcl*)) <B>]]</B> (<I>sc</I>,
			(<I>ed</I>, <I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB>
			) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B> (:dcx dci  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>,
			<I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB> ) . <I>md</I>*
			)  <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">A duplicate attribute declaration is ignored. Note that this filter is not sufficient
			to eliminate duplicate attributes: they must also be eliminated after names have
			been interned to account for synonyms.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB>, <B>QN[[</B>qn<SUB>2</SUB><B>]]</B>
			==<SUB>q</SUB> <I>n</I><SUB>2</SUB> |-<BR>
			<B>S[[</B> (:dcx dci (:ad<B> </B>qn<SUB>0</SUB> (:a qn<SUB>2</SUB>)) .  dcl*) <B>]]</B>
			(<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <SUB> </SUB>(n<SUB>2</SUB>
			. <I>n</I>*<SUB>1</SUB>), <I>nse</I><SUB>0</SUB> ) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B> (:dcx dci  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>, n<SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>,
			(n<SUB>2</SUB> . <I>n</I>*<SUB>1</SUB>), <I>nse</I><SUB>0</SUB> ) . <I>md</I>* )
			 <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">An existing element declaration is augmented based on a namespace declaration.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB> |-<BR>
			<B>S[[</B> (:dcx (:ad<B> </B>qn<SUB>0</SUB> (:nsb (:qn 'xmlns' l) nsn) .  dcl*) <B>]]</B>
			(<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>,
			<I>nse</I><SUB>0</SUB> ) . <I>md</I>* ) <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">let nsb0 = (<B>P[[ </B>l <B>]]</B>, <B>NS[[</B>nsn<B>]]</B>) in<BR>
			 let nse1 = augmentNSE(nsb0, nse0)<BR>
			 if <BR>
			in <B>S[[</B> (:dcx   dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>, n<SUB>1</SUB>, (<I>ed</I>,
			<I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>1</SUB>
			) . <I>md</I>* )  <I>nse</I><SUB>0</SUB><BR>
			end</TD>
	</TR>
</TABLE>
<BR>

<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">A duplicate namespace declaration is ignored.</TD>
	</TR>
	<TR>
		<TD COLSPAN="2"><B>QN[[</B>qn<SUB>0</SUB><B>]]</B> ==<SUB>q</SUB> <I>n</I><SUB>1</SUB>, <B>QN[[</B>l<SUB>1</SUB><B>]]</B>
			==<SUB>q</SUB> <I>l</I><SUB>2</SUB> |-<BR>
			<B>S[[</B> (:dcx dci (:ad<B> </B>qn<SUB>0</SUB> (:nsb (:qn 'xmlns' l<SUB>0</SUB>)
			nsn)) .  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>, <I>n</I>*<SUB>0</SUB>,
			<SUB> </SUB><I>n</I>*<SUB>1</SUB>, (((<I>nsb</I> l<SUB>0</SUB>, <I>ns</I>) .  <I>nse</I><SUB>0</SUB>
			) . <I>nse</I><SUB>1</SUB> ) . <I>md</I>* )  <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%"><B>S[[</B> (:dcx dci  dcl*) <B>]]</B> (<I>sc</I>, (<I>ed</I>, <I>n</I><SUB>1</SUB>,
			<I>n</I>*<SUB>0</SUB>, <SUB> </SUB><I>n</I>*<SUB>1</SUB>, (((<I>nsb</I> l<SUB>0</SUB>,
			<I>ns</I>) .  <I>nse</I><SUB>0</SUB> ) . <I>nse</I><SUB>1</SUB> ) . <I>md</I>* )
			 <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">A qualified name in the context of a matching binding is replaced by a universal
			name</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">(<I>ed</I>, (<I>qn</I> <I>p</I><SUB>0  </SUB><I>l</I><SUB>0</SUB>), <I>em</I><SUB>0</SUB>,
			<I>n</I>*<SUB>0</SUB>, <I>nse</I><SUB>0</SUB>), <I>isUniversalName(nse</I><SUB>0</SUB>(<I>p</I><SUB>0</SUB>))</TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">let <I>u</I><SUB>0</SUB> == <I>nse</I><SUB>0</SUB>(<I>p</I><SUB>0</SUB>)<BR>
			in<BR>
			(<I>ed</I>, <I>u</I><SUB>0</SUB>, <I>em</I><SUB>0</SUB>, <I>n</I>*<SUB>0</SUB>, <I>nse</I><SUB>0</SUB>)</TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">A qualified model name in the context of a matching binding is replaced by a universal
			name</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">(<I>ed</I>, <I>n</I><SUB>0</SUB>, <I>(n</I>*<SUB>0</SUB> . (<I>qn</I> <I>p</I><SUB>0
			 </SUB><I>l</I><SUB>0</SUB>) . <I>n</I>*<SUB>1</SUB>), <I>n</I>*<SUB>2</SUB>, <I>nse</I><SUB>0</SUB>),
			<I>isUniversalName(nse</I><SUB>0</SUB>(<I>p</I><SUB>0</SUB>))</TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">let <I>u</I><SUB>0</SUB> == <I>nse</I><SUB>0</SUB>(<I>p</I><SUB>0</SUB>)<BR>
			in<BR>
			(<I>ed</I>, <I>n</I><SUB>0</SUB>, <I>(n</I>*<SUB>0</SUB> . <I>u</I><SUB>0</SUB> .
			<I>n</I>*<SUB>1</SUB>), <I>n</I>*<SUB>2</SUB>, <I>nse</I><SUB>0</SUB>)</TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">A qualified attribute name in the context of a matching binding is replaced by a
			universal name</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">(<I>ed</I>, <I>n</I><SUB>0</SUB>, <I>em</I><SUB>0</SUB>, <I>(n</I>*<SUB>0</SUB> .
			(<I>qn</I> <I>p</I><SUB>0  </SUB><I>l</I><SUB>0</SUB>) . <I>n</I>*<SUB>1</SUB>),
			<I>nse</I><SUB>0</SUB>), <I>isUniversalName(nse</I><SUB>0</SUB>(<I>p</I><SUB>0</SUB>))</TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">let <I>u</I><SUB>0</SUB> == <I>nse</I><SUB>0</SUB>(<I>p</I><SUB>0</SUB>)<BR>
			in<BR>
			(<I>ed</I>, <I>n</I><SUB>0</SUB>, <I>em</I><SUB>0</SUB>, <I>(n</I>*<SUB>0</SUB> .
			<I>u</I><SUB>0</SUB> . <I>n</I>*<SUB>1</SUB>), <I>nse</I><SUB>0</SUB>)</TD>
	</TR>
</TABLE>
</P>

<P>
<TABLE BORDER="1" WIDTH="100%">
	<TR>
		<TD COLSPAN="2">An correspondence between content model identifier and element identifier based on
			the presence of a namespace binding in either  the containing element or the contained
			element leads to an identification of names and the propagation all namespace bindings
			from the containing element which are not shadowed by bindings in the contained element.
			For the purpose of comparison, the environments are combined such that, for the prefix
			respective the content model, the bindings in the containing element are supplemented
			- that is existing bindings remain visible, while for the prefix respective the contained
			element, the bindings are augmented - that is a binding in the contained element
			supercedes that of the containing element. The namespace environment of the contained
			element declaration is replaced with the extended</TD>
	</TR>
	<TR>
		<TD COLSPAN="2">supplementNSE( <I>nse</I><SUB>0</SUB> <I>nse</I><SUB>1</SUB>)(<I>p</I><SUB>0</SUB>)
			==<SUB>ns</SUB> extendNSE( <I>nse</I><SUB>0</SUB> <I>nse</I><SUB>1</SUB>)( <I>p</I><SUB>1</SUB>)<BR>
			|-<BR>
			<B>S[[</B> dcx0 <B>]]</B> (<I>sc</I>, (<I>ed</I>, (<I>qn</I> <I>p</I><SUB>0  </SUB><I>l</I><SUB>0</SUB>),
			<I>n</I>*<SUB>0</SUB>, <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB> ) . (<I>ed</I>,
			<I>n</I><SUB>1</SUB>, <I>(n</I>*<SUB>0</SUB> . (<I>qn</I> <I>p</I><SUB>1  </SUB><I>l</I><SUB>0</SUB>)
			. <I>n</I>*<SUB>1</SUB>), <I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>1</SUB>) . <I>md</I>*
			) <I>nse</I><SUB>0</SUB></TD>
	</TR>
	<TR>
		<TD WIDTH="20" VALIGN="TOP">==&gt;</TD>
		<TD WIDTH="50%">let <I>nse</I><SUB>2</SUB> = extendNSE( <I>nse</I><SUB>0</SUB> <I>nse</I><SUB>1</SUB>)
			in<BR>
			  let <I>un</I><SUB>0</SUB> =  (<I>nse</I><SUB>2</SUB>( <I>p</I><SUB>1</SUB>))(<I>qn</I>
			<I>p</I><SUB>1  </SUB><I>l</I><SUB>0</SUB>) in<BR>
			<B>S[[</B> dcx0 <B>]]</B> (<I>sc</I>, (<I>ed</I>, <I>un</I><SUB>0</SUB>, <I>n</I>*<SUB>0</SUB>,
			<I>n</I>*<SUB>1</SUB>, <I>nse</I><SUB>0</SUB> ) . (<I>ed</I>, <I>n</I><SUB>1</SUB>,
			<I>(n</I>*<SUB>0</SUB> . <I>un</I><SUB>0</SUB> . <I>n</I>*<SUB>1</SUB>), <I>n</I>*<SUB>1</SUB>,
			<I>nse</I><SUB>2</SUB>) . <I>md</I>* ) <I>nse</I><SUB>0</SUB></TD>
	</TR>
</TABLE>



</BODY>

</HTML>