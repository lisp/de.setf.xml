<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1"><!--
<DOCUMENTATION>
 <CHRONOLOGY>
  <DELTA><DATE>19971115</DATE>
   <A HREF="mailto:jaa%mecom-gmbh@mixx.de">jaa </A>:
   this document was composed to accompany the prototype distribution.
   covers background, program structure, and file organization.
   </DELTA>
  <DELTA><DATE>19971210</DATE>
   jaa:
   additions for model compiler and element matcher
   </DELTA>
  <DELTA><DATE>19980102</DATE>
   jaa: relation to other lisp serialization / representation efforts
   <DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
-->	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.3">	<TITLE>Common Lisp - XML</TITLE></HEAD><BODY TEXT="#000000" BGCOLOR="#E8E8E8"><H2>CL-XML: Event-Based Parsing</H2><P>20030408 (v 0.949)<BR><A HREF="mailto:James.Anderson@setf.de">james anderson</A>, <HR><BR><TABLE BORDER="1" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">	<TR>		<TD ALIGN="CENTER">			<P ALIGN="CENTER">[<A HREF="#Background">background</A>] [<A HREF="#ProgramInterface">program			interface</A>][<A HREF="#Examples">examples</A>]<A NAME="TOP"></A>		</TD>	</TR></TABLE><HR></P><P>The CL-XML processor can be invoked so as to communicate individual parse eventsto an invoking application. This behaviour can be instead of or in addition to thedefault behaviour as a <A HREF="dom-based-parsing.html">model-based</A> XML processor,An application can implement handlers for these events so as to control both theproducts of the parser and its resource usage. The mechanism operates in additionto <A HREF="xml-query-document-model.html">that</A> provided to specialize the implementationsof the document model nodes which the processor generates.</P><P>This document describes the mechanism for processing parse events and illustratesits use in an event-based RDF parser.<BR><TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">	<TR>		<TD><HR>		</TD>		<TD WIDTH="20" UNITS="PIXELS">[<A HREF="#TOP">Top</A>]</TD>	</TR></TABLE><H3><A NAME="Background"></A> Background</H3><P>The prevalent interface for <A HREF="http://www.megginson.com/SAX/event.html">event-based</A>XML processing is the Simple Application programming interface for XML, <A HREF="http://www.meggison.com/SAX/index.html">SAX</A>.SAX serves variously as an autonomous event-based XML parser for Java applications,as the standard event-driver for numerous Java-based parsers (<A HREF="http://xml.apache.org/xerces-j/index.html">Xerces</A>,<A HREF="http://java.sun.com/xml">JAXP</A>), and as the preprocessor for numerousother XML tools (<A HREF="http://users.iclway.co.uk/mhkay/saxon">SAXON</A>, <A HREF="http://technet.oracle.com/tech/xml/xdk_java.html">XDK</A>).</P><P>The core of the current generation of SAX-parsers is the <A HREF="sax-ContentHandler-methods.html"><CODE>org.xml.sax.ContentHandler</CODE></A>interface, which specifies the parsing events reported to the application. Whilethis interface does, in keeping with its name, provide a concise report of the documentcontent, the match with the CL-XML parser is too course-grained for it to serve asthe primary event-based interface. For this reason, two event-based interfaces areprovided. The first, lower level interface permits an application to specify a surrogate,a construction context, to handle an event stream is generated by the parser directlyin the course of phrase reduction. this permits the application detailed access toall lexical entitiesand to the the process by which the parser constructs the documentmodel. A higher level, SAX-equivalent, stream is generated by a special form of constructioncontext which uses the detailed events to build and generate SAX-equivalent events.</P><P><BR><HR></P><H3><A NAME="ProgramInterface"></A> Progam Interface</H3><H4>Construction Events</H4><P>The lower-level construction event interface comprises that subset of the parser'sreduction functions which are defined with a context parameter in addition to theparameters for the properties of the respective term which is to be reduced. Theinterface to these functions is governed by the naming and constitution of thoseterms in the BNF which denote model nodes and properties. The actual terms are specifiedby the implementation of the <CODE>bnfp:atn-constructor-specializer</CODE> methodspecialized for the <CODE>bnfp:atn-edge</CODE> class which is engaged during parsergeneration. Note that these functions are distinguished by case-sensitive names.In addition to these functions, several auxiliary functions are specialized in orderto provide finer grained control over the reduction/construction process. These aredistinguished by names which begin with <CODE>construct-</CODE>. (see &quot;<CODE>xml;code:xparser:xml-constructors.lisp</CODE>&quot;for the respective documentation.)</P><P><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|AttCharData-Constructor| context att-value name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|Attribute-Constructor| context att-value name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|CharData-Constructor| context character-data</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|CDataCharData-Constructor| character-data</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|Comment-Constructor| character-data</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-attribute-name context name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-attribute-plist context<BR>			&#160;&#160;&#160;&#160;&#160;attribute-value name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-construction-context context component</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-content-sequence context<BR>			&#160;&#160;&#160;&#160;&#160;content-sequence</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-elem-property-node context<BR>			&#160;&#160;&#160;&#160;&#160;prototype children</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-element-name context<BR>			&#160;&#160;&#160;&#160;&#160;name attr-plist+ns-node-sequence</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-element-node context name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-ns-node context attribute-value name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:construct-string-attr-node context<BR>			&#160;&#160;&#160;&#160;&#160;attribute-value name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|Content-Constructor| context<BR>			&#160;&#160;&#160;&#160;&#160;CDSect CharData Comment Element ParsedReference<BR>			&#160;&#160;&#160;&#160;&#160;Pi Reference</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|ContentSequence-Constructor| context<BR>			&#160;&#160;&#160;&#160;&#160;content-sequence</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|Document-Constructor| context<BR>			third-misc-sequence prolog root</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|Element-Constructor| context<BR>			&#160;&#160;&#160;&#160;&#160;content-sequence end-tag start-tag</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|ExtParsedEnt-Constructor| context<BR>			&#160;&#160;&#160;&#160;&#160;content-sequence text-decl</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|Pi-Constructor| context literal target</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|PiCharData-Constructor| context character-data</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><BR><TABLE BORDER="0" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:|STag-Constructor| context<BR>			&#160;&#160;&#160;&#160;&#160;attr-plist+ns-cons-sequence name</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE></P><P>An application may avail itself of this interface by specifying a context instancevalue for the keyword argument <CODE>:construction-context</CODE> to the <A HREF="cl-xml.html#Usage"><CODE>XMLP:document-parser</CODE></A>function. Where no value is specified, the document instance is used initially andis supplanted by the respective element instances over their respective extent. Theparser itself incorporates methods for these functions specialized accordingly togenerate a document model.</P><H4></H4><H4>Construction Contexts</H4><P>Use of the construction context interface is demonstrated in the two classes <CODE>XMLP:null-construction-context</CODE>and <CODE>NOX:sax-construction-context</CODE>.</P><P>Should an <A HREF="../demos/sax/null-construction-context.lisp"><CODE>XMLP:null-construction-context</CODE></A>instance be specified as the construction context, the parser produces a <CODE>NULL</CODE>result.</P><P><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>XMLP:null-construction-context</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Class]		</TD>	</TR>	<TR>		<TD COLSPAN="2">			<P>Where an <CODE>XMLP:null-construction-context</CODE> instance is furnished as			the <CODE>:construction-context</CODE> argument to <CODE>XMLP:document-parser</CODE>,			the respective specialized constructors generate null values for all reduction results.</P>			<P>In order to effect this, the context specializes the following functions with			methods which return <CODE>nil</CODE>:</P>			<BLOCKQUOTE>			<P><CODE>|Attribute-Constructor| |AttCharData-Constructor| |CharData-Constructor|			|CDataCharData-Constructor| |Comment-Constructor| construct-construction-context			|Document-Constructor| |Element-Constructor| |ExtParsedEnt-Constructor| |Pi-Constructor|			|PICharData-Constructor| |STag-Constructor|</CODE>			</BLOCKQUOTE>		</TD>	</TR></TABLE></P><P><BR>The <A HREF="../demos/sax/sax-construction-context.lisp"><CODE>NOX:sax-construction-context</CODE></A>class implementes methods for the low-level construction methods which direct a SAX1-equivalentparse event stream at the context instance's bound <CODE>consumer</CODE> property.The class is the basis of the bridge class used to parse RDF documents by drivingthe <A HREF="http://www.sourceforge.net/wilbur/">WILBUR</A> RDF parser through its<CODE>NOX:sax-consumer</CODE> interface. Note that, in comparison to an orthodoxSAX interface this is a hybrid event/tree interface in that various atomic propertiesand events are accumulated and passed to the event consumer as instances. See belowfor an <A HREF="#Example">example</A> which uses it to parse RDF.</P><P><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:sax-construction-context</CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Class]		</TD>	</TR>	<TR>		<TD COLSPAN="2">			<P>Where a <CODE>sax-construction-context</CODE> instance is furnished as the <CODE>:construction-context</CODE>			argument to <CODE>XMLP:document-parser</CODE>, the respective specialized constructors			direct a SAX1-equivalent parse event stream context instance's bound <CODE>consumer</CODE>			property.</P>			<P>In order to effect this, the context specializes the following functions with			methods which return <CODE>nil</CODE>:</P>			<BLOCKQUOTE>			<P><CODE>|CDataCharData-Constructor| |CharData-Constructor| construct-construction-context			construct-attribute-plist construct-ns-node |Document-Constructor| |STag-Constructor|			|Element-Constructor| |ExtParsedEnt-Constructor| |Pi-Constructor|</CODE>			</BLOCKQUOTE>		</TD>	</TR></TABLE></P><H4>Event Consumer Interface</H4><P>For convenience, the <CODE>NOX:sax-consumer</CODE> interface is summarized below.Note that this constitutes a SAX-1 equivalent interface with additional support fornamespaces.</P><P><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:char-content<BR>			(<I>self</I> NOX:sax-consumer) (<I>char-content</I> string) <I>mode</I></CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:end-document<BR>			(<I>self</I> NOX:sax-consumer) <I>mode</I></CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:end-element<BR>			(<I>self</I> NOX:sax-consumer) (<I>tag</I> open-tag) <I>mode</I></CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:proc-instruction<BR>			(<I>self</I> NOX:sax-consumer) (<I>tag</I> proc-instruction) <I>mode</I></CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:start-document<BR>			(<I>self</I> NOX:sax-consumer) <I>locator</I></CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE><TABLE BORDER="1" WIDTH="100%">	<TR>		<TD WIDTH="50%"><CODE>NOX:start-element<BR>			(<I>self</I> NOX:sax-consumer) (<I>tag</I> open-tag) <I>mode</I></CODE></TD>		<TD WIDTH="64" VALIGN="TOP">			<P ALIGN="RIGHT">[Generic Function]		</TD>	</TR></TABLE></P><P><TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">	<TR>		<TD><HR>		</TD>		<TD WIDTH="20" UNITS="PIXELS">[<A HREF="#TOP">Top</A>]</TD>	</TR></TABLE><H3><A NAME="Examples"></A> Examples</H3><P>A stream-based RDF parser demonstrates one way to use this event interface. Theimplementation specializes the <CODE>WILBUR:rdf-parser</CODE> class to use a <A HREF="../demos/sax/sax-construction-context.lisp"><CODE>NOX:sax-construction-context</CODE></A>,introduced above, as a SAX-equivalent driver to generate its parse events. The sourceto specialize the RDF parser's event producer class is minimal.</P><P><TABLE BORDER="1" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">	<TR>		<TD WIDTH="100%"><A HREF="../demos/rdf/rdf-inline-parser.lisp"><CODE>xml:demos;rdf;rdf-inline-parser.lisp</CODE></A></TD>	</TR>	<TR>		<TD WIDTH="100%">			<PRE>;;; -*- package: WILBUR; Syntax: Common-lisp; Base: 10 -*-(in-package &quot;WILBUR&quot;);; an xmlp-based rdf parser drives the wilbur event-based counterpart based on;; inline parser construction operations (defClass rdf-xmlp-parser (rdf-parser)  ()  (:default-initargs    :producer (make-instance 'nox::sax-construction-context                :consumer (make-instance 'rdf-syntax-normalizer))));;;;;;;;;; the top-level parse function(defGeneric parse-db-from-xmlp-stream (source &amp;rest options)  (:documentation   &quot;generate an rdf database from an input source.    uses an rdf parser specialized to translate xmlp parse events into the required    SAX-equivalent events.    includes a somewhat redundant method to map a string source to an URI as the    rdf parsing interface required that before the xmlp parser itself is called. &quot;)  (:method ((source t) &amp;rest options)           (apply #'parse-db-from-stream source (xqdm:uri source)                  :parser-class 'rdf-xmlp-parser                  options))  (:method ((source string) &amp;rest options)           (cond ((char= (char source 0) #\&lt;)                  (apply #'parse-db-from-xmlp-stream                         (make-instance 'vector-input-stream :vector source)                         options))                 (t                  (apply #'parse-db-from-xmlp-stream (xutils:make-uri source)                         options))))):EOF</PRE>		</TD>	</TR></TABLE></P><P>The implementation for the <CODE>NOX:sax-construction-context</CODE> class supplantsnumerous construction operators by specializing them to operate to the exclusionof the parser's internal methods. The excerpts below demonstrate how it supplants,respectively, operators which the xml parser would use to generate nodes in a documentmodel (<CODE>XMLP:|CharData-Constructor|</CODE>, <CODE>XMLP:|Element-Constructor|</CODE>,and <CODE>XMLP:|STag-Constructor</CODE>|) and one used to manipulate properties inthe parsing context (<CODE>XMLP:construct-ns-node</CODE>).</P><P><TABLE BORDER="1" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">	<TR>		<TD WIDTH="100%"><A HREF="../demos/rdf/rdf-inline-parser.lisp"><CODE>xml:demos;sax;</CODE></A><A HREF="../demos/sax/sax-construction-context.lisp"><CODE>sax-construction-context</CODE></A><A			HREF="../demos/rdf/rdf-inline-parser.lisp"><CODE>.lisp</CODE></A><CODE> (excerpted)</CODE></TD>	</TR>	<TR>		<TD WIDTH="100%">			<PRE>;;; -*- package: NOX; Syntax: Common-lisp; Base: 10 -*-(in-package &quot;NOX&quot;)</PRE>			<PRE>;;; ...</PRE>			<PRE>;;; the <CODE>xmlp:|CharData-Constructor|</CODE> method passes the character data through to;;; the event consumer through its <CODE>char-content</CODE> method. it returns nil to indicate;;; that the xml-parser itself should produce no result for this component.</PRE>			<PRE>(defMethod xmlp:|CharData-Constructor|           ((context sax-construction-context) (data string))  (setf data (collapse-whitespace data))  (when (plusp (length data))    (char-content (sax-producer-consumer context)                  data                  (sax-consumer-mode (sax-producer-consumer context)))    nil))</PRE>			<PRE>;;; ...;;; instead of binding the namespace prefix, as the parser's default method would,;;; the specialization simply returns the properties. the parser eventually furnishes;;; them together with attribute properties to the call to xmlp:|STag-Constructor|</PRE>			<PRE>(defMethod xmlp:construct-ns-node           ((context sax-construction-context) attribute-value name            &amp;optional (colon-position (position #\: name))            &amp;aux ns-name namespace)  (setf ns-name (xqdm:value-string attribute-value))  (unless (stringp ns-name)    (xqdm:xml-error &quot;namespace name syntax error: ~s: ~s.&quot; name attribute-value))  (when (and colon-position (zerop (length ns-name)))    (xqdm:xml-error xqdm:|NSC: No Null Namespace Bindings| :name name))  (setf namespace (xqdm:find-namespace ns-name :if-does-not-exist :create))  (xmlp:call-with-name-properties   #'(lambda (&amp;key local-part &amp;allow-other-keys) (cons local-part namespace))   name :colon-position colon-position :namespace xqdm:*xmlns-namespace*))</PRE>			<PRE>;;; ...;;; the distinction between the specialized method for xmlp:|Element-Constructor|;;; and that for xmlp:|STag-Constructor| demonstrates how these constructors;;; interact with the xml parser's internal state. where the element constructor;;; passes the event through the consumer's end-element method and produces no result,;;; the xmlp:|STag-Constructor| specialization not only generates a start-element;;; event, it also returns the resulting event instance. which xml parser then collects;;; among the terms in the Element phrase and supplies to the call to;;; xmlp:|Element-Constructor|</PRE>			<PRE>(defMethod xmlp:|Element-Constructor|           ((context sax-construction-context) (content* t) etag stag)  (when etag    (let ((close-tag (make-instance 'close-tag)))      (setf (tag-counterpart stag) close-tag            (tag-counterpart close-tag) stag)))  (end-element (sax-producer-consumer context) stag               (sax-consumer-mode (sax-producer-consumer context)))  nil)(defMethod xmlp:|STag-Constructor|           ((context sax-construction-context) attr-plist+ns-cons* name)  (let ((tag (make-instance 'open-tag))        (namespaces nil)        (attributes nil))    (xmlp:call-with-name-properties     #'(lambda (&amp;key namestring local-part namespace &amp;allow-other-keys)         (flet ((tag-attribute (&amp;key name att-value)                  (xmlp:call-with-name-properties                   #'(lambda (&amp;key local-part namespace &amp;allow-other-keys)                       (cons (concatenate 'string (xqdm:namespace-name namespace)                                          local-part)                             (xqdm:value-string att-value)))                   name))                (tag-namespace (name value)                  (cons (if (string-equal name xqdm:*xmlns-prefix-namestring*)                          nil                          name)                        value)))           (setf (token-string tag) (if (eq namespace xqdm:*null-namespace*)                                      local-part                                      (concatenate 'string                                                   (xqdm:namespace-name namespace)                                                   local-part))                 (tag-original-name tag) namestring)           (mapcar #'(lambda (attr-plist+ns-cons)                       (cond ((consp (rest attr-plist+ns-cons)) ;; an attribute                              (push (apply #'tag-attribute attr-plist+ns-cons)                                           attributes))                             (t                              (push (tag-namespace (first attr-plist+ns-cons)                                                   (rest attr-plist+ns-cons))                                    namespaces))))                   attr-plist+ns-cons*)           (setf (tag-attributes tag) attributes                 (tag-namespaces tag) namespaces)))     name)    (start-element (sax-producer-consumer context) tag                   (sax-consumer-mode (sax-producer-consumer context)))    tag))</PRE>			<PRE>;;; ...</PRE>		</TD>	</TR></TABLE></P><P>As a side note, it is also possible to drive the event-based interface to theRDF parser by generating a parse event stream while traversing a document model.This practice is demonstrated by the <A HREF="../demos/rdf/rdf-dom-parser.lisp"><CODE>WILBUR:rdf-dom-parserimplementation</CODE></A>, which is analogous to that for <CODE>NOX:sax-construction-context</CODE>.</P><P><TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="100%">	<TR>		<TD><HR>		</TD>		<TD WIDTH="24" UNITS="PIXELS">[<A HREF="#TOP">Top</A>]</TD>	</TR></TABLE><A HREF="/cl-http/standards/XSL/NOTE-xsl.html"><BR></A>&#169; setf.de 2003</BODY></HTML>