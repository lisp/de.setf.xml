;;; -*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: xml-path; -*-

#|
<DOCUMENTATION>
 <DESCRIPTION>
  a tokenizer for XPath is implemented based on the cl reader. this performs the lexical
  transform only.
  </DESCRIPTION>
 <COPYRIGHT YEAR='2001' AUTHOR='james adam anderson' MARK='(C)'
            href='file://xml/sysdcl.lisp' />
 <CHRONOLOGY>
  <DELTA DATE='20010118' AUTHOR='jaa'>initial version</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
|#

(in-package "XML-PATH")


#|
the XPath language lexical domain is specified in "REC-xpath-19991116".
the lexical analysis is implemented by modifying the readtable.
tokens are self-bound symbols in a special package.
they are generated by terminating reader macros which simply return the respetive token's
symbol.
where state is required, the special variable *xpath-token* is consulted.
look-ahead uses peek-char

|#


(eval-when (:execute :load-toplevel :compile-toplevel)
  (labels ((xpath-token-reader (name)
             #'(lambda (stream char)
                 (declare (ignore stream char))
                 name))
           (xpath-alternative-token-reader (name1 name2 test-char)
             #'(lambda (stream char)
                 (declare (ignore char))
                 (cond ((eql test-char (peek-char t stream nil nil))
                        ;; discard the second character in the token
                        (read-char stream)
                        name2)
                       (t name1))))
           (xpath-string-reader (test-char)
             (let ((buffer (make-array 0 :fill-pointer t :adjustable t)))
               #'(lambda (stream char)
                   (unless (eql char test-char)
                     (error "string reader for [~c] applied to [~c]." test-char char))
                   (setf (fill-pointer buffer) 0)
                   (loop (when (eql (setf char (read-char stream)) test-char)
                           (return (make-array (length buffer) :element-type 'character
                                               :initial-contents buffer)))
                         (vector-push-extend char buffer)))))
           
           (set-token-macro-character (character &optional (non-terminating nil))
             ;; a single-character token maps to a specific token, with termination by default
             (let ((token (intern (make-string 1 :initial-element character)
                                  *token-package*)))
               (set-macro-character character (xpath-token-reader token) non-terminating *xpath-readtable*)))
           (set-token-macro-string (string  &optional (non-terminating nil))
             ;; a string denotes two tokens which begin with the same character, with
             ;; termination by  default.
             (let ((token1 (intern (subseq string 0 1) *token-package*))
                   (token2 (intern string *token-package*)))
               (set-macro-character (schar string 0)
                                    (xpath-alternative-token-reader token1 token2 (schar string 1))
                                    non-terminating *xpath-readtable*))))
    
    
    (setf *xpath-readtable* (copy-readtable nil))
    (setf (readtable-case *xpath-readtable*) :preserve)
    (map nil #'set-token-macro-character "()[]@,|+=*$")
    (set-token-macro-character #\- t)
    (map nil #'set-token-macro-string '("::" "//" "<=" ">="))
    (set-token-macro-string ".." t)
    (set-macro-character #\' (xpath-string-reader #\') nil *xpath-readtable*)
    (set-macro-character #\" (xpath-string-reader #\") nil *xpath-readtable*)
    (set-token-macro-string "!=" nil)
    ;; end of xpath tokens
    ))


#|
section 3.7 describes the conditions wheere an NCName is recognized as a special term.
-> OperatorName
-> NodeType or FunctionName
-> AxisName


|#

(defun canonical-xpath-keyword (keyword)
  keyword)

(defun |xpath-token-reader| (reader)
  (let ((expr (funcall reader)))
    ;;(print expr)
    (when expr
      (cond ((stringp expr)
             ;;if a string is read, it was explicitly in quotes and is parsed as-is
             expr)
            ((numberp expr)
             ;; a number is also parsed as-is
             expr)
            ((symbolp expr) 
             ;; symbols are mostly what is read. check for, a canonical form
             (canonical-xpath-keyword expr))
            (t
             (warn "questionable token [~s]." expr)
             expr)))))

(defun xpath-tokenizer (input-str
                        &aux
                        (*readtable* *xpath-readtable*)
                        (*package* *token-package*)
                        #+:aclpc (allegro::*read-case* :leave))
  (let ((input-length (length input-str))
        (tokens (make-array 0 :fill-pointer 0 :adjustable t))
        (start 0)
        (expr nil))
    (flet ((reader ()
             (when (< start input-length)
               (multiple-value-bind (expr end)
                                    (read-from-string input-str nil nil :start start)
                 (setf start end)
                 expr))))
      (loop (setf expr (|xpath-token-reader| #'reader))
            (unless expr (return tokens))
            (vector-push-extend expr tokens)))))

(defun |Locationpath-Tokenizer| (x) (xpath-tokenizer x))
(defun |Expr-Tokenizer| (x) (xpath-tokenizer x))

;(locationpath-tokenizer "$x!=\"foo\"")

:EOF
