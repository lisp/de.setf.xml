;;; -*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: bnf-parser; -*-

#|
<DOCUMENTATION>
 <DESCRIPTION>
  this file comprises macros for defining an ATN net in lisp. note that this does not
  include compiling the network, just instantiating it. they are useful, at least, for
  bootstrapping a translator.
  the <A href='ebnf-grammar.atn'>EBNF</A> parser, for example, is coded in this form.
  see <A href='ATN-lisp-compiler.lisp'>ATN-lisp-compiler</A> for a reincarnation of
  this code which rewrites an ATN to a lisp function, and
  <A href='ATN-java-compiler.lisp'>ATN-java-compiler</A> for a reincarnation which
  rewrites to java.
  </DESCRIPTION>
 <COPYRIGHT YEAR='2001' AUTHOR='james adam anderson' MARK='(C)'
            href='file://bnfp/sysdcl.lisp' />
 <CHRONOLOGY>
  <DELTA DATE='20010122' AUTHOR='JAA'>
   array size as parameter</DELTA>
  <DELTA DATE='20010123' AUTHOR='JAA'>
   renamed as 'ATN-macros' since it comprises the node definition macros, <em>not</em>
   a compiler</DELTA>
  <DELTA DATE='20011001' AUTHOR='JAA'>
   <code>defatn-node</code> corrected to do non-destructive source manipulations.
   lispworks was re-expanding the expression when compiled.</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
|#

(in-package "BNFP")

(defvar *sequence*)
(defvar *sequence-length*)
(defvar *wfst-size* 2500)
(defparameter *wfst* (make-array *wfst-size* :initial-element nil))
(defparameter *pprint-structure* nil)

#|
(defparameter *character-cat-table*
  (make-array 256 :initial-element 'letter))

;;  (setf (svref *character-cat-table* (char-code char)) cat)
|#

;; the lexicon is a dictionary which maps either terminals to their category, or
;; maps categories to respective predicates. 
;; the use is peculiar, since the *predicate* table never appears to be used. both
;; criteria appear to come from the *lexicon* table...

(defparameter *lexicon*
  (make-hash-table :test #'equal))

(defparameter *predicates*
  (make-hash-table :test #'equal))

(defun setcat (item cats)
  (let ((entry (gethash item *lexicon*)))
    (setf (gethash item *lexicon*)
          (if entry
            (union cats entry)
            cats))))

(defun get-categories (lexicon item)
  (gethash item lexicon))

(defun get-category-predicate (lexicon category)
  (gethash category lexicon))

(defun setpred (cat func)
  (setf (gethash cat *lexicon*) func))

(defmacro deflexicon (&key lexems predicates)
  `(progn 
     (dolist (entry ',lexems)
       (setcat (first entry) (rest entry)))
     (dolist (pdef ',predicates)
       (apply #'setpred pdef))))

(defun callparser (name sequence)
  (setf *sequence* sequence)
  (setf *sequence-length* (length sequence))
  (setf *atn-structure* nil)
  (clear-wfst)
  (funcall name 0 nil))

(defun unparseable-sequence ()
  (let ((pos (loop for i from 0 to (1- (length *wfst*))
                   if (consp (aref *wfst* i))
                   maximize i)))
    (if (< pos *sequence-length*)
      (if (zerop pos) *sequence*
          (subseq *sequence* pos)))))

;;(unparseable-sequence)

(defun clear-wfst ()
  (dotimes (i (1- (length *wfst*)))
    (setf (aref *wfst* i) nil)))

(defmacro defatn
    (name name-of-start-node &key finally nodes); (max-length 500))
  `(let ()
     (declare (ftype (function (integer t) t) ,@(mapcar #'first nodes)))
     ,@(mapcar #'(lambda (k)
                   #+Genera (macroexpand (cons 'defatn-node k))
                   #-Genera (cons 'defatn-node k))
	       (reverse nodes)) ; reverse in order to avoid compiler warnings
     ;(setf *wfst* (make-array ,max-length :initial-element nil))
     (defun ,name (index register)
       (,name-of-start-node index register)
       ,(if finally
	    `(,finally *atn-structure*)
	  '*atn-structure*))
     ;; wg. compile-file
     (unless (compiled-function-p (symbol-function ',name)) (compile ',name))))

#|
;;; nb. (jaa) replaced with a combination of callparser and a the simpler code
;;; generated by the above macro.

(defmacro defatn
    (name name-of-start-node &key finally nodes (max-length 300))
  `(let ()
     ,@(mapcar #'(lambda (k)
                   (cons 'defatn-node k))
	       `,nodes)
     (setf *wfst* (make-array ,max-length :initial-element nil))
     (defun ,(parser-name name) (sequence)
       (setf *sequence* sequence)
       (setf *sequence-length* (length sequence))
       (setf *atn-structure* nil)
       (,name-of-start-node 0 nil)
       ,(if finally
	    `(,finally *atn-structure*)
	  '*atn-structure*))
     ;; wg. compile-file
     (unless (compiled-function-p (symbol-function ',name)) (compile ',name))))
|#

(defmacro defatn-node (name &rest kanten
                            &aux initially)
  (loop (case (first kanten)
          (:initially (pop kanten) (setf initially (pop kanten)))
          (t (return))))
  `(progn
     (defun ,name (index register)
       ,@(when initially `(,(subst '(get-objekt index) 'item initially)))
       ,@(mapcar 
          #'(lambda (kante)
              (setf kante 
                    (subst '(get-objekt index) 'item kante))
              (let ((typ (find-if #'kanten-typ? kante)))
                (if typ 
                  (apply (get typ 'define)
                         (if (kanten-typ? (car kante))
                           (cons t (cdr kante))
                           ;; 20011001 non-destructive is necessary: macroexpansion
                           ;; may repeat on the same form...
                           (remove typ kante)))
                  (error "Kantendefinition ist nicht zulaessig"))))
          kanten))
     (unless (compiled-function-p (symbol-function ',name)) (compile ',name))))

#|
(defmacro defatn-node (name &rest kanten)
  (pprint  `(defun ,name (index register)
      ,@(mapcar 
	 #'(lambda (kante)
	     (setf kante 
		   (subst '(get-objekt index) 'item kante))
	     (let ((typ (find-if #'kanten-typ? kante)))
	       (if typ 
		   (apply (get typ 'define)
			  (if (kanten-typ? (car kante))
			      (cons t (cdr kante))
			    (delete typ kante)))
		 (error "Kantendefinition ist nicht zulaessig"))))
	 kanten))))
|#

(defmacro defarc-type (name lambda-expression)
  `(setf (get ',name 'define)
     (compile nil ',lambda-expression)))

(defun get-objekt (index)
  (if (< index *sequence-length*)
      (elt *sequence* index)))

(defmethod has-category-p (lexicon item category)
  (and item
       (let ((p (get-category-predicate lexicon category)))
         (if p (funcall p lexicon item)
             (member category (get-categories lexicon item))))))

(defun is-token (lexicon x) 
  (declare (ignore lexicon))
  (and (not (null x))
       (not (has-category-p *lexicon* x 'metasymbol))))

#|
(defmethod kategorie? ((objekt symbol) kategorie)
  (get objekt kategorie))

(defmethod kategorie? ((object character) kategorie)
  (eq (svref *character-cat-table* (char-code object)) kategorie))
|#
(defun kanten-typ? (sexpr)
  (and (symbolp sexpr) (get sexpr 'define)))

(defun end-of-sequence-p (index)
  (= index *sequence-length*))

;;; Standardkanten: jump, cat, push, pop, word, test & type (fuer CL-Typen)

(defarc-type jump
  (lambda (test ziel &rest aktionen) 	 
    `(when ,test
       ,@aktionen (,ziel index register))))

(defarc-type pop
  (lambda (test netz &rest aktionen)
    (let ((ergebnis (second (member :ergebnis aktionen))))
      (and ergebnis 
	   (setf aktionen
	     (delete :ergebnis 
		     (delete ergebnis aktionen))))
      `(when ,test 
	 ,@aktionen
	 ,(or ergebnis
;`(push (cons ,ergebnis index) *atn-structure*) ;;???
	      `(pushnew (acons ',netz (reverse register) index)
		        *atn-structure*
                        :test #'equal))))))

(defarc-type push
  (lambda (test subnetz ziel &rest aktionen)
    `(when ,test
       ,@aktionen
       (mapc #'(lambda (ergebnis)
		 (,ziel (cdr ergebnis) (cons (car ergebnis) register)))
	     (or (assoc ',(if (consp subnetz) ;falls gesonderte
                            (cadr subnetz) ; Registerbezeichnung
			    subnetz)
			(elt *wfst* index)
                        :test #'equal)
		 ((lambda (anfang *atn-structure*)
		    (,(if (consp subnetz) ;car -> erster Knoten subnetz
                        (car subnetz)	; cadr -> Registername subnetz
			subnetz)
		     index nil)
                    (setf (elt *wfst* anfang) *atn-structure*))
		  index nil))))))


(defarc-type push
  (lambda (test subnetz ziel &rest aktionen)
    `(when ,test
       ,@aktionen
        (dolist (ergebnis (parse-subnet ',(if (consp subnetz) ;falls gesonderte
                                             (cadr subnetz) ; Registerbezeichnung
                                             subnetz)
                           index))
           (,ziel (cdr ergebnis) (cons (car ergebnis) register))))))

(defun fequal (x y) (equal x y))

(defun wfst-entry (net index)
  (cdr (assoc net (elt *wfst* index) :test #'fequal)))

(defun put-wfst-entry (index net structure)
   (push (cons net structure) (elt *wfst* index)))

(defun parse-subnet (net index)
  (or (wfst-entry net index)
      (let ((anfang index)
            (*atn-structure* nil))
        (funcall net index nil)
        (put-wfst-entry anfang net *atn-structure*)
        *atn-structure*)))


(defarc-type cat
  (lambda (test kategorie ziel &rest aktionen &aux ergebnis initially)
    (loop (case (first aktionen)
            (:ergebnis (pop aktionen) (setf ergebnis (pop aktionen)))
            (:initially (pop aktionen) (setf initially (pop aktionen)))
            (t (return))))
    `(progn ,@(when initially `(,(subst '(get-objekt index) 'item initially)))
            (and ,test
                 (has-category-p *lexicon* (get-objekt index) ',kategorie)
                 (progn ,@aktionen
                        (,ziel (1+ index)
                               ,(or ergebnis
                                    `(acons ',kategorie
                                            (get-objekt index)
                                            register))))))))

(defarc-type type
  (lambda (test type ziel &rest aktionen)
    (let ((ergebnis (second (member :ergebnis aktionen))))
      (and ergebnis (delete :ergebnis 
			    (delete ergebnis aktionen)))
      `(and ,test
	    (typep (get-objekt index) ',type)
	    (progn ,@aktionen
		   (,ziel (1+ index)
			  ,(or ergebnis
			       `(acons ',type
				       (get-objekt index)
				       register))))))))

(defarc-type word
  (lambda (test word ziel &rest aktionen)
    (let ((ergebnis (second (member :ergebnis aktionen))))
      (and ergebnis (delete :ergebnis 
			    (delete ergebnis aktionen)))
      `(and ,test
	    (equalp (get-objekt index) ',word)
	    (progn ,@aktionen
		   (,ziel (1+ index) 
                          ,(or ergebnis
                               `(cons '(word . ,word)
                                      register))))))))

(defarc-type test
  (lambda (test ziel &rest aktionen)
    (let ((ergebnis (second (member :ergebnis aktionen))))
      (and ergebnis (delete :ergebnis 
			    (delete ergebnis aktionen)))
      `(and ,test
	    (progn ,@aktionen
		   (,ziel (1+ index)
			  ,(or ergebnis
			       `(acons 'value
				       (get-objekt index)
				       register))))))))

;;;
;;; Einfache Ausgabe des Strukturbaums
;;;

(defun pprint-tree (tree stream i)
  (cond ((consp tree)
         (if (listp (cdr tree))
           (map nil #'(lambda (x) (pprint-tree x stream (+ i 3)))
                tree)
           (format stream "~%~vt~A: ~A" (+ i 3) (car tree) (cdr tree))))
        (t (format stream "~%~vt~A" i tree))))

(defun print-first-result (structure)
  (pprint-tree (caar structure) t 0)
  (caar structure)
  ;(values)
  )

(defun pprint-results (structures)
  (if *pprint-structure* 
    (dolist (x structures)
      (pprint-tree x t 0)))
  structures)

:eof