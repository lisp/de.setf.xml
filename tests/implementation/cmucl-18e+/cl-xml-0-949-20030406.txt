
* (software-version)

"Linux version 2.4.18-686-smp (herbert@gondolin) (gcc version 2.95.4 20011002 (Debian prerelease)) #1 SMP Sun Apr 14 12:07:19 EST 2002"
NIL
* (machine-version)

"X86"
* (lisp-implementation-version)

"18e 2003-03-28--17-00-33 src-head"
* (setq *load-verbose* t)

T
* (setq *compile-verbose* nil)

NIL
* "CMU Common Lisp 18e 2003-03-28--17-00-33 src-head, running on spe140
With core: /house/janson/cmucl-20030328T172037-i686/lib/cmucl/lib/lisp.core
Dumped on: Fri, 2003-03-28 11:14:05-05:00 on debian
See <http://www.cons.org/cmucl/> for support information.
Loaded subsystems:
    Python 1.1, target Intel x86
    CLOS based on Gerd's PCL 2003/03/22 16:15:17
"

"CMU Common Lisp 18e 2003-03-28--17-00-33 src-head, running on spe140
With core: /house/janson/cmucl-20030328T172037-i686/lib/cmucl/lib/lisp.core
Dumped on: Fri, 2003-03-28 11:14:05-05:00 on debian
See <http://www.cons.org/cmucl/> for support information.
Loaded subsystems:
    Python 1.1, target Intel x86
    CLOS based on Gerd's PCL 2003/03/22 16:15:17
"
* (setq *compile-print* nil)

NIL
* 
(require :gray-streams)

; Loading #p"/house/janson/cmucl-20030328T172037-i686/lib/cmucl/lib/subsystems/gray-streams-library.x86f".
T
* (setq EXTENSIONS:*GC-VERBOSE* nil)

NIL
* (setq EXTENSIONS:*INLINE-EXPANSION-LIMIT* 2)

2
* (load "load")

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/load.lisp".
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/library/define-system.lisp".

; In: DEFMETHOD EXECUTE-SYSTEM-OPERATIONS (CONS CONS)

;   (DEFMETHOD EXECUTE-SYSTEM-OPERATIONS
;              (# # &AUX EFFECTIVE-SYSTEMS EFFECTIVE-COMPONENTS ...)
;              (DECLARE #)
;              (WHEN # #)
;              ...)
; --> PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *SYSTEMS* *OPERATIONS*)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #)
;       ...)
; Note: Declaring special variable *OPERATIONS* to be ignored.
; 
; Note: Declaring special variable *SYSTEMS* to be ignored.
; 

; In:
;     LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *SYSTEMS* *OPERATIONS*)

;   #'(LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *SYSTEMS* *OPERATIONS*)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #)
;       ...)
; Note: Declaring special variable *OPERATIONS* to be ignored.
; 
; Note: Declaring special variable *SYSTEMS* to be ignored.
; 

; Compilation unit finished.
;   2 notes


;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/sysdcl.lisp".

;;; Loading #p"/house/janson/cmucl-20030328T172037-i686/lib/cmucl/lib/subsystems/gray-streams-library.x86f".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/patch/cmucl.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/library/de/setf/utility/package.fasl".

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/library/de/setf/utility/string.lisp

; In: DEFUN CONCATENATE-STRING*

;   (COND (# # # # STRING) (T ""))
; --> IF COND IF PROGN 
; ==>
;   ""
; Note: Deleting unreachable code.
; 
;   (DEFUN CONCATENATE-STRING* (LIST &AUX # STRING #)
;     (DECLARE # # #)
;     (COND # #))
; Warning: The binding of STRING is not a (VALUES &OPTIONAL BASE-STRING &REST T):
;   NIL
; 
; Note: Deleting unreachable code.
; 
;   (MAKE-STRING LENGTH)
; ==>
;   LENGTH
; Note: Deleting unreachable code.
; 
; --> MAKE-ARRAY EXTENSIONS:TRULY-THE KERNEL:ALLOCATE-VECTOR 
; ==>
;   LENGTH
; Note: Deleting unreachable code.
; 
;   (COND (# # # # STRING) (T ""))
; --> IF PROGN 
; ==>
;   STRING
; Note: Deleting unreachable code.
; 
;   (STRINGP ELT)
; Note: Deleting unreachable code.
; 
;   (LENGTH ELT)
; ==>
;   ELT
; Note: Deleting unreachable code.
; 
;   (DOTIMES (I #) (DECLARE #) (SETF # #) (INCF INDEX))
; --> DO BLOCK LET TAGBODY UNLESS COND IF NOT IF >= IF < 
; ==>
;   I
; Note: Deleting unreachable code.
; 
;   (SETF (SCHAR STRING INDEX) (CHAR ELT I))
; --> COMMON-LISP::%SCHARSET COMMON-LISP::%ASET THE 
; ==>
;   STRING
; Note: Deleting unreachable code.
; 
;   #'(LAMBDA (REST &AUX #) (ETYPECASE ELT # # #) (WHEN ELT #))
; Note: Deleting unreachable code.
; 
;   (CONCATENATE-STRING* ELT)
; Note: Deleting unreachable code.
; 
;   (WHEN ELT (INCF LENGTH #))
; --> COND IF 
; ==>
;   ELT
; Note: Deleting unreachable code.
; 
;   (INCF LENGTH (LENGTH ELT))
; --> LET* + 
; ==>
;   LENGTH
; Note: Deleting unreachable code.
; 

; In: DEFUN STRING+

;   (SETF (FIRST DESIGNATOR) (MAKE-STRING 1 :INITIAL-ELEMENT DESIGNATOR))
; --> COMMON-LISP::%RPLACA 
; ==>
;   DESIGNATOR
; Warning: Result is a BASE-CHAR, not a (VALUES &OPTIONAL CONS &REST T).
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/library/de/setf/utility/string.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/library/de/setf/utility/conditions.fasl".

Warning:  redefining SIMPLE-CONDITION-FORMAT-ARGUMENTS
Warning:  redefining SIMPLE-CONDITION-FORMAT-CONTROL

; In: LAMBDA (#:G1557 #:G1558 #:MEMF1559)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/library/de/setf/utility/test.lisp

; In: DEFUN TEST-OUTPUT

;   (DEFUN TEST-OUTPUT (&KEY #)
;     (DECLARE #)
;     (FLET #
;       #))
; Note: Variable WINDOW-TITLE-P defined but never used.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/library/de/setf/utility/test.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/package.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/clifs/inference-system-classes.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/clifs/inference-units.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-parameters.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-parser/atn-classes.lisp

; In: DEFMETHOD BIND-NET (ATN)

;   (ETYPECASE EDGE (PUSH-ATN-EDGE #) (JUMP-ATN-EDGE #) (OR-ATN-EDGE #) ...)
; --> LET COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-classes.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-macros.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/ebnf-tokenizer.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-parser/ebnf-to-atn-translator.lisp

; In: DEFMETHOD PRINT-OBJECT (BNF-QEXPR T)

;   (TYPECASE OBJECT
;     (BNF-ONE-EXPR NIL)
;     (BNF-PLUS-EXPR "+")
;     (BNF-OPT-EXPR "?")
;     ...)
; --> LET COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN RECLASSIFY-BNF-SYMBOLS

;   (TYPEP BNF-SYMBOL 'BNF-CELL-SYMBOL)
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN ENSURE-CATEGORY-OBJECTS

;   (TYPECASE EDGE (CAT-ATN-EDGE #) (OR-ATN-EDGE #))
; --> LET COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN BUILD-ATN-LEXICON

;   (TYPEP LHS 'BNF-INDIRECT-CAT-SYMBOL)
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/ebnf-to-atn-translator.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-parser/atn-macro-to-canonic-form.lisp

; In: DEFMETHOD ATN-CANONIC-FORM ((EQL 'DEFLEXICON) T)

;   (TYPEP X 'BNF-TABLE-CELL)
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN ENSURE-DEF-OBJECT

;   (TYPEP DEF 'BNF-TABLE-CELL)
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-macro-to-canonic-form.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/ebnf-grammar.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-parser/atn-runtime.lisp

; In: DEFUN COLLECT-ASSOCIATION-LIST

;   (DECF COUNT)
; --> LET* 
; ==>
;   (SETQ COUNT #:G6)
; Note: Doing signed word to integer coercion (cost 20), for:
;     The first argument of CHECK-FIXNUM.
; 

; In: DEFUN COLLECT-ASSOCIATION-VECTOR

;   (DECF COUNT)
; --> LET* 
; ==>
;   (SETQ COUNT #:G6)
; Note: Doing signed word to integer coercion (cost 20), for:
;     The first argument of CHECK-FIXNUM.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-runtime.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/conditions.fasl".


; In: LAMBDA (#:G4195 #:G4196 #:MEMF4197)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN #))
; Note: Variable CONDITION defined but never used.
; 
; Note: Variable STREAM defined but never used.
; 

; In: LAMBDA (#:G4212 #:G4213 #:MEMF4214 #:MEMF4215)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-parser/atn-lisp-compiler.lisp

; In: DEFMETHOD COMPILE-ATN-SYSTEM (ATN-SYSTEM)

;   (DEFMETHOD COMPILE-ATN-SYSTEM
;              (# &KEY COMPILE # LOAD ...)
;              "compile an atn system. may be directly evaluated oremitted to a file and compiled from there."
;              (DECLARE #)
;              ...)
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA
;         (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *GRAMMAR-SYSTEM
;          PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #) ..)
; Note: Declaring special variable *GRAMMAR-SYSTEM to be ignored.
; 

; In: DEFMETHOD COMPILE-ATN-SYSTEM (STRING)

;   (DEFMETHOD COMPILE-ATN-SYSTEM
;              (# &REST KEYS &KEY # ...)
;              "compile a bnf grammar to an atn system and from there to a lisp parser implementation."
;              (DECLARE #)
;              ...)
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *GRAMMAR PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #)
;       ...)
; Note: Declaring special variable *GRAMMAR to be ignored.
; 

; In: DEFMETHOD COMPILE-ATN-SYSTEM (PATHNAME)

;   (DEFMETHOD COMPILE-ATN-SYSTEM
;              (# &REST KEYS &KEY &ALLOW-OTHER-KEYS)
;              "read a bnf grammar from a file and compile it to a parser."
;              (DECLARE #)
;              ...)
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA
;         (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *GRAMMAR-PATHNAME
;          PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #) ..)
; Note: Declaring special variable *GRAMMAR-PATHNAME to be ignored.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-lisp-compiler.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-parser/atn-regex.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/parameters.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/cllib.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/base/utils.lisp

; In: DEFUN MAKE-FILE-URL

;   (ETYPECASE DEFAULTS (# # #) (STRING #) (PATHNAME #) ...)
; --> LET COND IF TYPEP LET OR LET IF OR TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN MAKE-URI

;   (ETYPECASE BASE (FILE-URL #) (NULL #) (PATHNAME #) ...)
; --> LET COND IF COND IF COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/utils.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/parsetable.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/vector-stream.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/base/www-utils-ersatz.lisp

; In: DEFUN HTTP::COPY-VECTOR-PORTION

;   (LOOP FOR IDX1 UPFROM FROM-START ...)
; --> BLOCK LET LET ANSI-LOOP::LOOP-BODY TAGBODY WHEN COND IF >= IF 
; ==>
;   (< IDX1 #:G0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a SINGLE-FLOAT.
;     The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a DOUBLE-FLOAT.
;     The second argument is a REAL, not a SINGLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
;     The second argument is a REAL, not a RATIONAL.
; 
; ==>
;   (< IDX2 #:G1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a SINGLE-FLOAT.
;     The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a DOUBLE-FLOAT.
;     The second argument is a REAL, not a SINGLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
;     The second argument is a REAL, not a RATIONAL.
; 
; ==>
;   (< IDX1 #:G0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a SINGLE-FLOAT.
;     The second argument is a REAL, not a DOUBLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a DOUBLE-FLOAT.
;     The second argument is a REAL, not a SINGLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
;     The second argument is a REAL, not a RATIONAL.
; 
;   (SETF (AREF TO-VECTOR IDX2) (AREF FROM-VECTOR IDX1))
; --> COMMON-LISP::%ASET LET* 
; ==>
;   (KERNEL:DATA-VECTOR-SET ARRAY KERNEL:INDEX C::NEW-VALUE)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
;   (AREF FROM-VECTOR IDX1)
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
;   (LOOP FOR IDX1 UPFROM FROM-START ...)
; --> BLOCK LET LET ANSI-LOOP::LOOP-BODY TAGBODY WHEN COND IF >= IF 
; ==>
;   (< IDX1 #:G0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline float comparison (cost 3) because:
;     The first argument is a REAL, not a DOUBLE-FLOAT.
;     The second argument is a REAL, not a DOUBLE-FLOAT.
;     Unable to do inline float comparison (cost 3) because:
;     The first argument is a REAL, not a SINGLE-FLOAT.
;     The second argument is a REAL, not a SINGLE-FLOAT.
;     etc.
; 
; ==>
;   (< IDX2 #:G1)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline float comparison (cost 3) because:
;     The first argument is a REAL, not a DOUBLE-FLOAT.
;     The second argument is a REAL, not a DOUBLE-FLOAT.
;     Unable to do inline float comparison (cost 3) because:
;     The first argument is a REAL, not a SINGLE-FLOAT.
;     The second argument is a REAL, not a SINGLE-FLOAT.
;     etc.
; 
;   (AREF FROM-VECTOR IDX1)
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 
;   (SETF (AREF TO-VECTOR IDX2) (AREF FROM-VECTOR IDX1))
; --> COMMON-LISP::%ASET LET* 
; ==>
;   (KERNEL:DATA-VECTOR-SET ARRAY KERNEL:INDEX C::NEW-VALUE)
; Note: Forced to do full call.
;     Unable to do inline array store (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The third argument is a T, not a (COMPLEX SINGLE-FLOAT).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array store (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The third argument is a T, not a SINGLE-FLOAT.
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 
;   (LOOP FOR IDX1 UPFROM FROM-START ...)
; --> BLOCK LET LET ANSI-LOOP::LOOP-BODY TAGBODY WHEN COND IF >= IF 
; ==>
;   (< IDX1 #:G0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline float comparison (cost 3) because:
;     The first argument is a REAL, not a DOUBLE-FLOAT.
;     The second argument is a REAL, not a DOUBLE-FLOAT.
;     Unable to do inline float comparison (cost 3) because:
;     The first argument is a REAL, not a SINGLE-FLOAT.
;     The second argument is a REAL, not a SINGLE-FLOAT.
;     etc.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/www-utils-ersatz.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/base/tokenizer.lisp

; In: DEFUN HASH-STRING

;   (WITH-STACK-SUBSTRING (STR STRING :START START :END ...)
;    (NSTRING-UPCASE STR) (SXHASH STR))
; --> LET* OR LET IF OR LENGTH 
; ==>
;   STRING
; Note: Deleting unreachable code.
; 
;   (WITH-STACK-SUBSTRING (STR STRING :START START :END ...) (SXHASH STR))
; --> LET* OR LET IF OR LENGTH 
; ==>
;   STRING
; Note: Deleting unreachable code.
; 
;   (DEFUN HASH-STRING (STRING &OPTIONAL # END #)
;     (DECLARE #)
;     (ECASE HASH-MASK # #))
; ==>
;   (C::%FUNCALL
;    #<LAMBDA #x485159B5  NAME= NIL  TYPE= #  WHERE-FROM= :DEFINED  VARS= #>
;    STRING
;    START
;    NIL)
; Warning: A possible binding of END is not a (VALUES &OPTIONAL FIXNUM &REST T):
;   NIL
; 

; In: LAMBDA (MAX-SIZE)

;   (MOD PRIME+2 FACTOR)
; --> BLOCK LET 
; ==>
;   (REM NUMBER KERNEL::DIVISOR)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/base/tokenizer.lisp

; In: DEFUN PRIME-NUMBERS-FOR-TOKENIZER-SYSTEM

;   (MOD PRIME+2 FACTOR)
; --> BLOCK LET 
; ==>
;   (REM NUMBER KERNEL::DIVISOR)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN SELECT-TABLE-SIZE

;   (ERROR
;    "Attempt to create a tokenizer table larger than the maximum implementation size, ~D."
;    *TOKENIZER-MAXIMUM-SIZE*)
; Note: Deleting unreachable code.
; 

; In: DEFUN MAP-TOKENS

;   (ENTRY-VALID-P ENTRY)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN %REHASH-TOKENIZER

;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ + MOD BLOCK LET 
; ==>
;   (REM NUMBER KERNEL::DIVISOR)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
; --> 1+ + MOD BLOCK LET IF AND IF NOT IF ZEROP 
; ==>
;   (= REM 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 
; --> 1+ + MOD BLOCK LET IF 
; ==>
;   (+ REM KERNEL::DIVISOR)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
;   (LOOP WITH HASH = (ENTRY-HASH ENTRY) ...)
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < 
; --> DECF LET* 
; ==>
;   (- #:G2 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G2) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
;   (LOOP WITH COUNT FIXNUM = ...)
; --> BLOCK LET LET ANSI-LOOP::LOOP-BODY TAGBODY SETQ LENGTH 
; ==>
;   (C::VECTOR-LENGTH VECTOR)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY * (*)).
; 
; --> BLOCK LET LET ANSI-LOOP::LOOP-BODY TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ 
; --> SETQ AREF LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ + MOD BLOCK LET IF 
; ==>
;   (+ REM KERNEL::DIVISOR)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;     The first argument is a REAL, not a (SIGNED-BYTE 32).
;     The result is a REAL, not a (SIGNED-BYTE 32).
;     etc.
; 
;   (LOOP WITH COUNT FIXNUM = ...)
; --> BLOCK LET LET ANSI-LOOP::LOOP-BODY TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ 
; --> SETQ AREF LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 
;   (LOOP WITH HASH = (ENTRY-HASH ENTRY) ...)
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < 
; --> DECF LET* 
; ==>
;   (- #:G2 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G2) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 

; In: DEFUN %TOKENIZE

;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (VALUES # NIL) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ + 
; ==>
;   (MOD (THE FIXNUM HASH) (THE FIXNUM #))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G27 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G27) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G27 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G27) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN TOKENIZE

;   (%TOKENIZE TOKENIZER (TOKENIZER-MASK TOKENIZER) STRING START ...)
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WHEN COND IF AND IF 
; ==>
;   (MULTIPROCESSING::ERROR-CHECK-LOCK-P LOCK)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G27 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G27) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G27 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G27) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN %GET-TOKEN

;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (VALUES # NIL) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ + 
; ==>
;   (MOD (THE FIXNUM HASH) (THE FIXNUM #))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN GET-TOKEN

;   (%GET-TOKEN TOKENIZER (TOKENIZER-MASK TOKENIZER) STRING START ...)
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WHEN COND IF AND IF 
; ==>
;   (MULTIPROCESSING::ERROR-CHECK-LOCK-P (TOKENIZER-LOCK TOKENIZER))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET WITH-LOCK-HELD MULTIPROCESSING:WITH-LOCK-HELD LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN WITH-TOKENIZING LET* 
; --> WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN INSERT-TOKEN

;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (SETF # TOKEN) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ + 
; ==>
;   (MOD (THE FIXNUM HASH) (THE FIXNUM #))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;   (SETF (ENTRY-VALUE ENTRY) TOKEN)
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL 
; ==>
;   (C::%FUNCALL #'(SETF ENTRY-VALUE) #:G16 #:G17)
; Warning: Result is a T, not a (VALUES T T).
; 
;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (SETF # TOKEN) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
;   (SUBSEQ STRING START END)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR VECTOR CONS NULL), not a SIMPLE-BASE-STRING.
; 
;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (SETF # TOKEN) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G11 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G11) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN REMOVE-TOKEN

;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (MULTIPLE-VALUE-PROG1 # # #) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ + 
; ==>
;   (MOD (THE FIXNUM HASH) (THE FIXNUM #))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;   (VALUES NIL)
; --> PROG1 LET 
; ==>
;   #:G23
; Warning: This is not a (VALUES T T):
;   NIL
; 
;   (WITH-TOKENIZING (TOKENIZER HASH-MASK HASH STRING START ...) :ENTRY-FOUND
;    (MULTIPLE-VALUE-PROG1 # # #) :ENTRY-NOT-FOUND ...)
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G19 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G19) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY PROGN WHEN COND IF AND IF AND IF AND IF 
; --> AND %%TOKEN-EQUAL ECASE LET COND IF COND IF PROGN %%TOKEN-EQUAL STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < DECF LET* 
; ==>
;   (- #:G19 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G19) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY IF ANSI-LOOP::LOOP-REALLY-DESETQ SETQ 
; --> COMPUTE-NEXT-INDEX LET + THE OR LET IF OR SETQ COMPUTE-SECONDARY-OFFSET 
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> LET* WITH-FAST-ARRAY-REFERENCES LET LOCALLY LOOP BLOCK LET LET LET 
; --> ANSI-LOOP::LOOP-BODY LET TAGBODY ANSI-LOOP::LOOP-REALLY-DESETQ SETQ AREF 
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN COLLISION-MAP

;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ + 
; ==>
;   (MOD (THE FIXNUM HASH) (THE FIXNUM #))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;   (LOOP WITH NUM-COLLISIONS FIXNUM = ...)
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < 
; --> DECF LET* 
; ==>
;   (- #:G16 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G16) 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a REAL, not a FLOAT.
; 
;   (INCF TOTAL-COLLISIONS NUM-COLLISIONS)
; --> LET* 
; ==>
;   (+ TOTAL-COLLISIONS NUM-COLLISIONS)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
;   (INCF DELETED-ENTRY-COLLISIONS)
; --> LET* 
; ==>
;   (+ DELETED-ENTRY-COLLISIONS 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
;   (AREF TABLE INDEX)
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a VECTOR, not a SIMPLE-ARRAY.
; 
;   (LOOP WITH NUM-COLLISIONS FIXNUM = ...)
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP < 
; --> DECF LET* 
; ==>
;   (- #:G16 1)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
; --> BLOCK LET LET LET ANSI-LOOP::LOOP-BODY LET TAGBODY WHEN COND IF MINUSP 
; ==>
;   (< (DECF #:G16) 0)
; Note: Forced to do GENERIC-< (cost 10).
;     Unable to do inline fixnum comparison (cost 3) because:
;     The first argument is a REAL, not a FIXNUM.
;     Unable to do inline fixnum comparison (cost 4) because:
;     The first argument is a REAL, not a FIXNUM.
;     etc.
; 
;   (COMPUTE-SECONDARY-OFFSET HASH MODULUS)
; --> 1+ 
; ==>
;   (+ (MOD # #) 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a REAL, not a FIXNUM.
;     The result is a REAL, not a FIXNUM.
;     etc.
; 
;   (AREF TABLE INDEX)
; --> LET* 
; ==>
;   (KERNEL:DATA-VECTOR-REF ARRAY KERNEL:INDEX)
; Note: Forced to do full call.
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY
;                                            (COMPLEX SINGLE-FLOAT) (*)).
;     The result is a T, not a (COMPLEX SINGLE-FLOAT).
;     Unable to do inline array access (cost 5) because:
;     The first argument is a VECTOR, not a (SIMPLE-ARRAY SINGLE-FLOAT (*)).
;     The result is a T, not a SINGLE-FLOAT.
;     etc.
; 
;   (INCF TOTAL-COLLISIONS NUM-COLLISIONS)
; --> LET* 
; ==>
;   (+ TOTAL-COLLISIONS NUM-COLLISIONS)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     Unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;     The first argument is a NUMBER, not a (SIGNED-BYTE 32).
;     The result is a NUMBER, not a (SIGNED-BYTE 32).
;     etc.
; 
;   (INCF DELETED-ENTRY-COLLISIONS)
; --> LET* 
; ==>
;   (+ DELETED-ENTRY-COLLISIONS 1)
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     etc.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/tokenizer.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/base/conditions.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xqdm-namespaces.lisp

; In: DEFGENERIC QNAME-EQUAL

;   (DEFGENERIC QNAME-EQUAL
;               (Q1 Q2)
;               (:DOCUMENTATION
;                "compare qualified names: values are equal if eq or, if not yet interned, they can be
;     literally equal and in the same qualified name context.
 ..))
; --> PROGN PUSH LET* LET* DEFMETHOD PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; --> FUNCTION MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK IF IF IF 
; --> STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR SYMBOL
;                                 BASE-CHAR
;                                 BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; ; [Last message occurs 2 times]

; --> PROGN PUSH LET* LET* DEFMETHOD PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; --> FUNCTION MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK IF IF LET IF 
; --> STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR SYMBOL
;                                 BASE-CHAR
;                                 BASE-STRING), not a SIMPLE-BASE-STRING.
;     The second argument is a (OR SYMBOL
;                                  BASE-CHAR
;                                  BASE-STRING), not a SIMPLE-BASE-STRING.
; ; 

; Warning: KEYWORD also exports the following symbols:
;   (:STOPPED :MAKE-OLD-FP-SAVE-LOCATION :PROMPT :DEFINITION-SOURCE
;    :WAIT-FUNCTION-ARGS ...)
; ; 

; Warning: KEYWORD also exports the following symbols:
;   (:STOPPED :MAKE-OLD-FP-SAVE-LOCATION :PROMPT :DEFINITION-SOURCE
;    :WAIT-FUNCTION-ARGS ...)
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-namespaces.fasl".

Warning:  KEYWORD also exports the following symbols:
  (:STOPPED :MAKE-OLD-FP-SAVE-LOCATION :PROMPT :DEFINITION-SOURCE
   :WAIT-FUNCTION-ARGS :WARN :IN-OUT :? :C :E :H :L :FOREIGN-FUNCTION :SIGSEGV
   :TRANSLATION :THRESHOLD :NUMBER-STACK-P :NORMAL :RELATIVEP :LAST-OFFSET
   :ISO8601 :INFINITY-DATA := :UNDEFINED-FUNCTION :FASL-FILE-IMPLEMENTATION :D
   :QUALITY :SGI :N :SHLVL :S :SIMPLE :LINUX :LINES :ARGLIST :STORAGE-INFO
   :CONSTRAINTS :UTF-16-21 :DATE-FIRST :CONDITION-REPORT :VERIFY-EXISTANCE
   :COMPLEX-ARG1 :INOUT :CONS-ENTRIES :O :DE.SETF.UTILITY.CONDITIONS
   :STANDARD-ARGUMENT-LOCATION :Q :ENTRIES-INFO :U :HELP :B :COSTS :INITARG :G
   :MINIMAL :IGNORE-TYPES :BOTH :VERBOSE :ENCAPSULATE :SAVE :ENUM :DOTTED :R :A
   :HIS :PROCEDURES :CLASS :TAB :Z :BREAKPOINT :ENTRY-POINTS :VALUATION
   :LOGNAME :IMMEDIATE-CONSTANT-SC :LABELLERS :HASH1 :UNTRUENAME :HASH5
   :SUPPORT-ROUTINES :INDEX-VECTOR :HASH-VECTOR :USER :SAP-MAKER :EARLY-METHOD
   :ERROR-ON-MISMATCH :GENERATOR-COST :READ :ACLPC :NOP :FOLLOW-LINKS
   :ROOT-STRUCTURES :RUNTIME :GENERAL-ENTITY-DEFINITION :RETURN :DIR-STRUCT
   :COUNTS :TABLE :COLNUM :ALTERNATE-SCS :%NAME :SLOT-NAME :GEN :METHOD-CLASS
   :OPTIMIZE :THEN :PREFIX-NAMESPACE :DEFAULT-MINUTES :SIGINT :VARS :ESCAPE
   :PROGRESS :ID-ATTR-NODE-P :P :%STATUS :PREFILTER :ACCESSOR :PRIMITIVE
   :ENVIRONMENT-NAME :LAMBDAS :SETF.CONDITIONS :DE.SETF.UTILITY.TEST :CATCH
   :HASH-FUNCTION :NUM-ARGS :OPTIMIZER :ALL :OVERWRITE :SUPER
   :DE.SETF.UTILITY.IMPLEMENTATION :REAL :RESUMER :FRESH-LINE-P
   :DIRECT-ANNOTATION-MODEL :UNPARSED :TEST-CONSTRAINT :SPACE :INTERESTING
   :PRINT-HERALD :LAST-LOCATION-RETRIEVED :EFFECTS :ITERATION-KEYWORDS :PRIN1
   :NON-PACKED :TYPES :PRINC :PRINT-MERIDIAN :DOWNFROM :PRINT :TOP-N :DEFINER
   :DEBUG-VARIABLES :MV-CALL :COMPILER :FILL-POINTER :IF-INPUT-DOES-NOT-EXIST
   :ALLOW :PV-TABLE :INFO-ARGS :UNINTERNED :LOAD-OBJECT :MORE-ARGS :ATHLON
   :AFFECTED :NODE :SIGPROF :PLACE :COMPILER-MACRO :INTERACTIVE-P :WRITES
   :UNLESS :VALUE2 :DEBUG-INFO :BY :UTF8 :PLIST :DISPLACED-INDEX-OFFSET
   :XML-WARN :EQ-TEST :SCHEDULED-REAL-TIME :NEXT* :SHELL :SIGIO :ITS :OUT
   :ORIGINAL-SOURCE :COMPILE-FROM :PRINT-FUNCTION :ALLEGRO :X86 :LE :CIRCLE
   :LOCATIONS :CASE :OPERANDS :SIGVTALRM :DEFAULT-DEFAULT :EVAL-STACK-TOP
   :XPATH :MATCH :SETS :PARAMETERS :HOUR :SLOT-NAMES :TRANSLATIONS :USE-BY
   :CONSTANT-SCS :NO-CHANCE :STACK-GROUP :PARSED-VOPS :ISO88591 :SYMBOL-TYPES
   :REPORT-RECURSION :%USE-LIST :SINGLE-CHAR-WILD :|VC: ID|
   :REANALYZE-FUNCTIONS :MORE-ARGS-TYPE :ALTERNATIVE :ARG-TYPES :DEBUG-VARS :DO
   :IGNORE-IT :LOAD-TOPLEVEL :CALL-SITE :PV-SIZE :%FUNCTION :ADDR-TYPE
   :COMMON-LISP-USER :VERBOSITY :GENERATOR :ALLOC-TRANS :ATSIGNP :PAGES
   :READABLY :PRINT-BANNER :FRAME :RFC1123 :EXPORT :ABSOLUTE :FORM :BACKLOG
   :EXITS :TABLE-VAR :NEAREST :FILE-NAME :TRANSLATE :OUTPUT-STATE :XML-ERROR
   :CONSTRUCTOR :SIZE :SAVE-P :DE.SETF.XML.NAMES.IMPLEMENTATION :EXECUTE-TESTS
   :SIGN-EXTEND :THE :MOVE-ARGUMENT :STRICT :VALUE3 :LABELLED
   :INPUT-EOF-FUNCTION :VERBOSE-P :DEPENDENCIES :RESET-TIME :SYSTEM-DESCRIPTION
   :INTERRUPTS :POSN :CMU :INIT-FORM :SPECIAL-BIND :PATCH-TABLE :DEBUG-VARIABLE
   :DEBUG-FUNCTION :UNPARSE-HOST :IN-INDEX :FORCE :INPUT-VARIABLES :VERSION>=
   :TEST-NOT :CLOSUREP :DOCUMENT :LISTEN :TOP-LEVEL-FORM-INDEX :%RUN-TIME
   :IBUF-TAIL :CAPITALIZE-FIRST :INITIAL-FUNCTION :FOR-KEYWORDS :DOWNTO :CHECK
   :UTF1612 :STACK-SLOT :CONFIRM-COMPILE :KEYWORDS :UNKNOWN-KEYWORD
   :INVALID-OBJECT :MCL :INITIALIZE-CONDITION :INTERN-ONLY :NOTES :TYPE-NAME
   :ATTRIBUTES :EXCLUDE :NAMESET-TOKENIZER :VALUE1 :MISER-WIDTH :CPL :MOK
   :CONDITION-VECTOR :TERMS :CIRCULARITY-TABLE :STRICT-RESULT :COMMON-LISP
   :*CLASS.TEST-UNIT* :BLOCK-COMPILE :SUCC :SC-NAMES :STEP :START-COLUMN
   :FIND-PACKAGES :SUFFIX :BLOCK-END :EVER-USED :LAMBDA-LIST :ELSE :BACKEND
   :GOVERNMENT :RETURNS :EXPORT-ONLY :NO-CLM :IEEE-FLOATING-POINT
   :PER-LINE-PREFIX :NUM-RESULTS :EXTENDED :SPECIAL-FORM :WHERE-FROM
   :ALLEGRO-VERSION>= :GID :NO-COMPILER :PID :UID :WINDOW-TITLE :RECURSE
   :TEMP-VARIABLE :SPILLED-VOPS :CONTENTS :SIGNALED :ALIEN-REP :SVSET
   :DE.SETF.XML.CONDITIONS :ARG-TEMPS :FLAG :LOCK :UNBINDABLE-PREFIX-P
   :BYTE-COMPILED-ENTRY :IGNORE :SIMPLE-CONTINUABLE-CONDITION :TOTAL-CONSUMES
   :VOID :EXTENSIONS :HIGH :INEXACT :FIN-FUNCTION :FUNCTIONAL :FUNCTION-END
   :KIND :FULL :PARTIALLY :NULL :SAVE-SP :COLONP :PREFILTERS :FROM-DEFCLASS-P
   :CODE-COMPONENT :PARSE-STATE-ACTIVE-P :DEFAULT :CURRENT :DELETE-ORIGINAL
   :|NSC: Prefix Immutable| :CLOSURE :SIGWINCH :RESTRICTED-TNS :REHASH-SIZE
   :DERIVED-TYPE :VIRTUAL-LOCATION :SORT :KNOWN-VOLATILE :CONSTANT-VALUE
   :NAMESPACE-DECLARATION :SIGTERM :DEFAULT-MONTH :ENCAPSULATED :INITIAL-VALUE
   :COUNT-SPACES :IBMRT :CONTEXT-DECLARATIONS :LOAD-TIME-VALUE :NATURALIZE-GEN
   :WHILE :OUTPUT-TERMS :RETURN-LIST :IF-OUTPUT-EXISTS :ASSEMBLY-ROUTINE
   :RESULT-TEST :AMOUNT :EQUAL-TABLE :SUPPRESS :UTF-16 :ACCESSORS :WAIT-TIMEOUT
   :QUERY :BREAK :WARNING-FUNCTION :ENDS :SC-NUMBERS :MOST-SPECIFIC-LAST
   :*VERSION* :CONDITION-ACTION :SIGTTIN :FAST-FUNCTION :LIVE :COMPLEX-UNION
   :ARG-DOCUMENTATION :DOWN :HZ :NEXT :NZ :LIVE-TNS :CONFLICTS :CCL
   :QUERY-COMPILE :LIBRARIES :BINDING-STACK :PROCEDURES-TABLE :PATH :ENUMERABLE
   :VALUE4 :EQUAL-FUNCTION-NAME :IN-BUFFER :PRINT-WEEKDAY :QUALIFIERS :FUN
   :ERROR :EACH :COMPLEXP :SIGUSR2 :UNDEFINED :TYPE-SYMBOLS :ERGEBNIS :NAME
   :OBUF-TAIL :WILD :ARG-TN :QUERY-LOAD :BREVITY :MAX-ARGS :DATA
   :FUNCTION-END-COOKIE :PARSE-STATE-SOURCE :ANSI :NO-ERROR :WORD :LAST
   :ARGS-LAMBDA-LIST :SLOT-DEFINITION :INSTANCE-SLOTS-LAYOUT :SITE-INIT
   :PREDICATE-TYPES :PRINT-PARSE-STATE :%SHADOWING-SYMBOLS
   :CONDITION-CONTINUE-FORMAT-CONTROL :REPORT-CONDITION :REFERENCES :FORCE-P
   :GERDS-PCL :WARNINGS :BOGUS-LRA :VALUE5 :ALWAYS :GENERATE-CALL-SEQUENCE
   :ALIST :INTERN :SIZE-FUNCTION :PARAMETER-ENTITY-DEFINITION :NEXT-METHOD-CALL
   :SCALE :SIGCHLD :UNADJUSTED :MAKE-LOAD-FORM-FUN :PCL-STRUCTURES :ELEMENT-P
   :FLAVOR :NEW-VERSION :RESULT-TN :FILE-LENGTH
   :DE.SETF.XML.PROCESS.IMPLEMENTATION :DE.SETF.XML.CODEC.IMPLEMENTATION
   :NATIVE :HASH-TABLE :SHORT :DIRECT-SUPERCLASSES :FORMAT-ARGUMENTS :EXIT-CODE
   :FROM :SIGHUP :FASL-PATHNAME :CACHE :ENTRY-FOUND :I486 :PRIMITIVE-TYPE-OF
   :ALIAS-TNS :INTERACTIVE :CONTINUE :PREPOSITION-GROUPS :NOTE :NLE :EOF
   :MORE-RESULT-COSTS :RECOMPILE :LOAD-TN :DUPLICATE
   :LISPWORKS-PERSONAL-EDITION :MULTIPLE-READER-LOCKS :NOT
   :MAKE-OLD-FP-PASSING-LOCATION :INITIATE :IMPORTANT :SELF-P
   :DIRECT-DEFAULT-INITARGS :BINDS :SINGLE :SIGXCPU :LEVEL :FIELD
   :ALLOW-OTHER-KEYS :END-BREAKPOINT :UTF16LE :SPECIALP :UNFILTERED :PRIORITY
   :NEW-COMPILER :SPECIFIED :NUM-MORE-ARGS :XML-WARNING :PRETTY :SPECIFIER
   :SYSTEM-CLASS :TARGET-FUNCTION :UTF16 :FULL-CALL :OLD-PCL :RPLACD :ATN-WFST
   :EXPORT-FROM :MAIN-ENTRY :RULES :AND :END :INITFORM-P :PRESERVE :PYTHON
   :EXTRACT-GEN :METHOD-COMBINATION :IS-STATIC :BYTE-COMPILE :LIST-FIRST
   :REGISTER-WORDS :SOURCE-FORM-CACHE :INPUT :DEFAULT-HOURS :SIGUSR1 :COERCE
   :RESERVE-LOCATIONS :PWD :LEXICAL-VARIABLES :TAGS :PTY :ARGUMENTS
   :SPECIAL-ARG-TYPES :NO-HEMLOCK :FLUSH :CONDITIONAL-P :DE.SETF.XML
   :CONDITIONAL :PRINT-SECONDS :ALTERNATE-METACLASS :DEBUG-LIVE-TNS
   :INSTRUCTION-FORMATS :WIRE :ZERO :EXTERN :FAST-MODE :WHICH :REANALYZE
   :ORIGINAL-SOURCE-PATH :PROCESS-GROUP :BEFORE-ADDRESS :FILE :DEBUG-SOURCE
   :PACKAGE :ACCRUED-EXCEPTIONS :RENAME-AND-DELETE :ARG :NUMBER :KILLED
   :EXPRESSIONS :PRODUCER :CONDITION-NAME :SYSTEM-FILES :ELSEWHERE-PC
   :VARIABLES :YEAR :IMPORT-FROM :BLOCK-BOUNDARY :FLAG-VARIABLE :NREQ
   :RANDOM-MT19937 :CONDITION :C-TYPE :COND :IBUF-HEAD :LISPWORKS4
   :PRINTER-LIST :MACTCP-COMPATIBILITY :MULTIPLE :BORN :WORD-PREDICATE :SPECIAL
   :ALLOCATION-CLASS :SEALED :TEST :TEMPORARY :BODY :EXPRESSION :SIGABRT :RHS
   :NAMESPACE :WALK-FORM :CREATED :OBSOLETE :CONTINUE-FORMAT-CONTROL :MSG
   :NO-PCL :GENERIC-FUNCTION-CLASS :DISPLAY :COMPILE-ALWAYS :NEEDING-REHASH
   :SVAR :FORMAT-LENGTH :SEGMENT-SAP :NUMERIC :DELETED-BLOCK-START :OVERRIDE
   :CAR-TYPE :METHOD-SPEC :COMPLAINT :FAILED-OPTIMIZATIONS :VALUES
   :SIMPLE-UNION :PRINTNAME :FOR :|WFC: Legal Character| :CONSUMES :APPEND
   :INITIALLY :KEYWORDS-P :IDENTITY :INTERNAL-XML-ERROR :OPTIMIZE-INTERFACE
   :START :PTY-PROCESS-GROUP :CUR-LABELS :NEGATION :EXTERNAL-SYMBOLS :KEYP
   :OBUF-LENGTH :ENCLOSING-SOURCE :OLD-FP :PPC :MAXIMUM :REQUIRED :ACTIONS
   :ANONYMOUS :SPARC :META-SB-NAMES :EDGES :NON-LOCAL-ENTRY :TEXT/PLAIN
   :CONDITION-ALL :OUTPUT-LATER :IMPORT-ONLY :GECOS :ALPHA :DOCUMENT-ELEMENT
   :BOUNDP :DYNAMIC-STATE :RELATIVE-PACKAGE-NAMES :ASSIGNMENT
   :METHOD-NAME-DECLARATION :HASH2 :MEMBER :MODULUS :HASH6 :PREV :PREREQUISITES
   :FILTERED :PRINT-LEVEL :REGISTER-SAVE-PENALTY :RESULT-TYPES :RESULT
   :ENTRY-NOT-FOUND :WALK-CALL :STRING+ :COMPONENTS :COLINC :COMPILE
   :INCLUDE-ARGS :ASSOC :SIGNED :ALIEN-INTERNALS :AUXS :CHOOSE
   :REHASH-THRESHOLD :CHARACTER :SAVE-ONCE :POST-MORE :BINDING-STACK-SIZE
   :BASE-FILE :TEMPLATE-NAMES :USE :INTERRUPT-CONTEXTS :TEST-FUN :TEST-FUNCTION
   :CHARACTER-SET :INITIAL-BINDINGS :HEAD :POSITIVE-INFINITY :BNFP-JAVA
   :ODD-LENGTH :SAFE :REMOTEHOST :UNPARSE-DIRECTORY :|VC: Notation Attributes|
   :BUFFER :CONTINUABLE-ERROR :META-SC-NAMES :HEADER :GENERATE-RETURN-SEQUENCE
   :LINE :MIN-ARGS :MODIFY-PACKAGE :OLD-DEFINITION :%REAL-TIME :AFTER :MISER
   :ELEMENT-TYPE :PREFIX-LENGTH :UTF-16-12 :ASSEMBLER-RESOURCES :GENGC
   :PORTABLE-COMMONLOOPS :SIGFPE :CACHED-CONSTANT :UNKNOWN-RETURN-PARTNER
   :RETURN-PC :MORE-ARGUMENT :PRINT-OBJECT :INVALIDATE :DEFTESTS
   :CYCLE-FUNCTION :CHAR-POS :INST-SPACE :GENERATOR-LAMBDA :UNSPECIFIC
   :CONDITION-AFTER :DAY :VALID :FUNCTIONS :FOREIGN-DATA :SAME-AS
   :MAKE-NLX-SP-TN :INCLUSIVE :WILD-ARGS :ROW :UTF1621 :ALIGNMENT
   :DENORMALIZED-OPERAND :REFS :NON-LOCAL-GO :PRINTERS :SIGQUIT :USING :TIME
   :BUFFERING :VERSION :STATIC :REVERSE :ERROR-CHECK
   :MAKE-INITIALIZED-CONDITION :SEQUENCE-TYPE :USASCII :LIST :BREAK-AFTER
   :FUNCTION :LANGUAGE :COMPONENT :MOVE-ARGS :SHADOWING-IMPORT-TO :START2
   :DWORD :PARSETABLE :STACK-SIZE :SIGKILL :SUPERSEDE :RAW :WHEREIN :OVERFLOW
   :UNTIL :CONSTANTS :LOCAL-LEXICAL-EXIT :FILES :PACKAGE-VERSION :HAIRY
   :NEW-FUNCTIONS :STRUCT :STACK-CHECKING :MULTIPLE-READER-SINGLE-WRITER
   :SIGTSTP :MOST-SPECIFIC-FIRST :SECTION :DEFEXCEPTION :FROM-END :OPTIONAL
   :TYPE-RESTRICTIONS :POST-REST :LINE-RELATIVE :UNBOUND :SB-NAMES
   :COMPILE-LOAD :CACHE-NAME :INHERITS :COMPILE-TOPLEVEL :CODE-OBJECT
   :EXPECTED-TYPE :MORE :CONTEXT :TOKENIZER :EXTERNAL :START-PC :PURGE-PACKAGE
   :USE-LABEL :PATH-KEYWORDS :DELAY :SEGMENT :LEXICAL-VAR :NLX-ENTRY
   :CATEGORIES :DEFAULT-SECONDS :DEPORT-GEN :DEFAULT-INITARGS :HASH-FUN
   :SIGXFSZ :ONE-FUNCTION :TERM :MAKE-TEST-UNIT :PREDICATE-NAME
   :SHADOWING-IMPORT-FROM :READS :LOCATION-PRINT-NAME :EVAL :LOCAL :M68K
   :BATCH-MODE :CONSED :WHEN :PREDICATE-FORM :IGNORE-THIS-ARG :STATUS-HOOK
   :ENTRY :LIKE :WAIT :START-POSITIONS :EVAL-STACK :FLAGS :NEW-DEFINITION
   :GUARD :NEWEST :MANDATORY :FUNCTION-NAME :CLEAR-INPUT :MAYBE-INLINE :SIGALRM
   :NEXT-FREE-KV :TRAPS :COMPUTING-CACHE-P :PROFILE :NE :RESET-FUNCTION
   :COMPLEX :CHECK-FOR-SUBDIRS :SMALLER :MAKE-RETURN-PC-SAVE-LOCATION :RPLACA
   :|VC: Name Token| :ATN-SOURCE :TYPE-PREDICATES :UNREAD :LINE-LENGTH
   :XML-CONDITION :REST-ARG-P :PRED :DE.SETF.UTILITY.STRING :PPRINT-DISPATCH
   :HASH-CODE :XQDM :SXHASH-TOKENIZATION :IF-ERROR-EXISTS :PLUS-INTEGER
   :WITH-NAMESPACES :PRINT-ALL :BITS :NOPE :MEMBERS :BYTE-ORDER
   :*DEFAULT-PREFIX-STRING* :VIRTUAL :KNOWN-RETURN :MAKE-PARSE-STATE
   :CONSTRAINT :CONSTANT-TNS :INTERNAL-WRITER-FUNCTION
   :MAKE-RETURN-PC-PASSING-LOCATION :FETCH-FUNCTION :LOADABLE-PCL :SIMPLE-=
   :PACKAGE-NOT-FOUND :START1 :REGISTER :*PACKAGE-OPERATIONS* :SCHEDULER-P
   :SYSTEM-LOAD-TIME :ANSI-CL :FORM-NUMBER-MAPPING-TABLE :INLINE-EXPANSIONS
   :VALUE :NCONC :WHERE :INPUT-VECTOR :NODE-VAR :FLOAT :PCL-CLASS :WARNING
   :PRINT-AFTER :WFST :REALLY-ASSERT :VARIANT :ANNOTATION-MODEL :NGE :WRITER
   :FUN-HOOKS :INVALID-VALUE-FOR-UNESCAPED-REGISTER-STORAGE :NONE
   :FUNCTION-START :DECLARE :SIGNAL :LETS :FAILED :CMU18E :MOVE-VOPS :TK1
   :MINIMUM :TRANSFORMS :CALL-WALK :STRUCT-SET :CORMANLISP :BOUT :UPTO
   :CHARACTER-ATTRIBUTE-TABLE :SOUT :DEFAULT-YEAR :SPECIALIZERS
   :ENVIRONMENT-START :INTERNAL-ERROR :LOAD-INIT-FILE :FORMAT-CONTROL
   :PROPERTIES :METHODS :POSITIONS :META-SC-NUMBERS :DELAYED :NA
   :INPUT-BUFFER-P :DELETED :SIMPLE-INTERSECTION :XPARSER :DEFAULT-NAMESPACE
   :CURRENT-CATCH-BLOCK :INITIAL-ARGS :TARGET :IGNORES :UTF-8 :DIES
   :INSTRUCTION-FLAVORS :ITEM :BIG-ENDIAN :PROCEDURE :EDIT :SINGLE-VALUE-RETURN
   :XML-UTILS :TYPE-DEFINITION :LARGER :PRINT-SPACES :WRITE-DATE :UNTRACED
   :ZONE :DESTRUCT-LAYOUT :UNWIND-PROTECT :NO-CLX :TRACE :PRODUCES
   :INTERPRETER-FUNCTION :CONSEQUENT :STANDARD :SAFETY :TYPE= :BYTE-ANNOTATE
   :IBUF-LENGTH :REPEAT :FORMAT :DE.SETF.XML.INTERFACE :TYPEP :DTYPE :NB :SB
   :INTERN-TEST :FASL-FILE-VERSION :END1 :INACTIVE :INITIALIZING :CONT :SB-LIST
   :INTERPRETED-CLOSURE :EXPORTN :LOAD-TIME-CODE-FIXUP :PARSE :TLF-NUMBER
   :ENABLE :CONDITION-CONTINUE-FORMAT-ARGUMENTS :HOME :OPTIONS
   :OPCODE-COLUMN-WIDTH :STRUCTURE :CONSED-L :READER :MULTI-CHAR-WILD
   :ABBREVIATED :COST :PPRO :HOST :INITIAL-OFFSET :FORCE-TO-STACK
   :CONDITION-NAMESPACE :CLOSURE-P :EXECUTE :PRINTED :OUTPUT-VARIABLES
   :FELL-THROUGH :PRINT-TIMEZONE :MORE-RESULT :SECTION-END :MORE-ARG-COSTS
   :ARGUMENT :PRINT-SUMMARY :NC :DIVIDE-BY-ZERO :COMPLEX-SUBTYPEP-ARG2
   :DEFAULTS :READ-ONLY :FORMS :READ-TIME :ANSWER-VARIABLE :HASH-BITS :IGNOREP
   :PRODUCTION :IR2-CONVERT :NET :NAMESPACE-PRINTNAME :STYLE
   :AUTO-COMPILE-DEFAULT :INITFUNCTION :INTERNAL-SYMBOLS :SPECIFITY :AROUND
   :*TEST-OUTPUT* :CODE-LOCATION :PROCESS-COMMAND-LINE :MINUTE
   :COERCE-TO-GENERIC-FUNCTION :SLOT :BEGINNING :CDR-TYPE :PURE :LISP :BYTES
   :PORT :MORE-RESULTS-TYPE :FINISH-OUTPUT :HUSHLOGIN :US-ASCII :CGC
   :DRAFT-ANSI-CL-2 :UNINTERN-TEST :PATHNAME :FASL-FILE-TYPE :CHOICES :FD
   :MACROS :INSTRUCTIONS :VARIABLE :CAT :INITFORM :DEFUN-ONLY :INST-HOOK
   :CONTINUE-FORMAT-ARGUMENTS :24-BIT :FINITE :GRAY-STREAMS
   :*TERMINAL-PARSER-ERROR-ACTION* :LTN-ANNOTATE :CSPEED :COMPLEX-INTERSECTION
   :ARREST-REASONS :DEPOSIT-GEN :DE.SETF.XML.BASE.IMPLEMENTATION :SET-KNOWN
   :INVALID :KEY :MAKE-UNKNOWN-VALUES-LOCATIONS :CONDITION-PARSE-STATE :UNIX
   :BOOTABLE-PCL :LOCATION-COLUMN-WIDTH :REMAINING :GLOBAL :SIMPLE-SUBTYPEP
   :%LAMBDA-LIST :64-BIT :AUTO-CLOSE :ENTRY-POINT :FAST :ERROR-FUN :DATE
   :NO-LAMBDA-LIST :SOURCE-ANALYSIS :PREREQUISITE :RECOMPILE-SOME
   :INITIAL-CONTENTS :LABELS :MAC :BREAK-ALL :LAYOUT :ARG-COSTS
   :COMPILE-LOAD-ALWAYS :BE :GE :%ARREST-REASONS :COUNT :PE :COMPILED
   :MOVE-ARG-VOPS :XQUERY :FILE-POSITION :LOAD :PARSE-STATE :DERIVE-TYPE
   :CURRENT-CONFLICT :ALIASES :CURRENT-UNWIND-PROTECT-BLOCK :OFFSET-VAR :ARITY
   :ATN-SYSTEM :NP :TYPE-PREDICATE :CUR-OFFS :HIERARCHICAL :CLEAR-OUTPUT
   :NEGATIVE-INFINITY :NAMESPACE-EQUAL :CALL-LEXENV :PREDICATE-TYPE :POSITIVE
   :ASSEMBLER-PARAMS :RESULT-LOAD-SCS :RUNNING :INITIAL-ELEMENT :CMUCLLIB
   :CUTOFF :SIGBUS :JUST-DUMP-IT-NORMALLY :SPLIT-SEQUENCE :INSERTION-P
   :FORCE-TO-MEMORY-P :RECURSIVE :SOURCES :IF :OF :PEEK-CHAR :%WHOSTATE :COMMON
   :RENAME :CACHE-TYPES :VALID-MASK :XML-SYMBOLS :CONSTRUCTOR-SPECIALIZER
   :LITTLE-ENDIAN :CONFIRM :VECTOR :MAKE-NLX-ENTRY-ARGUMENT-START-LOCATION
   :DOC-STRING :OBJECT :MAKE-NFP-TN :LABEL :SOURCE-ROOT :BASE :TOKENS :LINK
   :CMU18D :SUBCLASSES :DIRECT-SLOTS :%USED-BY-LIST :CODE-LOCATION-NUMBER
   :SPLIT-STRING :SIGURG :TOKENIZER-NAME :ERROR-FUNCTION :SYSTEM-CONSTANT
   :SPILLED-TNS :PREFIX :TN :EMITTER :INVERT :FINAL :TAGBODY :UNBOUNDED
   :START-NAME :IF-SOURCE-NEWER :TOO-HAIRY :EXECUTE-TEST :PUNCTUATION-P :NG
   :MAX-LOCATIONS :REF-ORDERING :SIZE-TEST :CLASS-SLOTS
   :MODIFY-PACKAGE-OPERATION :TRACE-FILE :ANY-PRIMITIVE-TYPE :TRACE-NETS :VAR
   :DATUM :UNPARSE :INLINEP :CONSTANT :MOVE :POLICY :TIMEZONE :USER-DATA
   :INHERITED :HOOKS :FINALLY :XCONFORMANCE :HPPA :RUN-SCHEDULER :INDIRECT
   :WRITE :COPY :BLOW-IT-OFF :ADJUSTED :BINARY :EXPORT-THROUGH :MODPACKAGE
   :ELEMENT-DEFINITION :PASSED :LOCAL-PART :|VC: No Duplicate Types| :DIGITOOL
   :READERS :PCL-FUNCALLABLE-INSTANCE-SLOTS :LOAD-PACKAGE :INIT-FUNCTION
   :PASSWORD :BNFP :DEBUG :TOP-LEVEL :INPUT-TERMS :OPENMCL :%NICKNAMES
   :KEY-SIZE :RECURSION :TRUENAMEP :DIRECTORY :GCS :BIND :SCS :UNARY-COERCE
   :SIGILL :ARGS :EQ-TABLE :NOTINLINE :FILTERING :SYSTEM-KEYWORD :TEMPVARS
   :CODES :DIRECTION :COLUMN :HASH3 :CURRENT-VALID-LOCATIONS :DEFAULT-DAY
   :HASH7 :MACRO :HASH0 :HASH4 :PO :ADJUSTABLE :SPECIFIED-SAVE
   :GENERIC-FUNCTION :UPFROM :AE :ELSEWHERE-P :EXITED :INCLUSIVE-PERMITTED
   :DEFAULT-PRINTER :AMBIGUOUS :ABORTED :UNUSED :SAVE-TN :EMIT-NOP
   :IDENTITY-WITH-ONE-ARGUMENT :COMMON-ID :BACK :SIGCONT :NEEDS-NEXT-METHODS-P
   :SAP :DOCS :LINKAGE-TABLE :LOCAL-CONFLICTS :GLIBC2 :EMIT-FUNCTION
   :NEXT-VECTOR :TEMP-TEMP :%RUN-REASONS :SMALL :CURRENT-EXCEPTIONS :XRELEASE
   :CHECK-CONSTRAINT :PRINTFUNCTION :DESCRIPTION :DYNCOUNT-INFO :WRITERS :HASH
   :CONTENT-NAMES :LOCAL-CALL :TYPE :GENERA :ARG-CHECK :PROBE :WEAK-P :CALLTIME
   :ABOVE :|VC: Element Content| :DOUBLE :UNSPECIFIED :ABORT :BYTE
   :UNKNOWN-RETURN :DISPLACED-TO :VARIABLE-LENGTH :DATA-GRAM :MORE-ENTRY :CLEAR
   :FOREIGN :ALIEN-STACK :TYPE-NUMBER :ERROR-STREAM :FIELDS
   :DE.SETF.XML.MODEL.IMPLEMENTATION :LENGTH :LISP-REP :NICKNAMES :LOAD-SOURCE
   :NEW-METHOD :SECTION-START-LINE :MAKE-NUMBER-STACK-POINTER-TN :CANON-TRANSLS
   :VOP-VAR :COMMENT :ALWAYS-LIVE :LOAD-COSTS :SEALS :USE-LABELS :+DELETED+
   :ARGUMENT-PRECEDENCE-ORDER :DISPATCH-TABLES :CALLS :FIXED :WIRED-TNS
   :SUBSPACE :|VC: No Duplicate Tokens| :INLINE-EXPANSION :DEFINE-SYSTEM :MP
   :SIGN-EXTEND-P :DECLARED :SLOT-NAME-LISTS :ACTION :INSTANCE :NAMED
   :TEMPLATES :NAMES :VARIANT-COST :DE.SETF.XML.MODEL :FUNNY
   :GENERATOR-FUNCTION :END2 :WHAT :DEFINED :CODE :INTERNAL/CALLS :LOCAL-NUMBER
   :MODE :PMAX :SOURCE :CUR-OFFS-HOOKS :SECTION-COLUMN :INLINE :PURGE :BUGS
   :ISO-8859-1 :EVAL-NAME :INIT :TRACE-STREAM :SPEED :ENSURE-PACKAGE :RAW-TYPE
   :VALID-STRUCTURES :STREAM :CALLERS-P :NEGATIVE :CONSED-H :N-BIN
   :SCHEDULED-RUN-TIME :CACHE-INDEX :INSTRUCTION-ALIGNMENT :SOURCE-INFO
   :CALL-LIST :MIME-TYPE :OPERATION :PREDICATE-FUNCTION :EDIT-PACKAGE
   :LOCAL-CONSTANT :LOAD-TIME-VALUE-FIXUP :ENTRY-TABLE :REF-KNOWN :MAYBE :CL
   :CONTROL :ACTIVE :NL :IBUF-SAP :FILTERED-VALUES :LOCAL-PART-EQUAL
   :ALLOCATION :CALLERS :|VC: Enumeration| :INITIAL :ID :SIGTTOU
   :MAKE-ARGUMENT-COUNT-LOCATION :LITERAL :INFO :COLLECT :MAIL :EXPANSIONS
   :TAIL :QNAME-EXTENT :BEFORE :CL-HTTP :READTABLE-CASE :DYNAMIC :INITIAL-P
   :PV-TABLE-SYMBOL :NON-LOCAL-EXIT :LEXENV :EQ :PATHNAME-TYPE :RESULT-TYPE
   :CONTROL-CYCLE-FUNCTION-NAME :CONC-NAME :UNION :MONTH :OBUF-SAP :NAMESTRING
   :SEQUENCE :BLOCK-START :PROPERTY-LIST :PURIFY :MCASE :SYNONYMS
   :SECTION-RELATIVE :LET :DEBUG-ENVIRONMENT :LEAF :AUTO-COMPILE :SYSTEM
   :REST-P :BEEP :GLOBAL-TN-COUNTER :LHS :CLASSES :CONCATENATE-STRING
   :INITIALIZE :CORE-DUMPED :ARRAY :CELL :NLX-INFO :ASSUMED :PERCENT :SIGIOT
   :BREAKPOINT-NUMBER :|VC: Entity Name| :CODESIZE :CONTINUATION
   :SPECIALIZED-ELEMENT-TYPE :LAST-FORM-RETRIEVED :DISASSEM-PARAMS :ORIGINAL
   :SUPPLIED-P :PARSER-NAME :DEVICE :VALUES-RECEIVERS :PREDICATE
   :SOURCE-PATHNAME :UPPER :UNLABELLED :TABLE-FREE :MESS-UP :GENSYM :IN
   :KEYWORD :MORE-ARGS-ENTRY-POINT :ARG-INFO :%FEATURES :INSIDE-BLOCK :BLOCKS
   :NFP :CLEAN-PACKAGE :ALIEN-STACK-POINTER :ALIEN-STACK-SIZE :ARGP
   :PRIMITIVE-TYPE-ALIASES :EMPTY :NEXT-OFFS :PENTIUM :LAST-BLOCK-COUNT :BELOW
   :CONTROL-STRING :META-PRIMITIVE-TYPE-NAMES :PINNED :UNDERFLOW :CREATE
   :ERROR-OUTPUT :PRINT-LENGTH :FAIL :SLOTS :CUSTOMARY-CASE :START-TIME :ALIEN
   :TAIL-P :SOCKET :PAGE-SIZE :ALIAS :GENSYMS :REOPTIMIZE :UPCASE :TIMEOUT
   :INTERNAL-ERRORS :DE.SETF.XML.NODE.IMPLEMENTATION :TAIL-SET :PATHNAME-NAME
   :IO :NO :NORMAL-TNS :TO :PCL :RADIX :DEPTH :RIGHT-MARGIN :ALLOW-OTHERS
   :EXTERNAL-FORMAT :XTESTS :DIR :OUTPUT-FILE :SIGN-EXTENDED :WILD-INFERIORS
   :SOFT :CONVERTED-ONCE :LISP-STREAM :LISPWORKS :CL-USER :SC :AFPA :TEST-FN
   :OPERATIONS :MISC :PARSE-STATE-CONDITION :HASH-NEW :PROBLEM :STUB :ADDR-LIST
   :TARGETS :IMPLICIT-FOR-REQUIRED :MASK :FUNCALLABLE-INSTANCE
   :PRECISION-CONTROL :ENTRY-FUNCTION :BUFFER-INDEX :MOVE-COSTS :UNARY-TYPEP
   :UP :HAIRY-SLOTS :GET-COMMAND :IF-DOES-NOT-EXIST :ENTRIES
   :FUNCALLABLE-INSTANCE-NAME :PRIMITIVE-TYPE-NAMES :XUTIL :VANILLA
   :ENVIRONMENT :REDUCE :ENV :53-BIT :HOW :LOW :REST :MORE-RESULTS :HER
   :PRINT-NAME :HISTORY :RESULT-COSTS :FLAG-ID :CLASS-INFO :MV-LET :WITH
   :DATAGRAM :TABLES :SET :GLOBAL-FUNCTION :UNPARSE-ENOUGH :ARGUMENT-TEST
   :WALK-FUNCTION :BLOCK :VARIANT-VARS :SAP-FORM :OPTIONALS :SOURCE-PATH
   :POSITION :FAST-SAFE :OUTPUT :CLOSE :RELATIVE :DOWNCASE
   :CHARACTER-MACRO-TABLE :CAPITALIZE :SIGSTOP :METACLASS :ELEMENTS :CHECKER
   :CMU17 :SPECIFIED-SAVE-TNS :CMU18 :LOWTAG :NLX-ENTRIES :MAKE-CALL-OUT-TNS
   :MAKE-DYNAMIC-STATE-TNS :FILL :KILL :CLEANUP :DOCUMENTATION :NLX-ENTRY-P
   :ELEMENT-SIZE :PV-CELL :CONSERVATIVE-FLOAT-TYPE :USE-ONLY :STRING
   :LABEL-HASH :DOC-STRING-ALLOWED :MORE-CONTEXT :SUFFIX-LENGTH :FAILURE
   :REHASH-TRIGGER :FINISHED :LOAD-IF :FIND-TEST :METHOD :DOTW :TOP-LEVEL-XEP
   :FDEFINITION :SECTIONP :INFO-ARG-COUNT :SELECT-COMPONENT-FORMAT :LOOP
   :DEFINITION :OR :SUCCESSORS :UNKNOWN :SHADOW :ELSEWHERE-START :WORDS :MODULE
   :DISP :WAIT-RETURN-VALUE :ADDRESS-SIZE :UNPARSE-FILE :SPECVAR :ANNONYMOUSP
   :COMPILED-CLOSURE :TYPE-KEYWORDS :NODES :HANDLER :LINEAR :CONTROL-STACK-ID
   :SUBTYPEP :PRINTER :MAKE-STACK-POINTER-TN :DEFAULT-WEEKDAY :TEST-UNIT
   :APPLYP :DEFAULT-ZONE :WAIT-FUNCTION :LAMBDA :NEW-ASSEM :REUSE-ADDRESS
   :COMPLEX-= :FUNCTION-MAP :OFFSET :TOP-LEVEL-FORM :UNEXPORT :GLOBAL-CONFLICTS
   :COPIER :EXTENSION :TEMPS :PRESERVE-WHITESPACE :GROUPS :START-USES :VERSION<
   :REPORT-FUNCTION :STACK-FRAME-SIZE :PREDICATES :DIMENSIONS :ALLOWP :CHARPOS
   :NS :OPTIONAL-DISPATCH :BIN :NEXT-METHOD-P-P :ARGUMENT-COLUMN :NO-CHECK
   :CONSTANT-PREFIX-P :SBCL :INTERFACE-COOKIE :REPORT :PRIMITIVE-TYPE
   :COMPLEX-SUBTYPEP-ARG1 :INTERNAL-READER-FUNCTION :STATE :ENCLOSING-OBJECT
   :UNSURE :RUN-REASONS :PARSE-STATE-STACK :COMPLEX-TOP-LEVEL :LONG
   :SLOT-ACCESS :PACKAGES :DE.SETF.UTILITY.PACKAGE :DOTTED-LIST :DONT-KNOW
   :CALL-METHOD-ARGS :INHERITANCE-DEPTH :EVAL-WHEN :SET-TRANS :CHECK-FEATURE
   :PARSE-STATE-TERM :COMPONENT-TNS :OPERATOR :NUMBER-ENTRIES :NAE :SIGPIPE
   :COOKIE :XML-CHECK-CHAR-CODES :IN-SUPERS :GENCGC :PATTERNS :REF-TRANS :RT
   :SYSTEM-PATHNAME :XEP :LEXEMS :INTERACTIVE-FUNCTION :UTF16BE :RETURN-PC-PASS
   :SUBSTRUCTURE :START-BREAKPOINT :RESULTS :DECLARATIONS :LOCATION-NUMBER
   :DEFTEST :FORCE-OUTPUT :ORDER :PACKAGE-PATHNAME :T-OK :PRODUCES-SSET
   :ADDR-PRINT-LEN :INPUT-FUNCTION :ARG-LOAD-SCS :INDEX :CLASS-NAME :INDEX-VAR
   :SIGSTKFLT :INCLUDE :ROUNDING-MODE :CURRENT-FILE :LOWER :TEMP :KEYS
   :PARSE-STATE-NON-TERMINAL :POSSIBILITIES :SECOND :NBE :INITARGS
   :NON-LOCAL-LEXICAL-EXIT :ERROR-FILE :INTERPRETED :MOVE-FUNCTIONS :ASCII
   :CURRENT-SIZE :NU :DEFSTRUCT-ACCESSOR-SYMBOL :IF-EXISTS :ALIGN :SIGTRAP
   :TITLE :COMPUTE-ONLY :INFO-ENVIRONMENT :MISFEATURES :CALL-NEXT-METHOD-P
   :JUNK-ALLOWED :MORE-COUNT :FUNSTATE :PARAMS :PER-LINE-PREFIX-END :INTERNAL
   :RESTART-P)

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-parameters.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-character-classes.fasl".

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xqdm-classes.lisp

; In: DEFMETHOD MAKE-INSTANCE (ABSTRACT-CLASS)

;   (XML-ERROR "instantiation precluded for class: ~s." CLASS)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFMETHOD PRINT-OBJECT (|*-content| T)

;   (DEFMETHOD PRINT-OBJECT
;              (# STREAM &AUX EXPR NAME)
;              (SETF NAME #)
;              (COND # # # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK SETQ IF IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD (SETF CHILDREN) (SEQUENCE DOC-NODE)

;   (DEFMETHOD (SETF CHILDREN) (# #) (WITH-SLOTS # DOC # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK LET SYMBOL-MACROLET PCL::PV-SET-SLOT-VALUE LET MULTIPLE-VALUE-BIND 
; --> LET UNLESS COND IF NOT IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-classes.fasl".


; In: LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. SPEC)

;   (TYPEP #:G93 'ABSTRACT-NAME)
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. TYPE)

;   (ETYPECASE SUPERTYPE (XML-SCHEMA-DATATYPES::TYPE-SPECIFIER) (NAME #))
; --> LET COND IF COND IF TYPEP LET OR LET TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xsd-types.lisp

; In:
;     DEFMETHOD TYPE.ELEMENT-TYPE (XML-SCHEMA-DATATYPES::LIST-TYPE-SPECIFIER)

;   (DEFMETHOD TYPE.ELEMENT-TYPE (#) (WITH-SLOTS # SPEC #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK LET 
; --> SYMBOL-MACROLET LET IF IF IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In:
;     DEFMETHOD TYPE.DIRECT-SUPERTYPES (XML-SCHEMA-DATATYPES::TYPE-SPECIFIER)

;   (ETYPECASE SUPERTYPE (XML-SCHEMA-DATATYPES::TYPE-SPECIFIER) (NAME #))
; --> LET COND IF COND IF TYPEP LET OR LET TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xsd-types.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/conditions/names/conditions.fasl".


; In: LAMBDA (#:G6375 #:G6376 #:MEMF6377 #:MEMF6378 #:MEMF6379)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6386 #:G6387 #:MEMF6388 #:MEMF6389 #:MEMF6390)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6397 #:G6398 #:MEMF6399 #:MEMF6400 #:MEMF6401)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6408 #:G6409 #:MEMF6410 #:MEMF6411 #:MEMF6412 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6420 #:G6421 #:MEMF6422 #:MEMF6423 #:MEMF6424 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6432 #:G6433 #:MEMF6434 #:MEMF6435 #:MEMF6436)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/conditions/node/conditions.fasl".


; In: LAMBDA (#:G6443 #:G6444 #:MEMF6445 #:MEMF6446 #:MEMF6447)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6454 #:G6455 #:MEMF6456 #:MEMF6457 #:MEMF6458)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/conditions/model/conditions.fasl".


; In: LAMBDA (#:G6465 #:G6466 #:MEMF6467 #:MEMF6468 #:MEMF6469 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6477 #:G6478 #:MEMF6479 #:MEMF6480 #:MEMF6481 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6489 #:G6490 #:MEMF6491 #:MEMF6492 #:MEMF6493 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6501 #:G6502 #:MEMF6503 #:MEMF6504 #:MEMF6505 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6513 #:G6514 #:MEMF6515 #:MEMF6516 #:MEMF6517)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6524 #:G6525 #:MEMF6526 #:MEMF6527 #:MEMF6528 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6536 #:G6537 #:MEMF6538 #:MEMF6539 #:MEMF6540 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6548 #:G6549 #:MEMF6550 #:MEMF6551 #:MEMF6552 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6560 #:G6561 #:MEMF6562 #:MEMF6563 #:MEMF6564 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6572 #:G6573 #:MEMF6574 #:MEMF6575 #:MEMF6576 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6584 #:G6585 #:MEMF6586 #:MEMF6587 #:MEMF6588 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6596 #:G6597 #:MEMF6598 #:MEMF6599 #:MEMF6600 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6608 #:G6609 #:MEMF6610 #:MEMF6611 #:MEMF6612 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6620 #:G6621 #:MEMF6622 #:MEMF6623 #:MEMF6624 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6632 #:G6633 #:MEMF6634 #:MEMF6635 #:MEMF6636 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6644 #:G6645 #:MEMF6646 #:MEMF6647 #:MEMF6648 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6656 #:G6657 #:MEMF6658 #:MEMF6659 #:MEMF6660 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6668 #:G6669 #:MEMF6670 #:MEMF6671 #:MEMF6672 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6680 #:G6681 #:MEMF6682 #:MEMF6683 #:MEMF6684)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6691 #:G6692 #:MEMF6693 #:MEMF6694 #:MEMF6695 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6703 #:G6704 #:MEMF6705 #:MEMF6706 #:MEMF6707 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6715 #:G6716 #:MEMF6717 #:MEMF6718 #:MEMF6719)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6726 #:G6727 #:MEMF6728 #:MEMF6729 #:MEMF6730 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6738 #:G6739 #:MEMF6740 #:MEMF6741 #:MEMF6742 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6750 #:G6751 #:MEMF6752 #:MEMF6753 #:MEMF6754 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6762 #:G6763 #:MEMF6764 #:MEMF6765 #:MEMF6766 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6774 #:G6775 #:MEMF6776 #:MEMF6777 #:MEMF6778)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6785 #:G6786 #:MEMF6787 #:MEMF6788 #:MEMF6789 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6797 #:G6798 #:MEMF6799 #:MEMF6800 #:MEMF6801 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6809 #:G6810 #:MEMF6811 #:MEMF6812 #:MEMF6813 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6821 #:G6822 #:MEMF6823 #:MEMF6824 #:MEMF6825 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6833 #:G6834 #:MEMF6835 #:MEMF6836 #:MEMF6837)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6844 #:G6845 #:MEMF6846 #:MEMF6847 #:MEMF6848)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6855 #:G6856 #:MEMF6857 #:MEMF6858 #:MEMF6859 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6867 #:G6868 #:MEMF6869 #:MEMF6870 #:MEMF6871)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6878 #:G6879 #:MEMF6880 #:MEMF6881 #:MEMF6882 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6890 #:G6891 #:MEMF6892 #:MEMF6893 #:MEMF6894 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6902 #:G6903 #:MEMF6904 #:MEMF6905 #:MEMF6906 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6914 #:G6915 #:MEMF6916 #:MEMF6917 #:MEMF6918 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6927 #:G6928 #:MEMF6929 #:MEMF6930 #:MEMF6931 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G6939 #:G6940 #:MEMF6941 #:MEMF6942 #:MEMF6943 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xqdm-operators.lisp

; In: DEFMETHOD PREFIX (ELEM-NODE)

;   (DEFMETHOD PREFIX (#) (DECLARE #) (WITH-SLOTS # NODE #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK LET 
; --> SYMBOL-MACROLET LET MULTIPLE-VALUE-BIND LET UNLESS COND IF NOT IF TYPEP 
; --> LET OR LET IF OR TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD PREFIX (ATTR-NODE)

;   (DEFMETHOD PREFIX (#) (DECLARE #) (WITH-SLOTS # NODE #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK LET 
; --> SYMBOL-MACROLET LET MULTIPLE-VALUE-BIND LET UNLESS COND IF NOT IF TYPEP 
; --> LET OR LET IF OR TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFGENERIC NODE-EQUAL

;   #'NODE-EQUAL
; Note: Deleting unreachable code.
; 

; In: DEFGENERIC WALK-NODE

;   (DEFGENERIC WALK-NODE
;               (NODE PREDICATE FUNCTION)
;               (:METHOD :AROUND # # #)
;               (:METHOD # #)
;               ...)
; --> PROGN PUSH LET* LET* DEFMETHOD PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *NODE PREDICATE FUNCTION)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #)
;       ...)
; Note: Declaring special variable *NODE to be ignored.
; 

; In: DEFUN WALK-ELEMENT-DEFINITIONS

;   (TYPEP NODE '(OR DOC-NODE HASH-TABLE DEF-ELEM-TYPE))
; --> LET OR LET IF OR LET TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN WALK-ELEMENTS

;   (TYPEP NODE '(OR DOC-NODE ABSTRACT-ELEM-NODE))
; --> LET OR LET IF OR TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-operators.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xqdm-validation.lisp

; In: DEFMETHOD COMPUTE-VALIDATION-FUNCTION (|content-model|)

;   (TYPECASE NAME (SYMBOL #) (ABSTRACT-NAME #) (T # #))
; --> LET COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD BIND-NET (ATN)

;   (TYPECASE X (STRING T) (PI-NODE T) (COMMENT-NODE T))
; --> LET COND IF COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD VALIDATE-CONTENT (ELEMENT-ATN T)

;   (ETYPECASE DATUM (# #) (STRING #) (PI-NODE #) ...)
; --> LET COND IF COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-validation.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/qname-resolution.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xqdm-graph.lisp

; In: DEFGENERIC WRITE-NODE-GRAPH

;   (DEFGENERIC WRITE-NODE-GRAPH (NODE STREAM) (:METHOD # #) (:METHOD # #) ...)
; --> PROGN PUSH LET* LET* DEFMETHOD PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. NODE *STANDARD-OUTPUT*)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #)
;       ...)
; Note: Declaring special variable *STANDARD-OUTPUT* to be ignored.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-graph.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/node-path-walk.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-walk.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-walk-accessors.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-parameters.lisp

; In: DEFUN BUFFER-STRING-SUBSEQ

;   (- END START)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a RATIONAL.
;     The second argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
;     The second argument is a NUMBER, not a RATIONAL.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a SINGLE-FLOAT.
;     The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a DOUBLE-FLOAT.
;     The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;     The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;     The second argument is a NUMBER, not a REAL.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a REAL.
;     The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;     The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;     The second argument is a NUMBER, not a REAL.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a REAL.
;     The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline float arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a DOUBLE-FLOAT.
;     The second argument is a NUMBER, not a DOUBLE-FLOAT.
;     The result is a NUMBER, not a DOUBLE-FLOAT.
;     Unable to do inline float arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a SINGLE-FLOAT.
;     The second argument is a NUMBER, not a SINGLE-FLOAT.
;     The result is a NUMBER, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN ADJUSTABLE-STRING-SUBSEQ

;   (- END START)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a RATIONAL.
;     The second argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
;     The second argument is a NUMBER, not a RATIONAL.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a SINGLE-FLOAT.
;     The second argument is a NUMBER, not a DOUBLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a DOUBLE-FLOAT.
;     The second argument is a NUMBER, not a SINGLE-FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;     The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
;     The second argument is a NUMBER, not a REAL.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a REAL.
;     The second argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;     The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
;     The second argument is a NUMBER, not a REAL.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a REAL.
;     The second argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
;   (REPLACE RESULT STRING :START2 START ...)
; Note: Unable to optimize due to type uncertainty:
;     The second argument is a BASE-STRING, not a SIMPLE-BASE-STRING.
; 
;   (LENGTH STRING)
; ==>
;   (C::VECTOR-LENGTH VECTOR)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a BASE-STRING, not a (SIMPLE-ARRAY * (*)).
; 
;   (- END START)
; Note: Forced to do GENERIC-- (cost 10).
;     Unable to do inline float arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a DOUBLE-FLOAT.
;     The second argument is a NUMBER, not a DOUBLE-FLOAT.
;     The result is a NUMBER, not a DOUBLE-FLOAT.
;     Unable to do inline float arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a SINGLE-FLOAT.
;     The second argument is a NUMBER, not a SINGLE-FLOAT.
;     The result is a NUMBER, not a SINGLE-FLOAT.
;     etc.
; 

; In: DEFUN RETURN-BUFFER-STRING

;   (LENGTH STRING)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR VECTOR CONS NULL), not a (SIMPLE-ARRAY * (*)).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR VECTOR CONS NULL), not a VECTOR.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-parameters.fasl".

;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/conditions/codec/conditions.fasl".


; In: LAMBDA (#:G6989 #:G6990 #:MEMF6991 #:MEMF6992 #:MEMF6993)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G7000 #:G7001 #:MEMF7002 #:MEMF7003 #:MEMF7004)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-stream-coding.lisp

; In: DEFMETHOD DECODING-STREAM-READER (STREAM (EQL :UTF-8))

;   (XML-ERROR "unsupported unicode datum: ~s." (LIST BYTE1 BYTE2 BYTE3 BYTE4))
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;   (XML-ERROR "illegal UTF-8 data: x~2,'0x." BYTE1)
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;   (LOGAND (READ-BYTE-CODE) 63)
; Note: Forced to do static-function Two-arg-and (cost 53).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a INTEGER, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a INTEGER, not a FIXNUM.
;     etc.
; ; [Last message occurs 3 times]


; In: DEFMETHOD ENCODING-STREAM-WRITER (STREAM (EQL :UTF-8))

;   (XML-ERROR "unsupported unicode datum: ~s." CODE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;   (LET (#)
;     (DOTIMES # #))
; Note: Deleting unreachable code.
; ; [Last message occurs 2 times]

;   (<= CODE 1023)
; --> IF > 
; ==>
;   CODE
; Note: Deleting unreachable code.
; 
;   (FUNCALL-FUNCTION.ARG FUNCTION.ARG (LOGIOR 192 #))
; --> FUNCALL FIRST CAR 
; ==>
;   FUNCTION.ARG
; Note: Deleting unreachable code.
; 
;   (<= CODE 65535)
; --> IF > 
; ==>
;   CODE
; Note: Deleting unreachable code.
; 
;   (FUNCALL-FUNCTION.ARG FUNCTION.ARG (LOGIOR 224 #))
; --> FUNCALL FIRST CAR 
; ==>
;   FUNCTION.ARG
; Note: Deleting unreachable code.
; 
;   (XML-ERROR "unsupported unicode datum: ~s." CODE)
; Note: Deleting unreachable code.
; 
;   (DOTIMES (X #) (FUNCALL-FUNCTION.ARG FUNCTION.ARG #))
; --> DO BLOCK LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET 1+ + 
; ==>
;   X
; Note: Deleting unreachable code.
; 
;   (FUNCALL-FUNCTION.ARG FUNCTION.ARG (CHAR STRING X))
; --> FUNCALL FIRST CAR 
; ==>
;   FUNCTION.ARG
; Note: Deleting unreachable code.
; 

; In: DEFMETHOD DECODING-STREAM-READER (STREAM (EQL :UTF-16-12))

;   (FUNCALL-FUNCTION.ARG FUNCTION.ARG)
; --> FUNCALL C::%FUNCALL IF 
; ==>
;   (KERNEL:%COERCE-TO-FUNCTION FUNCTION)
; Note: Unable to optimize because:
;     Might be a symbol, so must call FDEFINITION at runtime.
; 
;   (LSH (READ-BYTE-CODE) 8)
; ==>
;   (ASH (READ-BYTE-CODE) 8)
; Note: Forced to do full call.
;     Unable to do inline ASH (cost 2) because:
;     The first argument is a INTEGER, not a FIXNUM.
;     The result is a INTEGER, not a FIXNUM.
;     Unable to do inline ASH (cost 3) because:
;     The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;     The result is a INTEGER, not a (UNSIGNED-BYTE 32).
;     etc.
; 
;   (+ (LSH # 8) (READ-BYTE-CODE))
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a INTEGER, not a FIXNUM.
;     The second argument is a INTEGER, not a FIXNUM.
;     The result is a INTEGER, not a FIXNUM.
;     Unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;     The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;     The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;     The result is a INTEGER, not a (SIGNED-BYTE 32).
;     etc.
; 

; In: DEFMETHOD DECODING-STREAM-READER (STREAM (EQL :UTF-16-21))

;   (FUNCALL-FUNCTION.ARG FUNCTION.ARG)
; --> FUNCALL C::%FUNCALL IF 
; ==>
;   (KERNEL:%COERCE-TO-FUNCTION FUNCTION)
; Note: Unable to optimize because:
;     Might be a symbol, so must call FDEFINITION at runtime.
; 
;   (LSH (READ-BYTE-CODE) 8)
; ==>
;   (ASH (READ-BYTE-CODE) 8)
; Note: Forced to do full call.
;     Unable to do inline ASH (cost 2) because:
;     The first argument is a INTEGER, not a FIXNUM.
;     The result is a INTEGER, not a FIXNUM.
;     Unable to do inline ASH (cost 3) because:
;     The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;     The result is a INTEGER, not a (UNSIGNED-BYTE 32).
;     etc.
; 
;   (+ (READ-BYTE-CODE) (LSH # 8))
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a INTEGER, not a FIXNUM.
;     The second argument is a INTEGER, not a FIXNUM.
;     The result is a INTEGER, not a FIXNUM.
;     Unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;     The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;     The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;     The result is a INTEGER, not a (SIGNED-BYTE 32).
;     etc.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-stream-coding.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-operators.lisp

; In: DEFUN MAKE-UNAME

;   (SUBSEQ STRING 0 END)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR VECTOR CONS NULL), not a SIMPLE-BASE-STRING.
; 
;   (POSITION #\: NAMESTRING)
; Note: Unable to open code due to type uncertainty:
;     The second argument is a (OR VECTOR CONS NULL), not a LIST.
; 
; Note: Unable to open code due to type uncertainty:
;     The second argument is a (OR VECTOR CONS NULL), not a SIMPLE-ARRAY.
; 
; Note: Unable to optimize due to type uncertainty:
;     The second argument is a (OR VECTOR CONS NULL), not a SIMPLE-BASE-STRING.
; 
;   (1+ COLON-POSITION)
; ==>
;   (+ COLON-POSITION 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
;   (SUBSEQ NAMESTRING (1+ COLON-POSITION))
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR VECTOR CONS NULL), not a SIMPLE-BASE-STRING.
; 
;   (1+ COLON-POSITION)
; ==>
;   (+ COLON-POSITION 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     etc.
; 
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     etc.
; ; [Last message occurs 2 times]


; In: DEFGENERIC (SETF PREFIX-VALUE)

;   (XML-ERROR "prefix value not bindable: ~s." VALUE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFUN EOL-NORMALIZE-INPUT

;   (INCF *INPUT-LINE*)
; --> LET* 
; ==>
;   (+ *INPUT-LINE* 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     etc.
; 
;   (/= NEXT-BYTE 10)
; --> IF 
; ==>
;   (= NEXT-BYTE 10)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 
;   (INCF *INPUT-LINE*)
; --> LET* 
; ==>
;   (+ *INPUT-LINE* 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Forced to do GENERIC-+ (cost 10).
;     Unable to do inline fixnum arithmetic (cost 1) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The first argument is a NUMBER, not a FIXNUM.
;     The result is a NUMBER, not a FIXNUM.
;     etc.
; 

; In: DEFUN ADVANCE-INPUT

;   (FUNCALL *INPUT-READER* *INPUT-READER-ARG*)
; --> C::%FUNCALL IF 
; ==>
;   (KERNEL:%COERCE-TO-FUNCTION FUNCTION)
; Note: Unable to optimize because:
;     Might be a symbol, so must call FDEFINITION at runtime.
; 
;   (INCF *INPUT-COLUMN*)
; --> LET* 
; ==>
;   (SETQ *INPUT-COLUMN* #:G3)
; Note: Doing signed word to integer coercion (cost 20), for:
;     The second argument of SET.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-operators.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-readers.lisp

; In: DEFUN |_read-entity-ref-name|

;   (= *NAME-LENGTH* 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 
;   (= 1 *NAME-LENGTH*)
; --> = IF 
; ==>
;   (= C::Y 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 

; In: DEFUN |_read-character-entity-ref-name|

;   (= *NAME-LENGTH* 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 
;   (= 1 *NAME-LENGTH*)
; --> = IF 
; ==>
;   (= C::Y 1)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 

; In: DEFUN |_read-operator-name|

;   (= *NAME-LENGTH* 0)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a FLOAT.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; Note: Unable to open code because:
;     Operands might not be the same type.
; 

; In: DEFUN |<-reader|

;   (STRING= NAME "xml")
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR SYMBOL
;                                 BASE-CHAR
;                                 BASE-STRING), not a SIMPLE-BASE-STRING.
; 

; In: DEFUN |<![CDATA[-reader|

;   (STRING= NAME "xml")
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR SYMBOL
;                                 BASE-CHAR
;                                 BASE-STRING), not a SIMPLE-BASE-STRING.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-readers.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-tokenizer.lisp

; In: DEFUN TOKEN-READER

;   (TYPECASE DATUM (FIXNUM # #) (NULL #) (SYMBOL #) ...)
; --> LET COND IF COND IF COND IF COND IF COND IF COND IF COND IF TYPEP 
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN TOKEN-READER =>
;     DEF-INTERNAL-ENTITY (WHEN
;                          (AND #
;                               |REC-xml-19980210.PEs in Internal Subset|
;                               *IN-INTERNAL-SUBSET* ..

;   (LENGTH (CHILDREN DATUM))
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL VECTOR CONS), not a (SIMPLE-ARRAY * (*)).
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR NULL VECTOR CONS), not a VECTOR.
; 

; In: DEFUN TOKEN-READER

;   (FUNCALL MACRO)
; --> C::%FUNCALL IF 
; ==>
;   (KERNEL:%COERCE-TO-FUNCTION FUNCTION)
; Note: Unable to optimize because:
;     Might be a symbol, so must call FDEFINITION at runtime.
; 
;   (FORMAT *TRACE-OUTPUT*
;           " (dispatching with ~s using ~a(~s)->~a)"
;           (PEEK-TOKEN-STRING)
;           (TABLE.NAME *PARSETABLE*)
;           ...)
; ==>
;   (FORMAT C::DEST
;           (FORMATTER " (dispatching with ~s using ~a(~s)->~a)")
;           #:G28
;           #:G29
;           ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR BASE-STRING
;                                 STREAM
;                                 (MEMBER NIL T)), not a STREAM.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR BASE-STRING
;                                 STREAM
;                                 (MEMBER NIL T)), not a (MEMBER T).
; 
;   (FORMAT *TRACE-OUTPUT*
;           "~% (token-reader: ~@[in context ~s~] ~s)"
;           *PARSETABLE*
;           *ATN-STACK)
; ==>
;   (FORMAT C::DEST
;           (FORMATTER "~% (token-reader: ~@[in context ~s~] ~s)")
;           #:G13
;           #:G14)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR BASE-STRING
;                                 STREAM
;                                 (MEMBER NIL T)), not a STREAM.
; 
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a (OR BASE-STRING
;                                 STREAM
;                                 (MEMBER NIL T)), not a (MEMBER T).
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-tokenizer.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-processing-instruction.lisp

; In: DEFUN FIND-PI-NAMESPACE

;   (XML-ERROR "Attempt to locate an undefined namespace: ~s" NAME)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFPIFUNCTION |ns_import|

;   (XML-ERROR "name not present in space: ~s." NAME)
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-processing-instruction.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-constructors.lisp

; In: DEFUN REDUCE-DECL-SEQUENCE

;   (ETYPECASE DECL (DOCTYPE-CHILD-NODE #) (EXT-SUBSET-NODE #) (LIST #))
; --> LET COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFGENERIC CONSTRUCT-CONTENT-SEQUENCE

;   (ETYPECASE CONTENT (EXTERNAL-PARSED-ENTITY #) (# #) (LIST #))
; --> LET COND IF COND IF TYPEP LET OR LET TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFGENERIC CONSTRUCT-NS-NODE

;   (XML-ERROR "namespace name syntax error: ~s: ~s." NAME ATT-VALUE)
; Note: The second argument (in keyword position) is not a constant.
; 

; In: DEFUN CONS-ATTRIBUTE-CHILD-SEQUENCE

;   (XML-ERROR "illegal attribute child: ~s." ATT-CHILD)
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;   (TYPECASE ATT-CHILD
;     (NULL ATT-CHILD-SEQUENCE)
;     (DEF-INTERNAL-ENTITY #)
;     (# #)
;     ...)
; --> LET COND IF COND IF COND IF COND IF TYPEP LET OR LET TYPEP 
; --> C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFCONSTRUCTOR |AttDef-Constructor|

;   (XML-ERROR "unknown tokenized type: ~s." TOKENIZED-TYPE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;   (XML-ERROR "notation/enumeration missing: ~s." ENUMERATED-TYPE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 
;   (XML-ERROR "type missing: ~s." ATT-TYPE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFCONSTRUCTOR |Names|

;   (DEFCONSTRUCTOR |Names| (NAMES NAME) (DECLARE #) (CONS NAME NAMES))
; --> DEFMETHOD PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; --> FUNCTION MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS 
; ==>
;   (LET* (#)
;     (DECLARE #)
;     (DECLARE #)
;     (BLOCK |Names-Constructor| #))
; Warning: Ignore declaration for unknown variable SPACE.
; 
; Warning: Ignore declaration for unknown variable REGISTER.
; 

; In: DEFCONSTRUCTOR |NotationDecl-Constructor|

;   (XML-ERROR "|NotationDecl| public id required: ~s." PUBLIC-ID-ARGS)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFCONSTRUCTORMETHOD |Pi-Constructor|

;   (XML-ERROR "processing instruction error: ~s: ~s: ~a."
;              TARGET
;              LITERAL
;              CONDITION)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFCONSTRUCTOR |StringType|

;   (XML-ERROR "attribute string type is not known: ~s." STRUCTURE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFCONSTRUCTOR |TokenizedType|

;   (XML-ERROR "attribute tokenized type is not known: ~s." STRUCTURE)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFCONSTRUCTOR |VersionInfo|

;   (DEFCONSTRUCTOR |VersionInfo| (VERSION-NUMBER) (DECLARE #) VERSION-NUMBER)
; --> DEFMETHOD PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; --> FUNCTION MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS 
; ==>
;   (LET* (#)
;     (DECLARE #)
;     (DECLARE #)
;     (BLOCK |VersionInfo-Constructor| VERSION-NUMBER))
; Warning: Ignore declaration for unknown variable VERSION-KEYWORD.
; 
; Warning: Ignore declaration for unknown variable EQ.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-constructors.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-parser.lisp

; In: DEFLITERALPREDICATES *LITERAL-STRINGS*

;   (DEFLITERALPREDICATES *LITERAL-STRINGS* "ANY" "CDATA" "encoding" ...)
; --> BLOCK STRING= 
; ==>
;   (COMMON-LISP::STRING=* C::STRING1 C::STRING2 C::START1 C::END1 ...)
; Note: Unable to optimize due to type uncertainty:
;     The first argument is a BASE-STRING, not a SIMPLE-BASE-STRING.
; ; [Last message occurs 26 times]


; In: DEFUN INPUT-REFERENCE

;   (DEFUN INPUT-REFERENCE (POSITION &AUX TOKEN)
;     (DECLARE # # # #)
;     (COND # # # #))
; Warning: Ignore declaration for unknown variable INPUT.
; 
;   (XML-ERROR "token position wrapped: ~s/~s." POSITION *INPUT-INDEX*)
; Note: The second argument (in keyword position) is not a constant.
; 
;   (LOGAND *INPUT-INDEX* *TOKEN-CACHE-MASK*)
; Note: Forced to do static-function Two-arg-and (cost 53).
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The second argument is a INTEGER, not a FIXNUM.
;     Unable to do inline (unsigned-byte 32) arithmetic (cost 3) because:
;     The first argument is a FIXNUM, not a (UNSIGNED-BYTE 32).
;     The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;     etc.
; 
;   (LOGAND POSITION *TOKEN-CACHE-MASK*)
; Note: Forced to do static-function Two-arg-and (cost 53).
;     Unable to do inline fixnum arithmetic (cost 2) because:
;     The second argument is a INTEGER, not a FIXNUM.
;     Unable to do inline (unsigned-byte 32) arithmetic (cost 3) because:
;     The first argument is a (INTEGER -536870912
;                              536870910), not a (UNSIGNED-BYTE 32).
;     The second argument is a INTEGER, not a (SIGNED-BYTE 32).
;     etc.
; 
;   (INCF *INPUT-INDEX*)
; --> LET* 
; ==>
;   (SETQ *INPUT-INDEX* #:G0)
; Note: Doing signed word to integer coercion (cost 20), for:
;     The second argument of SET.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|IS-QName|

;   (DEFUN XML-PARSER::|IS-QName| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-Nmtoken|

;   (DEFUN XML-PARSER::|IS-Nmtoken| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-YesOrNo|

;   (DEFUN XML-PARSER::|IS-YesOrNo| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-StringType|

;   (DEFUN XML-PARSER::|IS-StringType| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-TokenizedType|

;   (DEFUN XML-PARSER::|IS-TokenizedType| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-CDStart|

;   (DEFUN XML-PARSER::|IS-CDStart| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-CDEnd|

;   (DEFUN XML-PARSER::|IS-CDEnd| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-Cardinality|

;   (DEFUN XML-PARSER::|IS-Cardinality| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|IS-MixedCardinality|

;   (DEFUN XML-PARSER::|IS-MixedCardinality| (ITEM) (%ATN-TRACE-FORM #))
; Warning: The result type from previous declaration:
;   (VALUES T T T)
; conflicts with the result type:
;   (MEMBER T NIL)
; 

; In: DEFUN XML-PARSER::|Document|

;   (XML-PARSER::|Document.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Root|

;   (%ATN-TRACE " [***/~a failed @ ~s." 'XML-PARSER::|Root| INDEX)
; --> WHEN COND IF PROGN %ATN-FORMAT PROGN FORMAT 
; ==>
;   " [***/~a failed @ ~s."
; Note: Deleting unreachable code.
; 
;   (FAIL INDEX)
; Note: Deleting unreachable code.
; ; [Last message occurs 2 times]


; In: DEFUN XML-PARSER::|Names|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Nmtokens|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EntityValue|

;   (XML-PARSER::|EntityValue/EntityValue.2.6| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttValue|

;   (XML-PARSER::|AttValue/AttValue.2.6| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttChildSequence|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttChild|

;   (XML-PARSER::|AttChild.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|DefaultAttValue|

;   (XML-PARSER::|DefaultAttValue/DefaultAttValue.2.6| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|DefaultAttChildSequence|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|DefaultAttChild|

;   (XML-PARSER::|DefaultAttChild.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|SystemLiteral|

;   (XML-PARSER::|SystemLiteral/SystemLiteral.2.6| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|PubidLiteral|

;   (XML-PARSER::|PubidLiteral/PubidLiteral.2.6| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Comment|

;   (XML-PARSER::|Comment/Comment.2.5| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Pi|

;   (XML-PARSER::|Pi/Pi.2.6| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|CDSect|

;   (XML-PARSER::|CDSect/CDSect.2.5| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Prolog|

;   (XML-PARSER::|Prolog/Prolog.2.4| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;   (LABELS (# # # # # ...)
;     (DECLARE #)
;     (XML-PARSER::|Prolog/start.1| INDEX)
;     (SETF *ATN-NODE NIL)
;     ...)
; Note: Deleting unused function
;   XML-PARSER::|Prolog/fail.3|
; 

; In: DEFUN XML-PARSER::|DoctypeProlog|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|XMLDecl|

;   (XML-PARSER::|XMLDecl/XMLDecl.2.7| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|VersionInfo|

;   (XML-PARSER::|VersionInfo/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Eq|

;   (XML-PARSER::|Eq.7| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|MiscSequence|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Misc|

;   (XML-PARSER::|Misc.4| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|DoctypeDecl|

;   (XML-PARSER::|DoctypeDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|IntSubsetDecl|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|DeclSep|

;   (XML-PARSER::|DeclSep.4| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|MarkupDecl|

;   (XML-PARSER::|MarkupDecl.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ExtSubset|

;   (LABELS (# # # # # ...)
;     (DECLARE #)
;     (XML-PARSER::|ExtSubset/start.1| INDEX)
;     (SETF *ATN-NODE NIL)
;     ...)
; Note: Deleting unused function
;   XML-PARSER::|ExtSubset/fail.3|
; 
;   (XML-PARSER::|ExtSubset.5| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ExtSubsetDecl|

;   (XML-PARSER::|ExtSubsetDecl.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|SDDecl|

;   (XML-PARSER::|SDDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Element|

;   (XML-PARSER::|Element/Element.2.7| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|STag|

;   (XML-PARSER::|STag/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttributeSequence|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Attribute|

;   (XML-PARSER::|Attribute/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ETag|

;   (XML-PARSER::|ETag/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Content|

;   (XML-PARSER::|Content.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ElementDecl|

;   (XML-PARSER::|ElementDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ContentSpec|

;   (XML-PARSER::|ContentSpec.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Children|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Cp|

;   (XML-PARSER::|Cp.2| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ChoiceOrSeq|

;   (XML-PARSER::|ChoiceOrSeq/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Choice|

;   (XML-PARSER::|Choice/Choice.4.6| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Seq|

;   (XML-PARSER::|Seq/Seq.4.6| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Mixed|

;   (XML-PARSER::|Mixed/Mixed.2.8| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttlistDecl|

;   (XML-PARSER::|AttlistDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttDefSequence|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttDef|

;   (XML-PARSER::|AttDef/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|AttType|

;   (XML-PARSER::|AttType.2| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EnumeratedType|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|NotationType|

;   (XML-PARSER::|NotationType/NotationType.2.7| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|NotationTypeSequence|

;   (XML-PARSER::|NotationTypeSequence/NotationTypeSequence.2.6| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Enumeration|

;   (XML-PARSER::|Enumeration/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EnumerationSequence|

;   (XML-PARSER::|EnumerationSequence/EnumerationSequence.2.4| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|DefaultDecl|

;   (XML-PARSER::|DefaultDecl.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ConditionalSect|

;   (XML-PARSER::|ConditionalSect.2| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|IncludeSect|

;   (XML-PARSER::|IncludeSect/IncludeSect.2.7| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|IgnoreSect|

;   (XML-PARSER::|IgnoreSect/IgnoreSect.2.7| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|IgnoreSectContents|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Ignore|

;   (XML-PARSER::|Ignore.2| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|NamedConditionalSect|

;   (XML-PARSER::|NamedConditionalSect/NamedConditionalSect.2.7| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|CharRef|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Reference|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EntityRef|

;   (XML-PARSER::|EntityRef/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|PEReference|

;   (XML-PARSER::|PEReference/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EntityDecl|

;   (XML-PARSER::|EntityDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|GEDecl|

;   (XML-PARSER::|GEDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|PEDecl|

;   (XML-PARSER::|PEDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EntityDef|

;   (XML-PARSER::|EntityDef.2| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|PEDef|

;   (FAIL INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ExternalID|

;   (XML-PARSER::|ExternalID.7| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|NDataDecl|

;   (XML-PARSER::|NDataDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|TextDecl|

;   (XML-PARSER::|TextDecl/TextDecl.2.5| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|ExtParsedEnt|

;   (LABELS (# # # # # ...)
;     (DECLARE #)
;     (XML-PARSER::|ExtParsedEnt/start.1| INDEX)
;     (SETF *ATN-NODE NIL)
;     ...)
; Note: Deleting unused function
;   XML-PARSER::|ExtParsedEnt/fail.3|
; 
;   (XML-PARSER::|ExtParsedEnt.5| RESULT-INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|EncodingDecl|

;   (XML-PARSER::|EncodingDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|NotationDecl|

;   (XML-PARSER::|NotationDecl/fail.3| INDEX)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|PublicID|

;   (XML-PARSER::|PublicID.7| (1+ INDEX))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFUN XML-PARSER::|Document-Parser|

;   (DEFUN XML-PARSER::|Document-Parser| (*ATN-INPUT &KEY # # # ...)
;     "// generated 2003.04.08T13:20:26 based on \"XML:XML-GRAMMAR.BNF\" from 2003.04.08T12:46:31.
; /*
; 
; <DOCUMENTATION>
 ..)
; Warning: Definition has keyword args, but previous declaration doesn't.
; 
; Warning: Definition has &allow-other-keys, but previous declaration doesn't.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-lib/xml-grammar.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-parser.lisp

; In: DEFMETHOD DOCUMENT-PARSER (FILE-URL)

;   (DEFMETHOD DOCUMENT-PARSER (# &REST ARGS) (WITH-FILE-STREAM # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA
;         (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *XML-BASE* PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #) ..)
; Note: Declaring special variable *XML-BASE* to be ignored.
; 

; In: DEFMETHOD DOCUMENT-PARSER (HTTP-URL)

;   (DEFMETHOD DOCUMENT-PARSER (# &REST ARGS) (WITH-HTTP-STREAM # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA
;         (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *XML-BASE* PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #) ..)
; Note: Declaring special variable *XML-BASE* to be ignored.
; 

; In: DEFMETHOD DOCUMENT-PARSER (DATA-URL)

;   (DEFMETHOD DOCUMENT-PARSER (# &REST ARGS) (WITH-DATA-STREAM # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA
;         (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. *XML-BASE* PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #)
;       (DECLARE #) ..)
; Note: Declaring special variable *XML-BASE* to be ignored.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-parser.fasl".


; In: LAMBDA (#:G7297 #:G7298 #:MEMF7299 #:MEMF7300)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
; Note: Variable STREAM defined but never used.
; 
;;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/atn-lib/xml-grammar.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-printer.lisp

; In: DEFGENERIC WRITE-NODE

;   (DEFGENERIC WRITE-NODE
;               (DATUM STREAM &REST ARGS)
;               (:DOCUMENTATION
;                "encode the node as xml to the provided stream.")
;               (:METHOD # #) ..)
; --> PROGN PUSH LET* LET* DEFMETHOD PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; ==>
;   #'(LAMBDA
;         (PCL::.PV-CELL. PCL::.NEXT-METHOD-CALL. NODE *OUTPUT-DESTINATION*
;          PCL::.REST-ARG.)
;       (DECLARE #)
;       (DECLARE #) ..)
; Note: Declaring special variable *OUTPUT-DESTINATION* to be ignored.
; 

; In: DEFMETHOD ENCODE-NODE (DOC-NODE-INTERFACE)

;   (DEFMETHOD ENCODE-NODE
;              (# &AUX # # # ...)
;              (ENCODE-STRING "<?xml")
;              (WHEN # #)
;              ...)
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK IF LET IF LET 
; --> IF LET IF LET PLUSP > IF > 
; ==>
;   (HASH-TABLE-COUNT (PCL::PV-SLOT-VALUE # # PCL::.SLOTS0. # ...))
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD ENCODE-NODE (DEF-ELEM-PROPERTY-TYPE)

;   (DEFMETHOD ENCODE-NODE
;              (# &AUX # # #)
;              (FLET #
;                #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK FLET IF PROGN 
; --> LET IF IF TYPEP C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-printer.fasl".


; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-writer.lisp

; In: DEFMACRO XML

;   (ETYPECASE TAG (STRING NIL) (SYMBOL NIL) (ABSTRACT-NAME NIL) ...)
; --> LET COND IF COND IF COND IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
;; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xparser/xml-writer.fasl".


; In: DEFPARAMETER |xml|:| |

;   (DEFPARAMETER |xml|:| | '|xml|:| |)
; --> PROGN 
; ==>
;   (SETQ |xml|:| | '|xml|:| |)
; Warning: Undefined variable: |xml|:| |
; 

; In: DEFPARAMETER |xml|:|"|

;   (DEFPARAMETER |xml|:|"| '|xml|:|"|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|"| '|xml|:|"|)
; Warning: Undefined variable: |xml|:|"|
; 

; In: DEFPARAMETER |xml|:|#FIXED|

;   (DEFPARAMETER |xml|:|#FIXED| '|xml|:|#FIXED|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|#FIXED| '|xml|:|#FIXED|)
; Warning: Undefined variable: |xml|:|#FIXED|
; 

; In: DEFPARAMETER |xml|:|#IMPLIED|

;   (DEFPARAMETER |xml|:|#IMPLIED| '|xml|:|#IMPLIED|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|#IMPLIED| '|xml|:|#IMPLIED|)
; Warning: Undefined variable: |xml|:|#IMPLIED|
; 

; In: DEFPARAMETER |xml|:|#PCDATA|

;   (DEFPARAMETER |xml|:|#PCDATA| '|xml|:|#PCDATA|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|#PCDATA| '|xml|:|#PCDATA|)
; Warning: Undefined variable: |xml|:|#PCDATA|
; 

; In: DEFPARAMETER |xml|:|#REQUIRED|

;   (DEFPARAMETER |xml|:|#REQUIRED| '|xml|:|#REQUIRED|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|#REQUIRED| '|xml|:|#REQUIRED|)
; Warning: Undefined variable: |xml|:|#REQUIRED|
; 

; In: DEFPARAMETER |xml|:%

;   (DEFPARAMETER |xml|:% '|xml|:%)
; --> PROGN 
; ==>
;   (SETQ |xml|:% '|xml|:%)
; Warning: Undefined variable: |xml|:%
; 

; In: DEFPARAMETER |xml|:&

;   (DEFPARAMETER |xml|:& '|xml|:&)
; --> PROGN 
; ==>
;   (SETQ |xml|:& '|xml|:&)
; Warning: Undefined variable: |xml|:&
; 

; In: DEFPARAMETER |xml|:|&#|

;   (DEFPARAMETER |xml|:|&#| '|xml|:|&#|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|&#| '|xml|:|&#|)
; Warning: Undefined variable: |xml|:|&#|
; 

; In: DEFPARAMETER |xml|:|&#x|

;   (DEFPARAMETER |xml|:|&#x| '|xml|:|&#x|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|&#x| '|xml|:|&#x|)
; Warning: Undefined variable: |xml|:|&#x|
; 

; In: DEFPARAMETER |xml|:|'|

;   (DEFPARAMETER |xml|:|'| '|xml|:|'|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|'| '|xml|:|'|)
; Warning: Undefined variable: |xml|:|'|
; 

; In: DEFPARAMETER |xml|:|(|

;   (DEFPARAMETER |xml|:|(| '|xml|:|(|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|(| '|xml|:|(|)
; Warning: Undefined variable: |xml|:|(|
; 

; In: DEFPARAMETER |xml|:|)|

;   (DEFPARAMETER |xml|:|)| '|xml|:|)|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|)| '|xml|:|)|)
; Warning: Undefined variable: |xml|:|)|
; 

; In: DEFPARAMETER |xml|:|)*|

;   (DEFPARAMETER |xml|:|)*| '|xml|:|)*|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|)*| '|xml|:|)*|)
; Warning: Undefined variable: |xml|:|)*|
; 

; In: DEFPARAMETER |xml|:*

;   (DEFPARAMETER |xml|:* '|xml|:*)
; --> PROGN 
; ==>
;   (SETQ |xml|:* '|xml|:*)
; Warning: Undefined variable: |xml|:*
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-operators.lisp

; In: DEFUN XML-PARSER::ADVANCE-INPUT

;   (DEFUN ADVANCE-INPUT () (DECLARE # # #) (COND # # # #))
; Warning: Undefined function: XML-PARSER::*INPUT-READER*
; 

; In: DEFPARAMETER |xml|:+

;   (DEFPARAMETER |xml|:+ '|xml|:+)
; --> PROGN 
; ==>
;   (SETQ |xml|:+ '|xml|:+)
; Warning: Undefined variable: |xml|:+
; 

; In: DEFPARAMETER |xml|:|,|

;   (DEFPARAMETER |xml|:|,| '|xml|:|,|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|,| '|xml|:|,|)
; Warning: Undefined variable: |xml|:|,|
; 

; In: DEFPARAMETER |xml|:-->

;   (DEFPARAMETER |xml|:--> '|xml|:-->)
; --> PROGN 
; ==>
;   (SETQ |xml|:--> '|xml|:-->)
; Warning: Undefined variable: |xml|:-->
; 

; In: DEFPARAMETER |xml|:/>

;   (DEFPARAMETER |xml|:/> '|xml|:/>)
; --> PROGN 
; ==>
;   (SETQ |xml|:/> '|xml|:/>)
; Warning: Undefined variable: |xml|:/>
; 

; In: DEFPARAMETER |xml|:|:|

;   (DEFPARAMETER |xml|:|:| '|xml|:|:|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|:| '|xml|:|:|)
; Warning: Undefined variable: |xml|:|:|
; 

; In: DEFPARAMETER |xml|:|;|

;   (DEFPARAMETER |xml|:|;| '|xml|:|;|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|;| '|xml|:|;|)
; Warning: Undefined variable: |xml|:|;|
; 

; In: DEFPARAMETER |xml|:<

;   (DEFPARAMETER |xml|:< '|xml|:<)
; --> PROGN 
; ==>
;   (SETQ |xml|:< '|xml|:<)
; Warning: Undefined variable: |xml|:<
; 

; In: DEFPARAMETER |xml|:<!

;   (DEFPARAMETER |xml|:<! '|xml|:<!)
; --> PROGN 
; ==>
;   (SETQ |xml|:<! '|xml|:<!)
; Warning: Undefined variable: |xml|:<!
; 

; In: DEFPARAMETER |xml|:<!--

;   (DEFPARAMETER |xml|:<!-- '|xml|:<!--)
; --> PROGN 
; ==>
;   (SETQ |xml|:<!-- '|xml|:<!--)
; Warning: Undefined variable: |xml|:<!--
; 

; In: DEFPARAMETER |xml|:<!ATTLIST

;   (DEFPARAMETER |xml|:<!ATTLIST '|xml|:<!ATTLIST)
; --> PROGN 
; ==>
;   (SETQ |xml|:<!ATTLIST '|xml|:<!ATTLIST)
; Warning: Undefined variable: |xml|:<!ATTLIST
; 

; In: DEFPARAMETER |xml|:<!DOCTYPE

;   (DEFPARAMETER |xml|:<!DOCTYPE '|xml|:<!DOCTYPE)
; --> PROGN 
; ==>
;   (SETQ |xml|:<!DOCTYPE '|xml|:<!DOCTYPE)
; Warning: Undefined variable: |xml|:<!DOCTYPE
; 

; In: DEFPARAMETER |xml|:<!ELEMENT

;   (DEFPARAMETER |xml|:<!ELEMENT '|xml|:<!ELEMENT)
; --> PROGN 
; ==>
;   (SETQ |xml|:<!ELEMENT '|xml|:<!ELEMENT)
; Warning: Undefined variable: |xml|:<!ELEMENT
; 

; In: DEFPARAMETER |xml|:<!ENTITY

;   (DEFPARAMETER |xml|:<!ENTITY '|xml|:<!ENTITY)
; --> PROGN 
; ==>
;   (SETQ |xml|:<!ENTITY '|xml|:<!ENTITY)
; Warning: Undefined variable: |xml|:<!ENTITY
; 

; In: DEFPARAMETER |xml|:<!NOTATION

;   (DEFPARAMETER |xml|:<!NOTATION '|xml|:<!NOTATION)
; --> PROGN 
; ==>
;   (SETQ |xml|:<!NOTATION '|xml|:<!NOTATION)
; Warning: Undefined variable: |xml|:<!NOTATION
; 

; In: DEFPARAMETER |xml|:<![

;   (DEFPARAMETER |xml|:<![ '|xml|:<![)
; --> PROGN 
; ==>
;   (SETQ |xml|:<![ '|xml|:<![)
; Warning: Undefined variable: |xml|:<![
; 

; In: DEFPARAMETER |xml|:<![CDATA[

;   (DEFPARAMETER |xml|:<![CDATA[ '|xml|:<![CDATA[)
; --> PROGN 
; ==>
;   (SETQ |xml|:<![CDATA[ '|xml|:<![CDATA[)
; Warning: Undefined variable: |xml|:<![CDATA[
; 

; In: DEFPARAMETER |xml|:</

;   (DEFPARAMETER |xml|:</ '|xml|:</)
; --> PROGN 
; ==>
;   (SETQ |xml|:</ '|xml|:</)
; Warning: Undefined variable: |xml|:</
; 

; In: DEFPARAMETER |xml|:<?

;   (DEFPARAMETER |xml|:<? '|xml|:<?)
; --> PROGN 
; ==>
;   (SETQ |xml|:<? '|xml|:<?)
; Warning: Undefined variable: |xml|:<?
; 

; In: DEFPARAMETER |xml|:|<?xml|

;   (DEFPARAMETER |xml|:|<?xml| '|xml|:|<?xml|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|<?xml| '|xml|:|<?xml|)
; Warning: Undefined variable: |xml|:|<?xml|
; 

; In: DEFPARAMETER |xml|:=

;   (DEFPARAMETER |xml|:= '|xml|:=)
; --> PROGN 
; ==>
;   (SETQ |xml|:= '|xml|:=)
; Warning: Undefined variable: |xml|:=
; 

; In: DEFPARAMETER |xml|:>

;   (DEFPARAMETER |xml|:> '|xml|:>)
; --> PROGN 
; ==>
;   (SETQ |xml|:> '|xml|:>)
; Warning: Undefined variable: |xml|:>
; 

; In: DEFPARAMETER |xml|:?

;   (DEFPARAMETER |xml|:? '|xml|:?)
; --> PROGN 
; ==>
;   (SETQ |xml|:? '|xml|:?)
; Warning: Undefined variable: |xml|:?
; 

; In: DEFPARAMETER |xml|:?>

;   (DEFPARAMETER |xml|:?> '|xml|:?>)
; --> PROGN 
; ==>
;   (SETQ |xml|:?> '|xml|:?>)
; Warning: Undefined variable: |xml|:?>
; 

; In: DEFPARAMETER |xml|:ANY

;   (DEFPARAMETER |xml|:ANY '|xml|:ANY)
; --> PROGN 
; ==>
;   (SETQ |xml|:ANY '|xml|:ANY)
; Warning: Undefined variable: |xml|:ANY
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|AttChild|

;   (DEFUN XML-PARSER::|AttChild| (INDEX &AUX # # #)
;     "AttChild ::= (AttCharData | Reference | ParsedReference)
; (|AttCharData| |ParsedReference| |Reference|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttChild-INDEX|
; 

; In: DEFUN XML-PARSER::|AttChildSequence|

;   (DEFUN XML-PARSER::|AttChildSequence| (INDEX &AUX # #)
;     "AttChildSequence ::= AttChild AttChildSequence?
; (|AttChild| |AttChildSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttChildSequence-INDEX|
; 

; In: DEFUN XML-PARSER::|AttDef|

;   (DEFUN XML-PARSER::|AttDef| (INDEX &AUX # # #)
;     "{53} AttDef ::= S+ QName S+ AttType S+ DefaultDecl
; (|AttType| |DefaultDecl| |QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttDef-INDEX|
; 

; In: DEFUN XML-PARSER::|AttDefSequence|

;   (DEFUN XML-PARSER::|AttDefSequence| (INDEX &AUX # #)
;     "AttDefSequence ::= AttDef AttDefSequence?
; (|AttDef| |AttDefSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttDefSequence-INDEX|
; 

; In: DEFUN XML-PARSER::|AttType|

;   (DEFUN XML-PARSER::|AttType| (INDEX &AUX # # #)
;     "{54} AttType ::= (StringType | TokenizedType | EnumeratedType)
; (|EnumeratedType| |StringType| |TokenizedType|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttType-INDEX|
; 

; In: DEFUN XML-PARSER::|AttValue|

;   (DEFUN XML-PARSER::|AttValue| (INDEX &AUX #)
;     "{10} AttValue ::= (('\"' AttChildSequence? '\"') | (''' AttChildSequence? '''))
; (|AttChildSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttValue-INDEX|
; 

; In: DEFUN XML-PARSER::|AttlistDecl|

;   (DEFUN XML-PARSER::|AttlistDecl| (INDEX &AUX # #)
;     "{52} AttlistDecl ::= '<!ATTLIST' S+ QName AttDefSequence? S* '>'
; (|AttDefSequence| |QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttlistDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|Attribute|

;   (DEFUN XML-PARSER::|Attribute| (INDEX &AUX # #)
;     "{41} Attribute ::= S+ QName Eq AttValue
; (|AttValue| |QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Attribute-INDEX|
; 

; In: DEFUN XML-PARSER::|AttributeSequence|

;   (DEFUN XML-PARSER::|AttributeSequence| (INDEX &AUX # #)
;     "AttributeSequence ::= Attribute AttributeSequence?
; (|Attribute| |AttributeSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|AttributeSequence-INDEX|
; 

; In: DEFPARAMETER |xml|:CDATA

;   (DEFPARAMETER |xml|:CDATA '|xml|:CDATA)
; --> PROGN 
; ==>
;   (SETQ |xml|:CDATA '|xml|:CDATA)
; Warning: Undefined variable: |xml|:CDATA
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|CDSect|

;   (DEFUN XML-PARSER::|CDSect| (INDEX &AUX # # #)
;     "{18} CDSect ::= CDStart CDataCharData? CDEnd
; (|CDataCharData| |CDEnd| |CDStart|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|CDSect-INDEX|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-operators.lisp

; In: DEFUN XML-PARSER::EOL-NORMALIZE-INPUT

;   (DEFUN EOL-NORMALIZE-INPUT (BYTE &AUX NEXT-BYTE)
;     (DECLARE # # # #)
;     (COND # #)
;     ...)
; Warning: Undefined variable: XML-PARSER::CODE
; 
; Warning: Undefined variable: XML-PARSER::COLUMN
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-readers.lisp

; In: DEFUN XML-PARSER::|_read-operator-name|

;   (DEFUN |_read-operator-name| (&AUX #) (DECLARE # # #) (LOOP # # #))
; Warning: Undefined variable: COUNT
; 

; In: DEFUN XML-PARSER::|_read-character-entity-ref-name|

;   (DEFUN |_read-character-entity-ref-name| (&AUX # #)
;     (DECLARE # # #)
;     (SETF CHAR-CODE #)
;     ...)
; Warning: Undefined variable: COUNT
; 

; In: DEFUN XML-PARSER::|_read-entity-ref-name|

;   (DEFUN |_read-entity-ref-name| (&AUX #)
;     (DECLARE # # #)
;     (SETF CHAR-CODE #)
;     ...)
; Warning: Undefined variable: COUNT
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|CharRef|

;   (DEFUN XML-PARSER::|CharRef| (INDEX &AUX # #)
;     "{66} CharRef ::= (('&#' Number ';') | ('&#x' HexNumber ';'))
; (|HexNumber| |Number|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|CharRef-INDEX|
; 

; In: DEFUN XML-PARSER::|Children|

;   (DEFUN XML-PARSER::|Children| (INDEX &AUX # #)
;     "{47} Children ::= ChoiceOrSeq Cardinality?
; (|Cardinality| |ChoiceOrSeq|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Children-INDEX|
; 

; In: DEFUN XML-PARSER::|Choice|

;   (DEFUN XML-PARSER::|Choice| (INDEX &AUX #)
;     "{49} Choice ::= (S* '|' S* Cp)+
; (|Cp|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Choice-INDEX|
; 

; In: DEFUN XML-PARSER::|ChoiceOrSeq|

;   (DEFUN XML-PARSER::|ChoiceOrSeq| (INDEX &AUX # # #)
;     "ChoiceOrSeq ::= '(' S* Cp ((Choice | Seq))? S* ')'
; (|Choice| |Cp| |Seq|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ChoiceOrSeq-INDEX|
; 

; In: DEFUN XML-PARSER::|Comment|

;   (DEFUN XML-PARSER::|Comment| (INDEX &AUX #)
;     "{15} Comment ::= '<!--' CommentCharData? '-->'
; (|CommentCharData|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Comment-INDEX|
; 

; In: DEFUN XML-PARSER::|ConditionalSect|

;   (DEFUN XML-PARSER::|ConditionalSect| (INDEX &AUX # # #)
;     "{61} ConditionalSect ::= (IncludeSect | IgnoreSect | NamedConditionalSect)
; (|IgnoreSect| |IncludeSect| |NamedConditionalSect|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ConditionalSect-INDEX|
; 

; In: DEFUN XML-PARSER::|Content|

;   (DEFUN XML-PARSER::|Content| (INDEX &AUX # # # ...)
;     "{43} Content ::= (CharData | Element | Comment | Pi | CDSect | Reference | ParsedReference)
; (|CDSect| |CharData| |Comment| |Element| |ParsedReference| |Pi| |Reference|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Content-INDEX|
; 

; In: DEFUN XML-PARSER::|ContentSpec|

;   (DEFUN XML-PARSER::|ContentSpec| (INDEX &AUX # # # ...)
;     "{46} ContentSpec ::= (EMPTY | ANY | Mixed | Children)
; (ANY |Children| EMPTY |Mixed|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ContentSpec-INDEX|
; 

; In: DEFUN XML-PARSER::|Cp|

;   (DEFUN XML-PARSER::|Cp| (INDEX &AUX # # #)
;     "{48} Cp ::= ((QName | ChoiceOrSeq)) Cardinality?
; (|Cardinality| |ChoiceOrSeq| |QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Cp-INDEX|
; 

; In: DEFUN XML-PARSER::|DeclSep|

;   (DEFUN XML-PARSER::|DeclSep| (INDEX &AUX # #)
;     "{28a} DeclSep ::= (S+ | PEReference | ParsedExtSubset)
; (|ParsedExtSubset| |PEReference|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|DeclSep-INDEX|
; 

; In: DEFUN XML-PARSER::|DefaultAttChild|

;   (DEFUN XML-PARSER::|DefaultAttChild| (INDEX &AUX # # #)
;     "DefaultAttChild ::= (DefaultAttCharData | Reference | ParsedReference)
; (|DefaultAttCharData| |ParsedReference| |Reference|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|DefaultAttChild-INDEX|
; 

; In: DEFUN XML-PARSER::|DefaultAttChildSequence|

;   (DEFUN XML-PARSER::|DefaultAttChildSequence| (INDEX &AUX # #)
;     "DefaultAttChildSequence ::= DefaultAttChild DefaultAttChildSequence?
; (|DefaultAttChild| |DefaultAttChildSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|DefaultAttChildSequence-INDEX|
; 

; In: DEFUN XML-PARSER::|DefaultAttValue|

;   (DEFUN XML-PARSER::|DefaultAttValue| (INDEX &AUX #)
;     "DefaultAttValue ::= (('\"' DefaultAttChildSequence? '\"') | ('''
;                                                                 DefaultAttChildSequence?
;                                                                 '''))
; (|DefaultAttChildSequence|)" ..)
; Warning: Undefined variable: XML-PARSER::|DefaultAttValue-INDEX|
; 

; In: DEFUN XML-PARSER::|DefaultDecl|

;   (DEFUN XML-PARSER::|DefaultDecl| (INDEX &AUX # # # ...)
;     "{60} DefaultDecl ::= (REQUIRED | IMPLIED | ((FIXED S)? DefaultAttValue))
; (|DefaultAttValue| FIXED IMPLIED REQUIRED)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|DefaultDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|DoctypeDecl|

;   (DEFUN XML-PARSER::|DoctypeDecl| (INDEX &AUX # # #)
;     "{28} DoctypeDecl ::= '<!DOCTYPE' S+ QName (S ExternalID)? S* ('['
;                                                               IntSubsetDecl*
;                                                               ']' S*)? '>'
; (|ExternalID| |IntSubsetDecl| |QName|)" ..)
; Warning: Undefined variable: XML-PARSER::|DoctypeDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|DoctypeProlog|

;   (DEFUN XML-PARSER::|DoctypeProlog| (INDEX &AUX # #)
;     "DoctypeProlog ::= DoctypeDecl MiscSequence?
; (|DoctypeDecl| |MiscSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|DoctypeProlog-INDEX|
; 

; In: DEFUN XML-PARSER::|Document|

;   (DEFUN XML-PARSER::|Document| (INDEX &AUX # # #)
;     "{1 } Document ::= Prolog Root MiscSequence?
; (|MiscSequence| |Prolog| |Root|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Document-INDEX|
; 

; In: DEFPARAMETER |xml|:EMPTY

;   (DEFPARAMETER |xml|:EMPTY '|xml|:EMPTY)
; --> PROGN 
; ==>
;   (SETQ |xml|:EMPTY '|xml|:EMPTY)
; Warning: Undefined variable: |xml|:EMPTY
; 

; In: DEFPARAMETER |xml|:ENTITIES

;   (DEFPARAMETER |xml|:ENTITIES '|xml|:ENTITIES)
; --> PROGN 
; ==>
;   (SETQ |xml|:ENTITIES '|xml|:ENTITIES)
; Warning: Undefined variable: |xml|:ENTITIES
; 

; In: DEFPARAMETER |xml|:ENTITY

;   (DEFPARAMETER |xml|:ENTITY '|xml|:ENTITY)
; --> PROGN 
; ==>
;   (SETQ |xml|:ENTITY '|xml|:ENTITY)
; Warning: Undefined variable: |xml|:ENTITY
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|ETag|

;   (DEFUN XML-PARSER::|ETag| (INDEX &AUX #)
;     "{42} ETag ::= '</' QName S* '>'
; (|QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ETag-INDEX|
; 

; In: DEFUN XML-PARSER::|Element|

;   (DEFUN XML-PARSER::|Element| (INDEX &AUX # # #)
;     "{39} Element ::= STag (('/>' | ('>' Content* ETag)))
; (|Content| |ETag| |STag|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Element-INDEX|
; 

; In: DEFUN XML-PARSER::|ElementDecl|

;   (DEFUN XML-PARSER::|ElementDecl| (INDEX &AUX # #)
;     "{45} ElementDecl ::= '<!ELEMENT' S+ QName S+ ContentSpec S* '>'
; (|ContentSpec| |QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ElementDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|EncodingDecl|

;   (DEFUN XML-PARSER::|EncodingDecl| (INDEX &AUX #)
;     "{80} EncodingDecl ::= S+ encoding Eq ((('\"' EncNameCharData '\"') | ('''
;                                                                     EncNameCharData
;                                                                     ''')))
; (|EncNameCharData|)" ..)
; Warning: Undefined variable: XML-PARSER::|EncodingDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|EntityDecl|

;   (DEFUN XML-PARSER::|EntityDecl| (INDEX &AUX # #)
;     "{70} EntityDecl ::= '<!ENTITY' S+ ((GEDecl | PEDecl))
; (|GEDecl| |PEDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|EntityDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|EntityDef|

;   (DEFUN XML-PARSER::|EntityDef| (INDEX &AUX # # #)
;     "{73} EntityDef ::= (EntityValue | (ExternalID NDataDecl?))
; (|EntityValue| |ExternalID| |NDataDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|EntityDef-INDEX|
; 

; In: DEFUN XML-PARSER::|EntityRef|

;   (DEFUN XML-PARSER::|EntityRef| (INDEX &AUX #)
;     "{68} EntityRef ::= '&' NCName ';'
; (|NCName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|EntityRef-INDEX|
; 

; In: DEFUN XML-PARSER::|EntityValue|

;   (DEFUN XML-PARSER::|EntityValue| (INDEX &AUX #)
;     "{9 } EntityValue ::= (('\"' EntityData? '\"') | (''' EntityData? '''))
; (|EntityData|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|EntityValue-INDEX|
; 

; In: DEFUN XML-PARSER::|EnumeratedType|

;   (DEFUN XML-PARSER::|EnumeratedType| (INDEX &AUX # #)
;     "{57} EnumeratedType ::= (NotationType | Enumeration)
; (|Enumeration| |NotationType|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|EnumeratedType-INDEX|
; 

; In: DEFUN XML-PARSER::|Enumeration|

;   (DEFUN XML-PARSER::|Enumeration| (INDEX &AUX #)
;     "{59} Enumeration ::= '(' EnumerationSequence S* ')'
; (|EnumerationSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Enumeration-INDEX|
; 

; In: DEFUN XML-PARSER::|EnumerationSequence|

;   (DEFUN XML-PARSER::|EnumerationSequence| (INDEX &AUX # #)
;     "EnumerationSequence ::= S* Nmtoken (S* '|' EnumerationSequence)?
; (|EnumerationSequence| |Nmtoken|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|EnumerationSequence-INDEX|
; 

; In: DEFUN XML-PARSER::|Eq|

;   (DEFUN XML-PARSER::|Eq| (INDEX &AUX)
;     "{25} Eq ::= S* '=' S*
; NIL"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Eq-INDEX|
; 

; In: DEFUN XML-PARSER::|ExtParsedEnt|

;   (DEFUN XML-PARSER::|ExtParsedEnt| (INDEX &AUX # #)
;     "{78} ExtParsedEnt ::= TextDecl? Content*
; (|Content| |TextDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ExtParsedEnt-INDEX|
; 

; In: DEFUN XML-PARSER::|ExtSubset|

;   (DEFUN XML-PARSER::|ExtSubset| (INDEX &AUX # #)
;     "{30} ExtSubset ::= TextDecl? ExtSubsetDecl*
; (|ExtSubsetDecl| |TextDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ExtSubset-INDEX|
; 

; In: DEFUN XML-PARSER::|ExtSubsetDecl|

;   (DEFUN XML-PARSER::|ExtSubsetDecl| (INDEX &AUX # # #)
;     "{31} ExtSubsetDecl ::= (MarkupDecl | ConditionalSect | DeclSep)
; (|ConditionalSect| |DeclSep| |MarkupDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|ExtSubsetDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|ExternalID|

;   (DEFUN XML-PARSER::|ExternalID| (INDEX &AUX # #)
;     "{75} ExternalID ::= ((SYSTEM S+ SystemLiteral) | (PUBLIC S+ PubidLiteral S+
;                                                   SystemLiteral))
; (|PubidLiteral| |SystemLiteral|)"
;     (DECLARE #) ..)
; Warning: Undefined variable: XML-PARSER::|ExternalID-INDEX|
; 

; In: DEFUN XML-PARSER::|GEDecl|

;   (DEFUN XML-PARSER::|GEDecl| (INDEX &AUX # #)
;     "{71} GEDecl ::= NCName S+ EntityDef S* '>'
; (|EntityDef| |NCName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|GEDecl-INDEX|
; 

; In: DEFPARAMETER |xml|:ID

;   (DEFPARAMETER |xml|:ID '|xml|:ID)
; --> PROGN 
; ==>
;   (SETQ |xml|:ID '|xml|:ID)
; Warning: Undefined variable: |xml|:ID
; 

; In: DEFPARAMETER |xml|:IDREF

;   (DEFPARAMETER |xml|:IDREF '|xml|:IDREF)
; --> PROGN 
; ==>
;   (SETQ |xml|:IDREF '|xml|:IDREF)
; Warning: Undefined variable: |xml|:IDREF
; 

; In: DEFPARAMETER |xml|:IDREFS

;   (DEFPARAMETER |xml|:IDREFS '|xml|:IDREFS)
; --> PROGN 
; ==>
;   (SETQ |xml|:IDREFS '|xml|:IDREFS)
; Warning: Undefined variable: |xml|:IDREFS
; 

; In: DEFPARAMETER |xml|:IGNORE

;   (DEFPARAMETER |xml|:IGNORE '|xml|:IGNORE)
; --> PROGN 
; ==>
;   (SETQ |xml|:IGNORE '|xml|:IGNORE)
; Warning: Undefined variable: |xml|:IGNORE
; 

; In: DEFPARAMETER |xml|:INCLUDE

;   (DEFPARAMETER |xml|:INCLUDE '|xml|:INCLUDE)
; --> PROGN 
; ==>
;   (SETQ |xml|:INCLUDE '|xml|:INCLUDE)
; Warning: Undefined variable: |xml|:INCLUDE
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|Ignore|

;   (DEFUN XML-PARSER::|Ignore| (INDEX &AUX # #)
;     "{65} Ignore ::= (IgnoreCData | ('<![' IgnoreSectContents? ']]>'))
; (|IgnoreCData| |IgnoreSectContents|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Ignore-INDEX|
; 

; In: DEFUN XML-PARSER::|IgnoreSect|

;   (DEFUN XML-PARSER::|IgnoreSect| (INDEX &AUX #)
;     "{63} IgnoreSect ::= '<![' S* IGNORE S* '[' IgnoreSectContents? ']]>'
; (|IgnoreSectContents|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|IgnoreSect-INDEX|
; 

; In: DEFUN XML-PARSER::|IgnoreSectContents|

;   (DEFUN XML-PARSER::|IgnoreSectContents| (INDEX &AUX # #)
;     "{64} IgnoreSectContents ::= Ignore IgnoreSectContents?
; (|Ignore| |IgnoreSectContents|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|IgnoreSectContents-INDEX|
; 

; In: DEFUN XML-PARSER::|IncludeSect|

;   (DEFUN XML-PARSER::|IncludeSect| (INDEX &AUX #)
;     "{62} IncludeSect ::= '<![' S* INCLUDE S* '[' ExtSubsetDecl* ']]>'
; (|ExtSubsetDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|IncludeSect-INDEX|
; 

; In: DEFUN XML-PARSER::|IntSubsetDecl|

;   (DEFUN XML-PARSER::|IntSubsetDecl| (INDEX &AUX # #)
;     "IntSubsetDecl ::= (DeclSep | MarkupDecl)
; (|DeclSep| |MarkupDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|IntSubsetDecl-INDEX|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-operators.lisp

; In: DEFUN XML-PARSER::EOL-NORMALIZE-INPUT

;   (DEFUN EOL-NORMALIZE-INPUT (BYTE &AUX NEXT-BYTE)
;     (DECLARE # # # #)
;     (COND # #)
;     ...)
; Warning: Undefined variable: XML-PARSER::LIN
; 
; Warning: Undefined variable: XML-PARSER::LINE
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|MarkupDecl|

;   (DEFUN XML-PARSER::|MarkupDecl| (INDEX &AUX # # # ...)
;     "{29} MarkupDecl ::= (ElementDecl | AttlistDecl | EntityDecl | NotationDecl | Pi | Comment)
; (|AttlistDecl| |Comment| |ElementDecl| |EntityDecl| |NotationDecl| |Pi|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|MarkupDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|Misc|

;   (DEFUN XML-PARSER::|Misc| (INDEX &AUX # #)
;     "{27} Misc ::= (Comment | Pi | S+)
; (|Comment| |Pi|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Misc-INDEX|
; 

; In: DEFUN XML-PARSER::|MiscSequence|

;   (DEFUN XML-PARSER::|MiscSequence| (INDEX &AUX # #)
;     "MiscSequence ::= Misc MiscSequence?
; (|Misc| |MiscSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|MiscSequence-INDEX|
; 

; In: DEFUN XML-PARSER::|Mixed|

;   (DEFUN XML-PARSER::|Mixed| (INDEX &AUX #)
;     "{51} Mixed ::= (('(' S* PCDATA (S* '|' S* QName)* S* ')'
;                  MixedCardinality) | ('(' S* PCDATA S* ')'))
; (|QName|)"
;     (DECLARE #) ..)
; Warning: Undefined variable: XML-PARSER::|Mixed-INDEX|
; 

; In: DEFPARAMETER |xml|:NDATA

;   (DEFPARAMETER |xml|:NDATA '|xml|:NDATA)
; --> PROGN 
; ==>
;   (SETQ |xml|:NDATA '|xml|:NDATA)
; Warning: Undefined variable: |xml|:NDATA
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|NDataDecl|

;   (DEFUN XML-PARSER::|NDataDecl| (INDEX &AUX #)
;     "{76} NDataDecl ::= S+ NDATA S+ NCName
; (|NCName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|NDataDecl-INDEX|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/base/tokenizer.lisp

; In: DEFUN TK1::SELECT-TABLE-SIZE

;   (LET* (# #)
;     (DECLARE #)
;     (UNLESS MODULUS #)
;     (VALUES MODULUS #))
; Warning: Undefined variable: TK1::NEW-SIZE
; 

; In: DEFPARAMETER |xml|:NMTOKEN

;   (DEFPARAMETER |xml|:NMTOKEN '|xml|:NMTOKEN)
; --> PROGN 
; ==>
;   (SETQ |xml|:NMTOKEN '|xml|:NMTOKEN)
; Warning: Undefined variable: |xml|:NMTOKEN
; 

; In: DEFPARAMETER |xml|:NMTOKENS

;   (DEFPARAMETER |xml|:NMTOKENS '|xml|:NMTOKENS)
; --> PROGN 
; ==>
;   (SETQ |xml|:NMTOKENS '|xml|:NMTOKENS)
; Warning: Undefined variable: |xml|:NMTOKENS
; 

; In: DEFPARAMETER |xml|:NOTATION

;   (DEFPARAMETER |xml|:NOTATION '|xml|:NOTATION)
; --> PROGN 
; ==>
;   (SETQ |xml|:NOTATION '|xml|:NOTATION)
; Warning: Undefined variable: |xml|:NOTATION
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|NamedConditionalSect|

;   (DEFUN XML-PARSER::|NamedConditionalSect| (INDEX &AUX # #)
;     "NamedConditionalSect ::= '<![' S* PEReference S* '[' ExtSubsetDecl* ']]>'
; (|ExtSubsetDecl| |PEReference|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|NamedConditionalSect-INDEX|
; 

; In: DEFUN XML-PARSER::|Names|

;   (DEFUN XML-PARSER::|Names| (INDEX &AUX # #)
;     "{6 } Names ::= NCName (S Names)?
; (|Names| |NCName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Names-INDEX|
; 

; In: DEFUN XML-PARSER::|Nmtokens|

;   (DEFUN XML-PARSER::|Nmtokens| (INDEX &AUX # #)
;     "{8 } Nmtokens ::= Nmtoken (S Nmtokens)?
; (|Nmtoken| |Nmtokens|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Nmtokens-INDEX|
; 

; In: DEFUN XML-PARSER::|NotationDecl|

;   (DEFUN XML-PARSER::|NotationDecl| (INDEX &AUX # #)
;     "{82} NotationDecl ::= '<!NOTATION' S+ NCName S+ PublicID S* '>'
; (|NCName| |PublicID|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|NotationDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|NotationType|

;   (DEFUN XML-PARSER::|NotationType| (INDEX &AUX #)
;     "{58} NotationType ::= NOTATION S+ '(' S* NotationTypeSequence S* ')'
; (|NotationTypeSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|NotationType-INDEX|
; 

; In: DEFUN XML-PARSER::|NotationTypeSequence|

;   (DEFUN XML-PARSER::|NotationTypeSequence| (INDEX &AUX # #)
;     "NotationTypeSequence ::= NCName (S* '|' S* NotationTypeSequence)?
; (|NCName| |NotationTypeSequence|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|NotationTypeSequence-INDEX|
; 

; In: DEFUN XML-PARSER::|PEDecl|

;   (DEFUN XML-PARSER::|PEDecl| (INDEX &AUX # #)
;     "{72} PEDecl ::= '%' S+ NCName S+ PEDef S* '>'
; (|NCName| |PEDef|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|PEDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|PEDef|

;   (DEFUN XML-PARSER::|PEDef| (INDEX &AUX # #)
;     "{74} PEDef ::= (EntityValue | ExternalID)
; (|EntityValue| |ExternalID|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|PEDef-INDEX|
; 

; In: DEFUN XML-PARSER::|PEReference|

;   (DEFUN XML-PARSER::|PEReference| (INDEX &AUX #)
;     "{69} PEReference ::= '%' NCName ';'
; (|NCName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|PEReference-INDEX|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-tokenizer.lisp

; In: DEFUN XML-PARSER::TOKEN-READER

;   (LET* (# # #)
;     (DECLARE # # # #)
;     (WHEN *ATN-TRACE* #)
;     (LOOP # #))
; Warning: Undefined variable: POSITION
; 

; In: DEFPARAMETER |xml|:PUBLIC

;   (DEFPARAMETER |xml|:PUBLIC '|xml|:PUBLIC)
; --> PROGN 
; ==>
;   (SETQ |xml|:PUBLIC '|xml|:PUBLIC)
; Warning: Undefined variable: |xml|:PUBLIC
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|Pi|

;   (DEFUN XML-PARSER::|Pi| (INDEX &AUX # #)
;     "{16} Pi ::= '<?' PiTarget (S PiCharData?)? '?>'
; (|PiCharData| |PiTarget|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Pi-INDEX|
; 

; In: DEFUN XML-PARSER::|Prolog|

;   (DEFUN XML-PARSER::|Prolog| (INDEX &AUX # # #)
;     "{22} Prolog ::= XMLDecl? MiscSequence? DoctypeProlog?
; (|DoctypeProlog| |MiscSequence| |XMLDecl|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Prolog-INDEX|
; 

; In: DEFUN XML-PARSER::|PubidLiteral|

;   (DEFUN XML-PARSER::|PubidLiteral| (INDEX &AUX #)
;     "{12} PubidLiteral ::= (('\"' PubidCharData? '\"') | (''' PubidCharData? '''))
; (|PubidCharData|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|PubidLiteral-INDEX|
; 

; In: DEFUN XML-PARSER::|PublicID|

;   (DEFUN XML-PARSER::|PublicID| (INDEX &AUX # #)
;     "{83} PublicID ::= ((SYSTEM S+ SystemLiteral) | (PUBLIC S+ PubidLiteral
;                                                 (S+ SystemLiteral)?))
; (|PubidLiteral| |SystemLiteral|)"
;     (DECLARE #) ..)
; Warning: Undefined variable: XML-PARSER::|PublicID-INDEX|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-stream-coding.lisp

; In:
;     DEFMETHOD XML-PARSER::DECODING-STREAM-READER (STREAM (EQL :UTF-16-21))

;   #'(LAMBDA (FUNCTION.ARG) (DECLARE # #) (BLOCK READ-UTF-16-DATUM #))
; Warning: Undefined function: XML-PARSER::READ-BYTE-CODE
; 

; In:
;     DEFMETHOD XML-PARSER::DECODING-STREAM-READER (STREAM (EQL :UTF-16-12))

;   #'(LAMBDA (FUNCTION.ARG) (DECLARE # #) (BLOCK READ-UTF-16-DATUM #))
; Warning: Undefined function: XML-PARSER::READ-BYTE-CODE
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-parser.lisp

; In: DEFMETHOD XML-PARSER:READ-EXTERNAL-ENTITY-DATA (XML-UTILS:HTTP-URL)

;   (DEFMETHOD READ-EXTERNAL-ENTITY-DATA (#) (WITH-HTTP-STREAM # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK LET* 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> C::%WITHIN-CLEANUP RETURN-FROM PROGN SETF SETQ 
; ==>
;   (XML-UTILS::READ-HTTP-HEADER-LINE STREAM)
; Warning: Undefined function: XML-UTILS::READ-HTTP-HEADER-LINE
; 

; In: DEFMETHOD XML-PARSER:DOCUMENT-PARSER (XML-UTILS:HTTP-URL)

;   (DEFMETHOD DOCUMENT-PARSER (# &REST ARGS) (WITH-HTTP-STREAM # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK LET* UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL BLOCK C::%WITHIN-CLEANUP RETURN-FROM PROGN SETF SETQ 
; ==>
;   (XML-UTILS::READ-HTTP-HEADER-LINE STREAM)
; Warning: Undefined function: XML-UTILS::READ-HTTP-HEADER-LINE
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-readers.lisp

; In: DEFUN XML-PARSER::|<![CDATA[-reader|

;   (DEFUN |<![CDATA[-reader| (&AUX # NAME)
;     (DECLARE # # # # ...)
;     (SETF BYTE #)
;     ...)
; Warning: Undefined function: XML-PARSER::READER
; 

; In: DEFUN XML-PARSER::|<-ignore-reader|

;   (DEFUN |<-ignore-reader| (&AUX #) (DECLARE # # # # ...) (SETF BYTE #) ...)
; Warning: Undefined function: XML-PARSER::READER
; 

; In: DEFUN XML-PARSER::|<-reader|

;   (DEFUN |<-reader| (&AUX # NAME) (DECLARE # # # # ...) (SETF BYTE #) ...)
; Warning: Undefined function: XML-PARSER::READER
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|Reference|

;   (DEFUN XML-PARSER::|Reference| (INDEX &AUX # #)
;     "{67} Reference ::= (EntityRef | CharRef)
; (|CharRef| |EntityRef|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Reference-INDEX|
; 

; In: DEFUN XML-PARSER::|Root|

;   (DEFUN XML-PARSER::|Root| (INDEX &AUX #)
;     "Root ::= Element
; (|Element|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Root-INDEX|
; 

; In: DEFUN XML-PARSER::|SDDecl|

;   (DEFUN XML-PARSER::|SDDecl| (INDEX &AUX #)
;     "{32} SDDecl ::= S+ standalone Eq ((('\"' YesOrNo '\"') | (''' YesOrNo ''')))
; (|YesOrNo|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|SDDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|STag|

;   (DEFUN XML-PARSER::|STag| (INDEX &AUX # #)
;     "{40} STag ::= '<' QName AttributeSequence? S*
; (|AttributeSequence| |QName|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|STag-INDEX|
; 

; In: DEFPARAMETER |xml|:SYSTEM

;   (DEFPARAMETER |xml|:SYSTEM '|xml|:SYSTEM)
; --> PROGN 
; ==>
;   (SETQ |xml|:SYSTEM '|xml|:SYSTEM)
; Warning: Undefined variable: |xml|:SYSTEM
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|Seq|

;   (DEFUN XML-PARSER::|Seq| (INDEX &AUX #)
;     "{50} Seq ::= (S* ',' S* Cp)+
; (|Cp|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|Seq-INDEX|
; 

; In: DEFUN XML-PARSER::|SystemLiteral|

;   (DEFUN XML-PARSER::|SystemLiteral| (INDEX &AUX #)
;     "{11} SystemLiteral ::= (('\"' SystemCharData? '\"') | (''' SystemCharData? '''))
; (|SystemCharData|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|SystemLiteral-INDEX|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-operators.lisp

; In: DEFUN XML-PARSER::MAKE-NAME-STRING

;   (LET (# #)
;     (DECLARE # # # #)
;     (DOTIMES # #)
;     (SETF *NAME-LENGTH* 0 *NAME-FILL* *NAME-START*)
;     ...)
; Warning: Undefined variable: XML-PARSER::TOKEN
; 

; In: DEFUN XML-PARSER::MAKE-TOKEN-STRING

;   (LET (# #)
;     (DECLARE # # # #)
;     (DOTIMES # #)
;     (SETF *TOKEN-LENGTH* 0 *TOKEN-END* NIL ...)
;     ...)
; Warning: Undefined variable: XML-PARSER::TOKEN
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|TextDecl|

;   (DEFUN XML-PARSER::|TextDecl| (INDEX &AUX # #)
;     "{77} TextDecl ::= '<?xml' VersionInfo? EncodingDecl S* '?>'
; (|EncodingDecl| |VersionInfo|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|TextDecl-INDEX|
; 

; In: DEFUN XML-PARSER::|VersionInfo|

;   (DEFUN XML-PARSER::|VersionInfo| (INDEX &AUX #)
;     "{24} VersionInfo ::= S+ version Eq ((('\"' VersionNumCharData '\"') | ('''
;                                                                      VersionNumCharData
;                                                                      ''')))
; (|VersionNumCharData|)" ..)
; Warning: Undefined variable: XML-PARSER::|VersionInfo-INDEX|
; ; 

; Warning: Undefined type: WARN
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-operators.lisp

; In: DEFGENERIC XML-PARSER::FIND-UNAME-BINDING

;   (TYPECASE BINDING (CONS #) (HASH-TABLE #) (ABSTRACT-DEF-NODE #) ...)
; --> LET COND IF COND IF COND IF COND IF TYPEP 
; ==>
;   (KERNEL:%TYPEP #:G16 'WARN)
; Warning: Undefined type: WARN
; 
; --> LET COND IF COND IF COND IF COND IF 
; ==>
;   (TYPEP #:G16 'WARN)
; Warning: Undefined type: WARN
; ; 

; Warning: 3 more uses of undefined type WARN.
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/atn-lib/xml-grammar.lisp

; In: DEFUN XML-PARSER::|XMLDecl|

;   (DEFUN XML-PARSER::|XMLDecl| (INDEX &AUX # # #)
;     "{23} XMLDecl ::= '<?xml' VersionInfo EncodingDecl? SDDecl? S* '?>'
; (|EncodingDecl| |SDDecl| |VersionInfo|)"
;     (DECLARE #)
;     ...)
; Warning: Undefined variable: XML-PARSER::|XMLDecl-INDEX|
; 

; In: DEFPARAMETER |xml|:[

;   (DEFPARAMETER |xml|:[ '|xml|:[)
; --> PROGN 
; ==>
;   (SETQ |xml|:[ '|xml|:[)
; Warning: Undefined variable: |xml|:[
; 

; In: DEFPARAMETER |xml|:]

;   (DEFPARAMETER |xml|:] '|xml|:])
; --> PROGN 
; ==>
;   (SETQ |xml|:] '|xml|:])
; Warning: Undefined variable: |xml|:]
; 

; In: DEFPARAMETER |xml|:]]>

;   (DEFPARAMETER |xml|:]]> '|xml|:]]>)
; --> PROGN 
; ==>
;   (SETQ |xml|:]]> '|xml|:]]>)
; Warning: Undefined variable: |xml|:]]>
; 

; In: DEFPARAMETER |xml|:|encoding|

;   (DEFPARAMETER |xml|:|encoding| '|xml|:|encoding|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|encoding| '|xml|:|encoding|)
; Warning: Undefined variable: |xml|:|encoding|
; 

; In: DEFPARAMETER |xml|:|lang|

;   (DEFPARAMETER |xml|:|lang| '|xml|:|lang|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|lang| '|xml|:|lang|)
; Warning: Undefined variable: |xml|:|lang|
; 

; In: DEFPARAMETER |xml|:|no|

;   (DEFPARAMETER |xml|:|no| '|xml|:|no|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|no| '|xml|:|no|)
; Warning: Undefined variable: |xml|:|no|
; 

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xparser/xml-readers.lisp

; In: DEFUN XML-PARSER::|<![CDATA[-reader|

;   (DEFUN |<![CDATA[-reader| (&AUX # NAME)
;     (DECLARE # # # # ...)
;     (SETF BYTE #)
;     ...)
; Warning: Undefined function: XML-PARSER::|read-and-test|
; 

; In: DEFUN XML-PARSER::|<-ignore-reader|

;   (DEFUN |<-ignore-reader| (&AUX #) (DECLARE # # # # ...) (SETF BYTE #) ...)
; Warning: Undefined function: XML-PARSER::|read-and-test|
; 

; In: DEFUN XML-PARSER::|<-reader|

;   (DEFUN |<-reader| (&AUX # NAME) (DECLARE # # # # ...) (SETF BYTE #) ...)
; Warning: Undefined function: XML-PARSER::|read-and-test|
; 

; In: DEFPARAMETER |xml|:|standalone|

;   (DEFPARAMETER |xml|:|standalone| '|xml|:|standalone|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|standalone| '|xml|:|standalone|)
; Warning: Undefined variable: |xml|:|standalone|
; 

; In: DEFPARAMETER |xml|:|version|

;   (DEFPARAMETER |xml|:|version| '|xml|:|version|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|version| '|xml|:|version|)
; Warning: Undefined variable: |xml|:|version|
; 

; In: DEFPARAMETER |xml|:|xml|

;   (DEFPARAMETER |xml|:|xml| '|xml|:|xml|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|xml| '|xml|:|xml|)
; Warning: Undefined variable: |xml|:|xml|
; 

; In: DEFPARAMETER |xml|:|yes|

;   (DEFPARAMETER |xml|:|yes| '|xml|:|yes|)
; --> PROGN 
; ==>
;   (SETQ |xml|:|yes| '|xml|:|yes|)
; Warning: Undefined variable: |xml|:|yes|
; 

; In: DEFPARAMETER |xml|:|\||

;   (DEFPARAMETER |xml|:|\|| '|xml|:|\||)
; --> PROGN 
; ==>
;   (SETQ |xml|:|\|| '|xml|:|\||)
; Warning: Undefined variable: |xml|:|\||
; ; 

; Warning: These variables are undefined:
;   |xml|:| | |xml|:|"| |xml|:|#FIXED| |xml|:|#IMPLIED| |xml|:|#PCDATA| |xml|:|#REQUIRED| |xml|:% |xml|:& |xml|:|&#| |xml|:|&#x| |xml|:|'| |xml|:|(| |xml|:|)| |xml|:|)*| |xml|:* |xml|:+ |xml|:|,| |xml|:--> |xml|:/> |xml|:|:| |xml|:|;| |xml|:< |xml|:<! |xml|:<!-- |xml|:<!ATTLIST |xml|:<!DOCTYPE |xml|:<!ELEMENT |xml|:<!ENTITY |xml|:<!NOTATION |xml|:<![ |xml|:<![CDATA[ |xml|:</ |xml|:<? |xml|:|<?xml| |xml|:= |xml|:> |xml|:? |xml|:?> |xml|:ANY XML-PARSER::|AttChild-INDEX| XML-PARSER::|AttChildSequence-INDEX| XML-PARSER::|AttDef-INDEX| XML-PARSER::|AttDefSequence-INDEX| XML-PARSER::|AttType-INDEX| XML-PARSER::|AttValue-INDEX| XML-PARSER::|AttlistDecl-INDEX| XML-PARSER::|Attribute-INDEX| XML-PARSER::|AttributeSequence-INDEX| |xml|:CDATA XML-PARSER::|CDSect-INDEX| XML-PARSER::CODE XML-PARSER::COLUMN COUNT XML-PARSER::|CharRef-INDEX| XML-PARSER::|Children-INDEX| XML-PARSER::|Choice-INDEX| XML-PARSER::|ChoiceOrSeq-INDEX| XML-PARSER::|Comment-INDEX| XML-PARSER::|ConditionalSect-INDEX| XML-PARSER::|Content-INDEX| XML-PARSER::|ContentSpec-INDEX| XML-PARSER::|Cp-INDEX| XML-PARSER::|DeclSep-INDEX| XML-PARSER::|DefaultAttChild-INDEX| XML-PARSER::|DefaultAttChildSequence-INDEX| XML-PARSER::|DefaultAttValue-INDEX| XML-PARSER::|DefaultDecl-INDEX| XML-PARSER::|DoctypeDecl-INDEX| XML-PARSER::|DoctypeProlog-INDEX| XML-PARSER::|Document-INDEX| |xml|:EMPTY |xml|:ENTITIES |xml|:ENTITY XML-PARSER::|ETag-INDEX| XML-PARSER::|Element-INDEX| XML-PARSER::|ElementDecl-INDEX| XML-PARSER::|EncodingDecl-INDEX| XML-PARSER::|EntityDecl-INDEX| XML-PARSER::|EntityDef-INDEX| XML-PARSER::|EntityRef-INDEX| XML-PARSER::|EntityValue-INDEX| XML-PARSER::|EnumeratedType-INDEX| XML-PARSER::|Enumeration-INDEX| XML-PARSER::|EnumerationSequence-INDEX| XML-PARSER::|Eq-INDEX| XML-PARSER::|ExtParsedEnt-INDEX| XML-PARSER::|ExtSubset-INDEX| XML-PARSER::|ExtSubsetDecl-INDEX| XML-PARSER::|ExternalID-INDEX| XML-PARSER::|GEDecl-INDEX| |xml|:ID |xml|:IDREF |xml|:IDREFS |xml|:IGNORE |xml|:INCLUDE XML-PARSER::|Ignore-INDEX| XML-PARSER::|IgnoreSect-INDEX| XML-PARSER::|IgnoreSectContents-INDEX| XML-PARSER::|IncludeSect-INDEX| XML-PARSER::|IntSubsetDecl-INDEX| XML-PARSER::LIN XML-PARSER::LINE XML-PARSER::|MarkupDecl-INDEX| XML-PARSER::|Misc-INDEX| XML-PARSER::|MiscSequence-INDEX| XML-PARSER::|Mixed-INDEX| |xml|:NDATA XML-PARSER::|NDataDecl-INDEX| TK1::NEW-SIZE |xml|:NMTOKEN |xml|:NMTOKENS |xml|:NOTATION XML-PARSER::|NamedConditionalSect-INDEX| XML-PARSER::|Names-INDEX| XML-PARSER::|Nmtokens-INDEX| XML-PARSER::|NotationDecl-INDEX| XML-PARSER::|NotationType-INDEX| XML-PARSER::|NotationTypeSequence-INDEX| XML-PARSER::|PEDecl-INDEX| XML-PARSER::|PEDef-INDEX| XML-PARSER::|PEReference-INDEX| POSITION |xml|:PUBLIC XML-PARSER::|Pi-INDEX| XML-PARSER::|Prolog-INDEX| XML-PARSER::|PubidLiteral-INDEX| XML-PARSER::|PublicID-INDEX| XML-PARSER::|Reference-INDEX| XML-PARSER::|Root-INDEX| XML-PARSER::|SDDecl-INDEX| XML-PARSER::|STag-INDEX| |xml|:SYSTEM XML-PARSER::|Seq-INDEX| XML-PARSER::|SystemLiteral-INDEX| XML-PARSER::TOKEN XML-PARSER::|TextDecl-INDEX| XML-PARSER::|VersionInfo-INDEX| XML-PARSER::|XMLDecl-INDEX| |xml|:[ |xml|:] |xml|:]]> |xml|:|encoding| |xml|:|lang| |xml|:|no| |xml|:|standalone| |xml|:|version| |xml|:|xml| |xml|:|yes| |xml|:|\||
; ; 

; Warning: These functions are undefined:
;   XML-PARSER::*INPUT-READER* XML-PARSER::READ-BYTE-CODE XML-UTILS::READ-HTTP-HEADER-LINE XML-PARSER::READER XML-PARSER::|read-and-test|
; ; 

; Warning: This type is undefined:
;   WARN
; 

; Compilation unit finished.
;   209 warnings
;   462 notes


T
* (execute-system-operations :xtests '(:load))

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/xquerydatamodel/model.lisp".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/bom.lisp".

NIL
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/document-internal.lisp".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/document-external.lisp".


#<DOC-NODE file://XML/TESTS/XML/CHANNEL.XML {486FDB35}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                  {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|Channel| 1 {48B19BDD}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|Channel|
                         {48B1833D}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 27 entries {486FE32D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {486FE8DD}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {486FD465}>
 IDS                   #<EQL hash table, 0 entries {486FF43D}>
 NOTATIONS             #<EQL hash table, 0 entries {486FF9ED}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|Channel| 1 {48B19BDD}>

#<DOC-NODE file://xml/Tests/xml/channel.xml {48BC42CD}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                  {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|Channel| 1 {48E9BD85}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|Channel|
                         {48E9A4E5}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 27 entries {48BC4AA5}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48BC5055}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {48BC3BFD}>
 IDS                   #<EQL hash table, 0 entries {48BC5BB5}>
 NOTATIONS             #<EQL hash table, 0 entries {48BC5F4D}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|Channel| 1 {48E9BD85}>

#<DOC-NODE file://XML/TESTS/XML/EMAIL.XML {48F68005}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<COMMENT-NODE {48F47745}>
                        #<ELEM-NODE :|mail| 1 {4865070D}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|mail|
                         {4864FCAD}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 9 entries {48F99295}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48F992D5}>
 GENERAL-ENTITIES      #<EQL hash table, 7 entries {48F2CAC5}>
 IDS                   #<EQL hash table, 0 entries {48F99315}>
 NOTATIONS             #<EQL hash table, 0 entries {48F99355}>
 VERSION               "1.0"
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|mail| 1 {4865070D}>
; In: LAMBDA (#:G7977 #:G7978 #:MEMF7979 #:MEMF7980 #:MEMF7981)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

#<DOC-NODE file://XML/TESTS/XML/LISP.XML {486C97A5}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                               {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE |lisp as xml|::LISP 1 {48A29725}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE
                         |-//mecomnet.de//DTD Lisp (sort of)//en|::LISP
                         {48A27F25}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 43 entries {486C9F7D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {486CA52D}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {486C8FC5}>
 IDS                   #<EQL hash table, 0 entries {486CAF7D}>
 NOTATIONS             #<EQL hash table, 0 entries {486CB665}>
 VERSION               "1.0"
 STANDALONE            T
 ROOT                  #<ELEM-NODE |lisp as xml|::LISP 1 {48A29725}>

#<DOC-NODE file://XML/TESTS/XML/REAL-MINI-ALEPH-HET.XML {48D1D7E5}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                              {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :DICTIONARY 1 {48E9EDB5}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :DICTIONARY
                         {48E9E305}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 13 entries {48D1DFBD}>
 PARAMETER-ENTITIES    #<EQL hash table, 2 entries {48D1E56D}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {48D1D115}>
 IDS                   #<EQL hash table, 11 entries {48D1EFBD}>
 NOTATIONS             #<EQL hash table, 0 entries {48D1F685}>
 VERSION               "1.0"
 STANDALONE            NIL
 ROOT                  #<ELEM-NODE :DICTIONARY 1 {48E9EDB5}>
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/document-specialized.lisp".

#<DOC-NODE <no uri> {48F49A3D}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                          {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|envelope| 1 {48F4DD7D}>)
 PARENT                NIL
 ENTITY-INFO           #<ENTITY-INFORMATION-NODE :|| {48F50D95}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 0 entries {48F4A215}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48F4A7C5}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {48F48F35}>
 IDS                   #<EQL hash table, 0 entries {48F4B32D}>
 NOTATIONS             #<EQL hash table, 0 entries {48F4B8DD}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|envelope| 1 {48F4DD7D}>
; Compilation unit aborted.
;   1 note


* *

10
* (in-package "XMLP")

#<The XML-PARSER package, 1481/1574 internal, 111/192 external>
* (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>")

#<DOC-NODE <no uri> {48758F15}>
42
* (root *)

#<ELEM-NODE |envelope| 1 {4878EC7D}>
* (class-precedence-list (class-of *))
; 

; Warning: This function is undefined:
;   CLASS-PRECEDENCE-LIST
; 
* (apropos "CLASS-PRECEDENCE-LIST")

CLASS-PRECEDENCE-LIST
PCL::EARLY-CLASS-PRECEDENCE-LIST [function] (class)
PCL:COMPUTE-CLASS-PRECEDENCE-LIST [function] 
PCL:CLASS-PRECEDENCE-LIST [function] 
KERNEL:STD-COMPUTE-CLASS-PRECEDENCE-LIST [function] (class)
* (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>")

#<DOC-NODE <no uri> {48A836DD}>
42
* (root *)

#<ELEM-NODE |envelope| 1 {48AAD99D}>
* (pcl:class-precedence-list (class-of *))

(#<STANDARD-CLASS ELEM-NODE {486F2D9D}>
 #<ABSTRACT-CLASS UNAMED-NODE {48917005}>
 #<ABSTRACT-CLASS XML-QUERY-DATA-MODEL::UNAMED {48916F75}>
 #<ABSTRACT-CLASS NAMED-NODE {48916EED}>
 #<ABSTRACT-CLASS XML-QUERY-DATA-MODEL::NAMED {48916E6D}>
 #<ABSTRACT-CLASS TYPED-NODE {489171AD}>
 #<ABSTRACT-CLASS ABSTRACT-NODE {48739EFD}>
 #<ABSTRACT-CLASS ABSTRACT-ELEM-NODE {486B924D}>
 #<ABSTRACT-CLASS ORDINAL-NODE {48739ECD}>
 #<ABSTRACT-CLASS DOC-CHILD-NODE {4891769D}>
 #<ABSTRACT-CLASS ELEM-CHILD-NODE {4891762D}>
 #<ABSTRACT-CLASS DOCUMENT-SCOPED-NODE {48739EED}>
 #<ABSTRACT-CLASS ELEM-NODE-INTERFACE {48739EAD}>
 #<STANDARD-CLASS STANDARD-OBJECT {2815F91D}>
 #<SLOT-CLASS PCL::SLOT-OBJECT {2815F9C5}> #<BUILT-IN-CLASS T {281623A5}>)
* (let* ((*specialize-elem-node* t)
       (document (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>"))))


; In: LET* ((*SPECIALIZE-ELEM-NODE* T) (DOCUMENT #))

;   (LET* (# #)
;     )
; Note: Variable DOCUMENT defined but never used.
; 
* (in-package :xqdm)

#<The XML-QUERY-DATA-MODEL package, 572/1574 internal, 553/563 external>
* (defClass doc-node (entity-delegate abstract-node doc-node-interface)
  ((root :initform nil :initarg :root :accessor root :accessor element
         :type abstact-elem-node
         :documentation
         "binds the root element of the document.
          this is also called the <em>document element</em>.
          it is <em>not</em> the <em>document root</em> - that is the doc-node itself.")
   (standalone  :accessor standalone :initarg :standalone :initarg :sddecl
                :initform t
                :documentation
                "indicates that an external subset is required to properly decode a document.
                 the value is ignored by the parser, but it should be set correctly to enable
                 valid serialization. default is <code>T</code>.")
   (version :accessor version :initarg :version :initarg :version-info
            :initform nil)
   (notations  :accessor notations
               :initform (make-hash-table) :type hash-table)
   (ids  :accessor ids
         :initform (make-hash-table) :type hash-table)
   (general-entities :accessor general-entities
                     :initform (make-hash-table) :type hash-table)
   (parameter-entities  :initarg :parameter-entities :accessor parameter-entities
                        :initform (make-hash-table) :type hash-table)
   (types :accessor types
          :initform (make-hash-table) :type hash-table)
   (attributes :initform nil :accessor attributes
          :type list :documentation
          "binds attlist definition instances. these are present for documentation
           purposes only: the effective definitions are integrated in the element
           type definitions.")
   (validate :initform nil :initarg :validate :accessor validate?)
   (namespaces :initform nil :initarg :namespaces :accessor namespaces
               :documentation
               "bind the set of namespaces present within the document.")))

#<STANDARD-CLASS DOC-NODE {486F2D8D}>
* (let* ((*specialize-elem-node* t)
       (document (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>"))))


; In: LET* ((*SPECIALIZE-ELEM-NODE* T) (DOCUMENT #))

;   (LET* (# #)
;     )
; Note: Variable DOCUMENT defined but never used.
; ; 

; Warning: This function is undefined:
;   DOCUMENT-PARSER
; 
* (in-package :xmlp)

#<The XML-PARSER package, 1482/1574 internal, 111/192 external>
* (let* ((*specialize-elem-node* t)
       (document (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>"))))


; In: LET* ((*SPECIALIZE-ELEM-NODE* T) (DOCUMENT #))

;   (LET* (# #)
;     )
; Note: Variable DOCUMENT defined but never used.
; 
* (cl-user::execute-system-operations :xqdm '(:compile :load))

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-namespaces.fasl".

Warning:  KEYWORD also exports the following symbols:
  (:|| :PARAMS :DEBUG-VARIABLES :NAMESPACES :SIGTSTP :|w3597| :|1| :? :C :E :H
   :L :S :U :Z :|a| :|f| :RESTART-P :|p| :OBUF-LENGTH :|x| := :B :EMITTER :D :N
   :%ARREST-REASONS :Q :W :|b| :A :MAC :G :O :R :|Subject|
   :PARSE-STATE-ACTIVE-P :|StartDate| :|country2| :GRAY-STREAMS :AUTODETECT
   :FOREIGN-DATA :SCALE :|c| :SIGXFSZ :NGE :SEC :COST :P :HOST :LOAD-SOURCE
   :SIGNED :BUFFER :F :FOREIGN-FUNCTION :POST-MORE :X86 :VERBOSE-QNAMES :BODY
   :|w2636| :|ns_import| :CODE-COMPONENT :CAPITALIZE-FIRST
   :CODE-LOCATION-NUMBER :QUERY-COMPILE :EXECUTE-TESTS :CHECK-FOR-SUBDIRS
   :BACKLOG :ALLOCATION :REPORT-FUNCTION :URI-TYPE :ELEMENT-SIZE :THE :SEALED
   :SORT :SIGFPE :SLOT :FOLLOW-LINKS :TAGS :BYTE-COMPILE :FUNNY :FETCH-FUNCTION
   :ENSURE-PACKAGE :STRICT-RESULT :INPUT-VARIABLES :MONTH :MOVE-ARGS :ARITY
   :VARIANT-COST :LOAD-PACKAGE :|EndDate| :OUTPUT-FILE :PPRINT-DISPATCH :CPL
   :MAX-EXCLUSIVE :MOK :US-ASCII :TEST-CONSTRAINT :CGC :|NSC: Prefix Immutable|
   :SIGWINCH :BLOCK-END :POLICY :TRACE-NETS :SEGMENT :INSTRUCTION-FLAVORS :BY
   :STOPPED :PRINTNAME :ERROR-FUNCTION :NOTATION :DOTTED :ALIAS-TNS :BACKEND
   :ELSEWHERE-P :VALUES-RECEIVERS :PCL-FUNCALLABLE-INSTANCE-SLOTS :|ns_export|
   :MIN-INCLUSIVE :DEFAULT-MINUTES :GID :PID :UID :UNPARSE-HOST :ALTERNATE-SCS
   :IMPORT-ONLY :DIRECT-DEFAULT-INITARGS :SIGIOT :SUCCESSORS :HZ :NZ
   :ENUMERABLE :SMALLER :|Abstract| :DEBUG-VARS :SYSTEM-KEYWORD :GET-COMMAND
   :|envelope| :WRITE :AUXS :OVERWRITE :HOUR :CONTROL :ROOT :COMPLEXP :TIMEOUT
   :UNPARSED :COLLECT :SIGALRM :NAMED :I486 :NAMES :DOCUMENTATION :LEXICAL-VAR
   :PMAX :MAKE-STACK-POINTER-TN :STATE :TOP-LEVEL-FORM
   :CONTINUE-FORMAT-ARGUMENTS :NAMESPACE-DECLARATION :POSITIVE-INFINITY
   :ENTRY-NOT-FOUND :MORE-ARGS-TYPE :FUN :SUBSPACE :FILE-POSITION :NLE
   :INITIAL-OFFSET :WARN :PARAMETERS :CONT :NON-PACKED :EXCLUDE :XML-WARNING
   :CONDITION-AFTER :JUST-DUMP-IT-NORMALLY :DEFINITION-SOURCE
   :MAKE-DYNAMIC-STATE-TNS :INITIAL-ELEMENT :PRIMITIVE-TYPE-NAMES :24-BIT
   :CONDITION-REPORT :NO-CHANCE :BACK :SIMPLE-CONTINUABLE-CONDITION :CONC-NAME
   :RANDOM-MT19937 :DEBUG-INFO :DISP :LISP :STANDARD-ARGUMENT-LOCATION :ZERO
   :64-BIT :PRINT-SECONDS :SUPPLIED-P :DEFS :FUNCTION-END-COOKIE :REFS
   :NEGATION :PROCESS-GROUP :NODE-CLASS :SYSTEM-CONSTANT :LOCAL :METHOD-SPEC
   :CLEAN-PACKAGE :OUT :CURRENT-CATCH-BLOCK :NO-LAMBDA-LIST :PRINT-PARSE-STATE
   :CACHE-NAME :EOF :URI :WINDOW-TITLE :ATTRIBUTE-MODEL :TRAPS :VALID-MASK
   :IBUF-LENGTH :INTERPRETED-CLOSURE :BASE :CONS-ENTRIES :DYNAMIC :PRODUCTION
   :DICTIONARY :UNKNOWN-RETURN :NAMESPACE-EQUAL :|Envelope| :SETF.CONDITIONS
   :PRINT-LEVEL :NEXT-METHOD-P-P :AND :END :REPORT-CONDITION :FASL-FILE-TYPE
   :TEMP :IBUF-TAIL :UNLABELLED :RUN-SCHEDULER :ARG-TYPES
   :DE.SETF.XML.NAMES.IMPLEMENTATION :BREAKPOINT-NUMBER :ASSUMED :SPARC
   :READ-TIME :GECOS :CONSTANT-PREFIX-P :DECLARE :CALL-SITE :COMPILE-FROM
   :CONDITIONAL-P :COSTS :ARG :PACKAGE :HELP :ROOT-STRUCTURES :ADDR-PRINT-LEN
   :LIBRARIES :INIT :LTN-ANNOTATE :START-PC :NEEDING-REHASH
   :DE.SETF.UTILITY.STRING :|getRate| :SHADOW :HANDLER
   :LISPWORKS-PERSONAL-EDITION :CONTINUABLE-ERROR :DELETED :NLX-ENTRY :WARNINGS
   :|h627| :VARIANT-VARS :IMPLICIT-FOR-REQUIRED :CONDITION-ACTION
   :PRINT-MERIDIAN :COUNT :ISO8601 :|mail| :MORE-ARGUMENT :MSG :CL-USER :TRF
   :XRF :SB-LIST :POSSIBILITIES :FLAG-VARIABLE :IBUF-HEAD :INSTRUCTIONS
   :ENTRY-FOUND :DATE-FIRST :STATUS-HOOK :SYSTEM-PATHNAME :|LatestTime| :BLOCKS
   :ALPHA :PATHNAME-TYPE :MCASE :ERROR-STREAM :SPLIT-SEQUENCE :UNTRUENAME
   :MAXIMUM :READER :PPC :ENTRY :WALK-CALL :SOURCE-ROOT :VANILLA :START2
   :SIGBUS :INPUT-EOF-FUNCTION :DIES :LET :GENERAL-ENTITY-DEFINITION :INHERITS
   :LEVEL :GLIBC2 :REOPTIMIZE :SAVE-SP :LOCAL-CALL :DOTTED-LIST :PROMPT
   :CALLTIME :EMIT-FUNCTION :COMPLEX-INTERSECTION :LITERAL :NON-LOCAL-GO
   :FORCE-OUTPUT :USE :PREFIX-NAMESPACE :NAMESPACE-PRINTNAME :FORCE :AMBIGUOUS
   :PARENT :READERS :EXIT-CODE :SELECT-COMPONENT-FORMAT :FIELDS
   :MACTCP-COMPATIBILITY :INOUT :LISPWORKS4 :DEFAULT-HOURS
   :|VC: No Duplicate Types| :CATCH :DERIVE-TYPE :PATHNAME :DEFINE-SYSTEM
   :ATSIGNP :LOCAL-CONFLICTS :UCS-4-4321 :SECTION :CALL-METHOD-ARGS :BLOCK
   :CLOSE :SOFT :CAR-TYPE :MISER-WIDTH :TOP-N :INITIALIZING :|h153| :|id| :|md|
   :ENTITY-VALUE :NON-LOCAL-LEXICAL-EXIT :PYTHON :BLOCK-START :CALL-WALK
   :FUNCALLABLE-INSTANCE-NAME :DOWN :NEXT-FREE-KV :SPECIAL-FORM
   :CALL-NEXT-METHOD-P :PREREQUISITE :PUBID-LITERAL :START1 :SIGTERM :TYPE-NAME
   :HEADER :VERBOSE :RECURSION :CHOICES :YEAR :CONSTRUCTION-CONTEXT :MATCH
   :ARGUMENT-COLUMN :NUMBER-STACK-P :LABELS :SYSTEM-FILES :UNPARSE-ENOUGH
   :VARIABLES :MORE-COUNT :FUNCTION-END :DOCUMENT-ELEMENT :STRUCT-SET
   :TEMPORARY :ACCESSORS :WRITE-DATE :FIELD :SHADOWING-IMPORT-FROM :NATIVE
   :REGISTER-WORDS :CLEAR :ERROR-FUN :DEFAULT :CONDITION-NAMESPACE :COLONP
   :INITARG :USE-BY :MISC :CONSTANT-VALUE :DE.SETF.UTILITY.PACKAGE :SPECIALP
   :LOAD-INIT-FILE :UCS4-3412 :QUERY-LOAD :DYNCOUNT-INFO :|ingo| :UNPARSE-FILE
   :CONTROL-CYCLE-FUNCTION-NAME :LOCAL-NUMBER :UNSPECIFIED :FRACTION-DIGITS
   :BEEP :UTF8 :NO-COMPILER :FASL-PATHNAME :ARG-DOCUMENTATION :ANSI-CL :USING
   :CONSED-L :TEMP-TEMP :|h1280| :SPECIFIED :CHECK-FEATURE :SPECIFIER :|Logo|
   :RETURN-LIST :ELEMENT-P :WHERE-FROM :MAKE-NFP-TN :PPRO :PRINTER
   :WARNING-FUNCTION :CURRENT-SIZE :NO-HEMLOCK :SIGTTIN :ENDS :DESTRUCT-LAYOUT
   :CLASS-NAME :LOADABLE-PCL :MINIMAL :VALID-STRUCTURES :FORCE-TO-STACK
   :COMPONENT-TNS :UNFILTERED :MAKE-RETURN-PC-SAVE-LOCATION :SMALL
   :SEQUENCE-TYPE :ENVIRONMENT :MOST-SPECIFIC-LAST :MORE-ENTRY :%RUN-REASONS
   :ENUM :UNION :POSN :STRUCTURE :*VERSION* :|Width| :MODULUS
   :PARSE-STATE-NON-TERMINAL :USER-DATA :OVERRIDE :JUNK-ALLOWED :CHARACTER
   :UTF16LE :SPILLED-TNS :PARAMETER-ENTITY-DEFINITION :SINGLE-CHAR-WILD
   :LOCATION-NUMBER :SIGVTALRM :READS :TYPE-KEYWORDS :SEALS
   :CHARACTER-MACRO-TABLE :CLASS-SLOTS :BORN :CLEANUP :CONFIRM
   :DE.SETF.UTILITY.IMPLEMENTATION :ARGUMENT-TEST :DOCS :*TEST-OUTPUT*
   :SUPPORT-ROUTINES :STACK-FRAME-SIZE :ATN-WFST :ATTRIBUTES :|Date| :DONT-KNOW
   :OUTPUT-LATER :|lang| :VALUE2 :DOCUMENT :SITE-INIT
   :DE.SETF.XML.CODEC.IMPLEMENTATION :DE.SETF.XML.INTERFACE :UNARY-COERCE
   :CONSUMES :DE.SETF.XML.NODE.IMPLEMENTATION :LAMBDA-LIST :MAIL :MORE-RESULT
   :SIZE-FUNCTION :CONSTANT :ALIGN :ALLOW-OTHER-KEYS :COMPLEX-= :UTF16BE
   :STRICT :CALL-LIST :EXTENSION :|w552| :DOWNCASE :PRODUCES-SSET :DEPOSIT-GEN
   :SECTION-RELATIVE :SINGLE :RELATIVE :VALUE3 :PRINT-OBJECT :PATH
   :TEMP-VARIABLE :WAIT-TIMEOUT :ABBREVIATED :NDATA-DECL :ARGUMENT
   :NEW-FUNCTIONS :EQ-TEST :BUGS :EXPORT :EVER-USED :AFTER :RESTRICTED-TNS
   :|h432| :|Height| :SAP-MAKER :LAYOUT :CLOSURE-P :RESULT :CONTINUE :ASSOC
   :VERIFY-EXISTANCE :NUM-MORE-ARGS :FORM :ALIEN-INTERNALS :LABELLED
   :EXPANSIONS :LINKAGE-TABLE :|PostURL| :BOOTABLE-PCL :ALIEN-STACK-POINTER
   :MODIFY-PACKAGE-OPERATION :TOKENIZED-TYPE :HASH-BITS :MULTIPLE :KEYWORDS-P
   :|Tracking| :MULTIPLE-READER-SINGLE-WRITER :CANON-TRANSLS :TOP-LEVEL
   :USE-LABEL :LOAD-IF :VALUE1 :PREDICATES :EXITS :ERROR :PRIORITY
   :PARSE-STATE-SOURCE :WHITESPACE :|Recipient| :ADJUSTABLE :PORT
   :LOCATION-PRINT-NAME :GENERATOR-FUNCTION :TABLES :PACKAGE-PATHNAME
   :MAIN-ENTRY :XML-CHECK-CHAR-CODES :CDR-TYPE :PROTOTYPE :EQ-TABLE :CMU18D
   :ACLPC :COMPILED-CLOSURE :POSITIVE :SC-NUMBERS :MULTI-CHAR-WILD :EVAL-WHEN
   :RAW-TYPE :|w2033| :|VC: Enumeration| :BNFP :RECURSIVE :PATCH-TABLE
   :EXTRACT-GEN :USER :INPUT :CHILDREN :INTERPRETED :AUTO-COMPILE :CHECKER
   :ENUMERATED-TYPE :HOOKS :EXPAND :SIGCONT :VARIABLE :FILL :KILL :SDDECL
   :BLOCK-BOUNDARY :FASL-FILE-VERSION :THEN :APPEND :EXTERN :GENERAL-ENTITIES
   :STRUCT :SCHEDULED-RUN-TIME :ALLOW :EXPORT-THROUGH :FAST-MODE :PREDICATE
   :CUSTOMARY-CASE :MAKE-TEST-UNIT :HASH0 :PARTIALLY :HASH4 :BEFORE-ADDRESS
   :INCLUDE-ARGS :VALUE4 :IN-OUT :MODULE :SIGINT :FORCE-P :DISPLAY
   :CIRCULARITY-TABLE :NO-ERROR :MV-CALL :LINK :CONDITION-NAME :NREQ
   :*DEFAULT-PREFIX-STRING* :TOTAL-CONSUMES :PV-CELL :ELEMENT-DEFINITION :IBMRT
   :MODPACKAGE :LOAD-TOPLEVEL :WHILE :|Name| :SPECIFITY :OUTPUT-TERMS :QUALITY
   :MOVE-COSTS :VALUE5 :NAMEVERSION-INFO :MAX-ARGS :FILTERED :LISP-STREAM
   :INSTANCE :ARGP :INFO :PV-SIZE :PRINTED :FORMAT-LENGTH :DIRECTORY :INDEX
   :LEXEMS :NLX-ENTRY-P :PARSE-STATE-CONDITION :PCL-STRUCTURES :REST :ALWAYS
   :SIGIO :KILLED :TAIL :INITIALIZE :INEXACT :IR2-CONVERT :INCLUSIVE :PERMANENT
   :DEBUG-LIVE-TNS :SAVE :UNREAD :CONTENT-NAMES :FROM :|Title|
   :GENERIC-FUNCTION-CLASS :DEFAULT-DEFAULT :EXITED :PREFILTERS
   :PARSE-STATE-TERM :STORAGE-INFO :DENORMALIZED-OPERAND :ATTRIBUTE-NAMES
   :TOP-LEVEL-XEP :ALIEN :UNDEFINED-FUNCTION :PAGES :HAIRY-SLOTS :WITH :SOCKET
   :|isbn| :XPATH :IF-SOURCE-NEWER :BYTES :M68K :INTERNAL-XML-ERROR
   :UNWIND-PROTECT :|st| :OLD-FP :FUNCTIONAL :PINNED :MAKE-PARSE-STATE :DATE
   :|Item| :IMPORTANT :INVALID :PARSED-VOPS :ARG-LOAD-SCS :SINGLE-VALUE-RETURN
   :LINE-LENGTH :LOCATION-COLUMN-WIDTH :TABLE :READTABLE-CASE :DYNAMIC-STATE
   :LOCAL-PART :SHADOWING-IMPORT-TO :BREAK-ALL :DEPENDENCIES :CALL-LEXENV
   :INTERFACE-COOKIE :ACTION :CASE :TLF-NUMBER :INITARGS :RESULT-TYPES :PREV
   :LOGNAME :|Author| :OFFSET-VAR :UNINTERN-TEST :NUMBER :VALUES :RETURN-PC
   :STEP :DUPLICATE :QNAME-EXTENT :SVAR :NAMESPACE-ALGEBRA :SIGN-EXTENDED
   :EMIT-NOP :BUFFER-INDEX :|w3498| :INIT-FORM :COLON-POSITION :UNEXPORT
   :%SHADOWING-SYMBOLS :SIZE :METATYPE :SIGHUP :XML-CONDITION :ANSI
   :RESULT-TYPE :STIPULATION :SIGSEGV :ACTIONS :VECTOR :SECTION-COLUMN
   :OBUF-TAIL :REAL :XCONFORMANCE :AFFECTED :COMPLEX-SUBTYPEP-ARG2 :LEXENV
   :CONSTRUCTOR-SPECIALIZER :|hw| :PARAMETER-ENTITIES :UCS-4-3412 :FIND-TEST
   :INTERACTIVE-FUNCTION :NO-CLM :GENERATE-RETURN-SEQUENCE :END1
   :DE.SETF.UTILITY.TEST :MISER :MAYBE :PRIMITIVE :ANNONYMOUSP :|LastMod|
   :*TERMINAL-PARSER-ERROR-ACTION* :FLOAT :SUPER :MEMBER :ELEMENT-TYPE
   :INFINITY-DATA :REPEAT :PRINT-SPACES :ASSEMBLER-PARAMS
   :CONDITION-CONTINUE-FORMAT-CONTROL :COMPLEX-TOP-LEVEL :GENERATOR-LAMBDA
   :NATURALIZE-GEN :UTF-16 :SIGUSR2 :FORMAT-CONTROL :ENCODING-DECL
   :PTY-PROCESS-GROUP :ARG-CHECK :XML-UTILS :ENCODING :LAST-FORM-RETRIEVED
   :INTERRUPT-CONTEXTS :FUNCTIONS :ASCII :PURGE :WILD-ARGS :WARNING :%NAME
   :TABLE-VAR :DEFEXCEPTION :FROM-END :BOTH :ALIGNMENT :FILES :SOURCE-INFO
   :OPTIMIZE :SAVE-TN :DE.SETF.XML.PROCESS.IMPLEMENTATION :CUR-OFFS
   :CONDITION-CONTINUE-FORMAT-ARGUMENTS :TEST-FUNCTION
   :ARGUMENT-PRECEDENCE-ORDER :RUNNING :AE :TYPE-SYMBOLS :PASSED :INACTIVE
   :RIGHT-MARGIN :RFC1123 :MORE-RESULTS :CONFIRM-COMPILE :RESULT-TEST
   :CONSERVATIVE-FLOAT-TYPE :START-COLUMN :FRESH-LINE-P :HASH-NEW :SERIALIZE-P
   :NUMERIC :BREAK :NET :LIVE :UNPARSE :DWORD :COMPONENT :COMPILED :UNTIL
   :RESERVE-LOCATIONS :MISFEATURES :CONDITIONAL :NEW-VERSION :PARSE-STATE
   :FASL-FILE-IMPLEMENTATION :DEFAULT-DAY :LOCATIONS :DISASSEM-PARAMS :CL-HTTP
   :TYPE-RESTRICTIONS :NAME :|VC: ID| :TYPE-BY-PRECEDENCE :FULL :DOUBLE :NULL
   :TOKENIZER :ARG-INFO :TRACE-P :SIGUSR1 :ALIST :DOTW :AUTO-COMPILE-DEFAULT
   :VERSION>= :GENERATE-CALL-SEQUENCE :SIMPLE-UNION :INSIDE-BLOCK :CUTOFF
   :SUBTYPEP :DEBUG-ENVIRONMENT :DE.SETF.XML.CONDITIONS :EXTERNAL
   :PATH-KEYWORDS :UCS-4-1234 :WORD-PREDICATE :EDGES :PROFILE :DEFAULT-SECONDS
   :INPUT-VECTOR :LOAD-TIME-VALUE :VALID :DEFAULT-INITARGS :PUNCTUATION-P
   :ERROR-CHECK :HASH-FUN :EACH :IN-SUPERS :VOP-VAR :XQDM :%USE-LIST :|pi|
   :CONDITION-PARSE-STATE :INITIATE :LOAD :SOURCE :IMMEDIATE-CONSTANT-SC
   :SXHASH-TOKENIZATION :COMPLEX-UNION :THRESHOLD :MINIMUM :HAIRY :|external|
   :QUERY :XML-SYMBOLS :WHEN :TEMPLATES :PRIMITIVE-TYPE :TARGETS :REMAINING
   :SYSTEM-DESCRIPTION :FINITE :CHECK :NOTATION-TYPE :INSERTION-P :PLIST
   :NORMAL-TNS :OPERATOR :|IntroURI| :GENCGC :MAKE-NUMBER-STACK-POINTER-TN
   :TARGET-FUNCTION :RESULT-TN :MANDATORY :WRITER :CORE-DUMPED :BUFFERING
   :DIRECT-SUPERTYPES :SUBCLASSES :FAILED :DIRECT-SLOTS :WIRE :ELSEWHERE-START
   :EXPORT-ONLY :CLASS :CHOOSE :PURGE-PACKAGE :ITEM :REUSE-ADDRESS :STANDALONE
   :RADIX :FLAGS :ORIGINAL-SOURCE-PATH :REST-ARG-P :XRELEASE :PRINT-HERALD
   :CONDITION :FDEFINITION :CURRENT-UNWIND-PROTECT-BLOCK :WRITES :NAME-TYPE
   :PLUS-INTEGER :BASE-FILE :ALLOCATION-CLASS :INTERNAL/CALLS
   :TOP-LEVEL-FORM-INDEX :STACK-CHECKING :PRINT-ALL :SIGILL :ENTRIES :INTERN
   :REANALYZE :TOKENS :DIRECTION :MEMBERS :FUNCTION-START :CONSTRAINT :NG
   :CONCATENATE-STRING :IMPLIED :CMU17 :IN-INDEX :CMU18 :PURIFY :ENCODED :PWD
   :DATA :MOVE :ELSE :SOURCES :VERSION-INFO :ADDRESS-SIZE :LOWER
   :PRIMITIVE-TYPE-OF :NEXT* :ARRAY :PLACE :HIGH :DIRECT-PREDICATE :SB-NAMES
   :BINARY :HASH3 :PRINT-AFTER :COERCE :HASH7 :FILTERED-VALUES :INITIALLY :DAY
   :VARIANT :METACLASS :COMMENT :MIN-ARGS :RECOMPILE-SOME :EXTERNAL-ID
   :MOST-SPECIFIC-FIRST :ENCLOSING-OBJECT :SYSTEM-LOAD-TIME :ENTRY-POINT
   :MAKE-LOAD-FORM-FUN :INVALID-VALUE-FOR-UNESCAPED-REGISTER-STORAGE
   :SCHEDULER-P :SIMPLE-SUBTYPEP :EMPTY :CMU18E :INLINE-EXPANSION :IGNORES
   :SIGCHLD :MAKE-INITIALIZED-CONDITION :LOCK :FORCE-TO-MEMORY-P :MOVE-VOPS
   :PROCESS-COMMAND-LINE :PV-TABLE-SYMBOL :COMPILE-LOAD-ALWAYS :OPTIONALS
   :CHARACTER-ATTRIBUTE-TABLE :CLOSUREP :INSTANCE-SLOTS-LAYOUT :CORMANLISP
   :UPTO :MAYBE-INLINE :ALIASES :PROPERTIES :SIGQUIT :SPECIAL-ARG-TYPES
   :DEFAULT-YEAR :SAP-FORM :WORDS :NOTE :DEPTH :OPERATION :DEFAULT-MONTH :TITLE
   :LINE :SPECIAL :CODE-OBJECT :SEQUENCE :SAFE :META-SC-NUMBERS
   :DEFAULT-NAMESPACE :STANDARD :EQUAL-FUNCTION-NAME :ARGS-LAMBDA-LIST
   :ORIGINAL :IF-INPUT-DOES-NOT-EXIST :SYSTEM-ID :REFERENCES :%WHOSTATE
   :DEFAULTS :BYTE-ORDER :EDIT :NEXT-OFFS :TIME :ID-ATTR-NODE-P :WRITERS
   :REGISTER-SAVE-PENALTY :HASH-FUNCTION :ZONE :MAKE-CALL-OUT-TNS :EVAL-NAME
   :WHEREIN :PROCEDURE :CONTENT-MODEL :INPUT-FUNCTION :UPPER :ALIEN-REP
   :PEEK-CHAR :HB :%STATUS :SB :MASK :SLOT-NAMES :TYPEP :IGNORE-IT
   :METHOD-CLASS :MORE :NO-CLX :FILE :XML-WARN :ABOVE :*CLASS.TEST-UNIT*
   :|Schedule| :ABORT :ANONYMOUS :IGNOREP :MAKE-OLD-FP-PASSING-LOCATION
   :DEFINER :FLAVOR :DEBUG-VARIABLE :CALLERS-P :EVAL-STACK :DIVIDE-BY-ZERO
   :|PICS-Label| :PREREQUISITES :SIGSTOP :BIND :KIND :LIKE :UNPARSE-DIRECTORY
   :INIT-FUNCTION :BLOW-IT-OFF :FAILED-OPTIMIZATIONS :APPLYP
   :INTERNAL-READER-FUNCTION :FILE-NAME :BOUNDP :INFO-ARG-COUNT
   :CURRENT-CONFLICT :MORE-ARG-COSTS :SECTION-END :STATIC :|henning|
   :MIN-EXCLUSIVE :|type| :ENVIRONMENT-START :NEGATIVE :NOPE :REGISTER :EXPORTN
   :WILD-INFERIORS :OUTPUT-VARIABLES :FAST-FUNCTION :FORMS :UNDERFLOW
   :IF-OUTPUT-EXISTS :LABEL-HASH :UTF-16-21 :%FEATURES :ANSWER-VARIABLE
   :SLOT-NAME :ARG-COSTS :SAFETY :LIST-FIRST :|UserSchedule| :CODESIZE
   :ALTERNATIVE :SCHEDULED-REAL-TIME :WORD :COERCE-TO-GENERIC-FUNCTION :WILD
   :MINUTE :|VC: Entity Name| :RETURN :SYSTEM :REST-P :EVAL :SUBSTRUCTURE
   :ENTRY-TABLE :UNKNOWN-RETURN-PARTNER :METHOD-COMBINATION :MESS-UP :MORE-ARGS
   :QUALIFIERS :BLOCK-COMPILE :CONTEXT-DECLARATIONS :VERBOSITY :SAVE-P
   :HUSHLOGIN :DETAIL :FILTERING :NONE :ENTITY :REMOTEHOST :NEW-METHOD
   :|aPiNode| :INPUT-BUFFER-P :INITIAL-CONTENTS :LEAF :ORIGINAL-SOURCE :EFFECTS
   :DEFUN-ONLY :INTERPRETER-FUNCTION :CSPEED :RETURNS :COPIER :NORMAL :VALUE
   :COUNTS :PRED :MODIFY-PACKAGE :ASSIGNMENT :ARREST-REASONS :START :LENGTH
   :POSITIONS :HOME :PARSER-NAME :|IntervalTime| :DISPLACED-INDEX-OFFSET
   :SUCCESS :START-NAME :TOTAL-DIGITS :ONE-FUNCTION :BEGINNING :VERSION< :WHERE
   :SIGKILL :CMUCLLIB :TRACE-STREAM :TOKENIZER-NAME :SIZE-TEST
   :PREPOSITION-GROUPS :ACCRUED-EXCEPTIONS :ASSEMBLY-ROUTINE :PROCEDURES-TABLE
   :BE :RELATIVEP :NON-LOCAL-EXIT :NE :END-NAME :LISTEN :NODE-VAR :DOWNTO
   :PREDICATE-FORM :PURE :RESULT-COSTS :SET-KNOWN :SOURCE-ANALYSIS :XQUERY
   :ADJUSTED :USASCII :ISO88591 :CAT :EXTENDED :HASH-CODE
   :DIRECT-ANNOTATION-MODEL :COMPLEX-SUBTYPEP-ARG1 :ALLOC-TRANS :STACK-SIZE
   :TIME-P :UNBOUNDED :DOCTYPE-PROLOG :TERM :INITIALIZE-CONDITION
   :CONVERTED-ONCE :COND :PREDICATE-TYPE :DEFAULT-PRINTER :PRETTY :LINEAR
   :HIERARCHICAL :ENCAPSULATED :PV-TABLE :IBUF-SAP :FILL-POINTER :OPENMCL
   :SIGPIPE :SUPPRESS :NO-CHECK :OLD-PCL :AFPA :INLINEP :|Rating|
   :MAKE-ARGUMENT-COUNT-LOCATION :DE.SETF.XML.MODEL.IMPLEMENTATION :RESUMER
   :NOTES :ENVIRONMENT-NAME :INSTRUCTION-FORMATS :FELL-THROUGH :SVSET :EXECUTE
   :CODE-LOCATION :BYTE :UNADJUSTED :TAIL-P :OBUF-SAP :COMMON :INITIAL-FUNCTION
   :FLAG :DIR-STRUCT :BYTE-ANNOTATE :PREDICATE-TYPES :COMMON-LISP-USER :WHICH
   :RUN-REASONS :|Sender| :TK1 :VALUE-TYPE :LIVE-TNS :OBJECT :RESET-TIME
   :GENSYM :MV-LET :TEMPVARS :SLOT-DEFINITION :PROBLEM :PRINT-TIMEZONE
   :%FUNCTION :INTERNAL :|IsVisible| :MORE-CONTEXT :ADDR-LIST :SIGURG
   :NEEDS-NEXT-METHODS-P :CUR-LABELS :PER-LINE-PREFIX :*PACKAGE-OPERATIONS*
   :INST-HOOK :FINAL :ENABLE :DE.SETF.XML.MODEL :SYMBOL-TYPES :INFO-ARGS
   :SOURCE-PATH :TABLE-FREE :INTERNAL-SYMBOLS :COMPONENTS :LOCAL-CONSTANT
   :OLD-DEFINITION :NEW-COMPILER :IDENTITY :ORDINALITY :EXECUTE-TEST :TOO-HAIRY
   :HEAD :READ :UNDEFINED :TEST-FUN :CONDITION-ALL :NAMESPACE-DECLARATIONS
   :REF-ORDERING :ARG-TEMPS :UCS-4-2143 :DE.SETF.XML.BASE.IMPLEMENTATION :DATUM
   :|MinStorage| :|Publisher| :SIGTTOU :XUTIL :LINUX :LINES :TERMS :FINALLY
   :ALIAS :INTERNAL-WRITER-FUNCTION :REHASH-TRIGGER :STACK-GROUP :UNSPECIFIC
   :COPY :INDIRECT :INTERACTIVE-P :ELEMENTS :TAGBODY :SPECIALIZERS :PACKAGES
   :TYPE-PREDICATE :CONSTANT-TNS :RUNTIME :TIMEZONE :NAMESPACE-NAME
   :DEFSTRUCT-ACCESSOR-SYMBOL :LAMBDA :HER :TEMPS :PREFIX :FORMAT-ARGUMENTS
   :PASSWORD :TYPE :VOID :INHERITANCE-DEPTH :BELOW :CODES :UTF-16-12 :MACROS
   :MOVE-FUNCTIONS :|VC: No Duplicate Tokens| :PACKAGE-NOT-FOUND :EXPECTED-TYPE
   :KEY-SIZE :IDENTITY-WITH-ONE-ARGUMENT :FUNCTION :ATN-SYSTEM
   :MORE-RESULTS-TYPE :|EarliestTime| :IEEE-FLOATING-POINT :ARGS :KEYWORDS
   :BREAK-AFTER :READABLY :EXPORT-FROM :INTERNAL-ERROR :INTERACTIVE :UNTRACED
   :HREF :HASH2 :LAMBDAS :HASH6 :INHERITED :ENCLOSING-SOURCE :PATTERN
   :INVALID-OBJECT :INTERN-ONLY :NSDECL-NODES :SPEED :INPUT-TERMS
   :BINDING-STACK :PROPERTY-LIST :|PublicationDate| :RESULT-LOAD-SCS
   :LOAD-OBJECT :MODEL :MORE-RESULT-COSTS :LOAD-TN :%RUN-TIME :EXTENSIONS
   :EPHEMERAL :DTYPE :NODE :CIRCLE :INITIAL-VALUE :HASH-VECTOR :DRAFT-ANSI-CL-2
   :ATTR-NODES :EVAL-STACK-TOP :MAX :LOCAL-LEXICAL-EXIT :CURRENT-EXCEPTIONS
   :DEBUG :KNOWN-VOLATILE :LAST-OFFSET :HPPA :ENCAPSULATE :LABEL :|MIMEType|
   :CONFLICTS :META-SC-NAMES :ROUNDING-MODE :|Keywords| :DIRECT-SUPERCLASSES
   :NLX-INFO :MIME-TYPE :HASH :PRESERVE :TEST-UNIT :SUFFIX-LENGTH :C-TYPE
   :GERDS-PCL :TRANSLATION :RAW :STYLE :CLEAR-OUTPUT :PROBE :UNKNOWN-KEYWORD
   :NEXT-METHOD-CALL :NODES :CONDITION-VECTOR :SYNONYMS :DISPLACED-TO :SIGNALED
   :REF-TRANS :FOREIGN :OPTIMIZE-INTERFACE :VARIABLE-LENGTH :CURRENT-FILE
   :FAILURE :DATA-GRAM :NICKNAMES :TYPE-NUMBER :INITFORM :ENTRIES-INFO :UNLESS
   :EXPRESSION :CREATE :COMPILE-LOAD :|Authorization| :DECLARED
   :SECTION-START-LINE :NEWEST :START-TIME :NEW-DEFINITION :+DELETED+
   :|VC: Name Token| :MACRO :CALLS :USE-LABELS :MISC-SEQUENCE :SPECIAL-BIND
   :DEBUG-FUNCTION :UNARY-TYPEP :ALLEGRO-VERSION>= :OPCODE-COLUMN-WIDTH
   :DISPATCH-TABLES :TRACE :SYSTEM-CLASS :CURRENT :KEY :NO-PCL :MOVE-ARGUMENT
   :AMOUNT :PER-LINE-PREFIX-END :BINDING-STACK-SIZE :SIGN-EXTEND-P
   :CONSTANT-SCS :DEFINITION :STATUS :FOR-KEYWORDS :PRINTER-LIST :DIGITOOL
   :INITFUNCTION :COLNUM :ENTITY-INFO :DEFAULT-WEEKDAY :NA :END2 :PRINT-BANNER
   :REFERENCE :DEFINED :START-POSITIONS :CACHE-TYPES :CONTENT :CODE :OVERFLOW
   :IS-STATIC :SELF-P :MODE :PRINT-FUNCTION :INLINE :USE-ONLY :SIGABRT
   :LEXICAL-VARIABLES :INDEX-VECTOR :CONTROL-STACK-ID :REQUIRED
   :INLINE-EXPANSIONS :BINDS :IGNORE-THIS-ARG :REVERSE :TEST :COMMON-LISP :NB
   :ALLEGRO :TYPE-PREDICATES :FIND-PACKAGES :CONSED-H :UNBOUND :N-BIN
   :BIG-ENDIAN :IO :FORM-NUMBER-MAPPING-TABLE :SIMPLE-INTERSECTION :CACHE-INDEX
   :EDIT-PACKAGE :NEGATIVE-INFINITY :TRANSFORMS :CL :CURRENT-VALID-LOCATIONS
   :STRING-TYPE :|encodingStyle| :STRING+ :MAX-LENGTH :ELSEWHERE-PC :ACTIVE
   :CALLERS :REDUCE :INITIAL :REF-KNOWN :UTF1621 :NC :SC :LOAD-TIME-CODE-FIXUP
   :LISP-REP :ATT-VALUE :|Category| :EARLY-METHOD :|Copyright| :INTERRUPTS
   :ARGLIST :ARGUMENTS :VAR :ROOT-NAME :UCS4-4321 :NFP :WAIT-FUNCTION-ARGS
   :DOCUMENT-NAME :FAIL :ALIEN-STACK :ERROR-ON-MISMATCH
   :DE.SETF.UTILITY.CONDITIONS :XML-ERROR :%REAL-TIME :BEFORE
   :MAKE-OLD-FP-SAVE-LOCATION :FD :ID :ISO-8859-1 :ALTERNATE-METACLASS
   :OBSOLETE :RENAME-AND-DELETE :END-BREAKPOINT :OPTIONS :BOGUS-LRA :NAMESPACE
   :GCS :SCS :MAKE-UNKNOWN-VALUES-LOCATIONS :RESULTS :KNOWN-RETURN
   :|VC: Notation Attributes| :DE.SETF.XML :COMPILE :LOAD-COSTS :FILE-LENGTH
   :FUN-HOOKS :GE :LE :PE :EQUAL-TABLE :DEFTEST :PARSETABLE :RPLACA
   :CONTINUATION :MP :IDS :SET :WHAT :PCL-CLASS :SAP :SHORT :MAX-LOCATIONS
   :METHOD :CLASSES :DOC-STRING :CELL :OUTPUT :XML-QUERY-DATA-MODEL
   :IF-ERROR-EXISTS :VALUATION :CF :IF :OF :LOOP :PREFIX-LENGTH :|Precache|
   :INTERESTING :IGNORE-WHITESPACE :DEBUG-SOURCE :PRIN1 :PRINC :GLOBAL-FUNCTION
   :PARSE-STATE-STACK :PRINT :CLASS-INFO :SIGPROF :BATCH-MODE :TN :UTF16
   :SOURCE-PATHNAME :CONSTRAINTS :UTF-8 :WEAK-P :ORDER :ODD-LENGTH
   :ANY-PRIMITIVE-TYPE :METHODS :EXPRESSIONS :NLX-ENTRIES :FROM-DEFCLASS-P
   :PREDICATE-FUNCTION :NAMESTRING :NAMESET-TOKENIZER :IF-DOES-NOT-EXIST :SHELL
   :PENTIUM :PRIMITIVE-TYPE-ALIASES :UNKNOWN :INTERN-NAMES :INVALIDATE :NEXT
   :TEXT :CONTROL-STRING :SLOTS :OR :ERROR-OUTPUT :LAST-LOCATION-RETRIEVED
   :XMLP :CYCLE-FUNCTION :PRINT-LENGTH :GENSYMS :|IsClonable| :DIRECT-SUBTYPES
   :FLAG-ID :EQ :RPLACD :COMPUTING-CACHE-P :UPCASE :SAME-AS :VIRTUAL
   :FUNCTION-NAME :COMPLEX :CLOSURE :PRINTERS :INCLUDE :NO :FAST :LAST
   :LABELLERS :%USED-BY-LIST :PATHNAME-NAME :|Channel| :MORE-ARGS-ENTRY-POINT
   :ABORTED :|library| :UTF1612 :MOVE-ARG-VOPS :|w4336| :SPLIT-STRING
   :CUR-OFFS-HOOKS :COMPLAINT :GLOBAL-TN-COUNTER :ALLOW-OTHERS
   :CHECK-CONSTRAINT :LHS :RHS :CAPITALIZE :XEP :HOW :%NICKNAMES :LISPWORKS
   :KEYS :CLEAR-INPUT :ENTRY-FUNCTION :PACKAGE-VERSION :ERGEBNIS
   :SPECIFIED-SAVE :PRODUCER :|WFC: Legal Character| :METHOD-NAME-DECLARATION
   :META-SB-NAMES :SUCC :WIRED-TNS :XML-DECL :PREFILTER :FIXED :LINE-RELATIVE
   :AUTO-CLOSE :RECOMPILE :STUB :HIS :FORMAT :ITERATION-KEYWORDS :FUNSTATE
   :CONSTRUCTOR :GOVERNMENT :INITIAL-ARGS :INST-SPACE :INCLUSIVE-PERMITTED
   :FUNCALLABLE-INSTANCE :CONSEQUENT :META-PRIMITIVE-TYPE-NAMES
   :SOURCE-FORM-CACHE :NUM-ARGS :OPTIONAL :CHARPOS :ENUMERATION
   :PRECISION-CONTROL :%LAMBDA-LIST :DELETE-ORIGINAL :ALT :CHAR-POS
   :COMPILER-MACRO :SC-NAMES :CONTEXT :SAVE-ONCE :ENV :PRINT-WEEKDAY :NOTATIONS
   :DIR :BNFP-JAVA :ATHLON :GEN :CCL :MCL :PCL :CACHED-CONSTANT :VALIDATE
   :CONSTANTS :DEFAULT-ZONE :53-BIT :ESCAPE :COLUMN :HISTORY :XTESTS :TAIL-SET
   :|VC: Element Content| :COMPLEX-ARG1 :GENERATOR :GL :SUPERSEDE :NL
   :WALK-FORM :RETURN-PC-PASS :UNBINDABLE-PREFIX-P :LOAD-TIME-VALUE-FIXUP
   :MAKE-NLX-SP-TN :IGNORE-TYPES :REPORT-RECURSION :CMU :LOW :ROW :MIN-LENGTH
   :DATAGRAM :ADDR-TYPE :FAST-SAFE :CHARACTER-SET :FLUSH
   :MAKE-NLX-ENTRY-ARGUMENT-START-LOCATION :REHASH-THRESHOLD :|Body| :OPTIMIZER
   :LARGER :VARS :PRODUCES :HASH1 :HASH5 :PERCENT :POSITION :|Email|
   :HASH-TABLE :|w4337| :TYPE= :TYPES :PRINT-SUMMARY :ARG-TN :|country1|
   :PREDICATE-NAME :SPECIFIED-SAVE-TNS :TRANSLATIONS :DESCRIPTION
   :SPECIALIZED-ELEMENT-TYPE :COUNT-SPACES :WFST :DOC-STRING-ALLOWED
   :LAST-BLOCK-COUNT :STRING :EN :IN :ATN-SOURCE :VERSION :COMPILE-TOPLEVEL
   :PRINTFUNCTION :TYPE-DEFINITION :OUTPUT-STATE :STACK-SLOT :COLLAPSE
   :SPILLED-VOPS :SIGXCPU :DEFTESTS :FINISHED :TEMPLATE-NAMES :SIMPLE-= :RULES
   :TEXT/PLAIN :LETS :SETS :SIGNAL :SECTIONP :ASSEMBLER-RESOURCES :SUFFIX
   :KEYWORD :SECOND :LITTLE-ENDIAN :DECLARATIONS :DO :REANALYZE-FUNCTIONS
   :VERBOSE-P :PO :TO :BYTE-COMPILED-ENTRY :WAIT-RETURN-VALUE :OPERATIONS
   :COMPILE-ALWAYS :GENERA :PTY :DELAYED :MAX-INCLUSIVE :LOWTAG :NOT :DELAY
   :BIN :COOKIE :MIN :SPECVAR :NS-NODES :TEST-NOT :|ns_make| :SIGSTKFLT
   :GLOBAL-CONFLICTS :IN-BUFFER :WITH-NAMESPACES :TARGET :CL-XML-0-918
   :GENERIC-FUNCTION :WAIT-FUNCTION :NUM-RESULTS :SIGN-EXTEND :UPFROM :NP
   :FUNCTION-MAP :UP :BREVITY :BIND-DEFINITIONS :NCONC :|Usage| :PUBLIC-ID
   :CREATED :GENGC :DOCTYPE-DECL :NEW-ASSEM :DEVICE :REALLY-ASSERT :OFFSET
   :GROUPS :AROUND :CONTENTS :NAE :NS :OPERANDS :COLINC :LIST :INTERN-TEST
   :START-USES :NEAREST :CATEGORIES :ENTRY-POINTS :PARSE :COMPILER :PAGE-SIZE
   :DIMENSIONS :MAKE-RETURN-PC-PASSING-LOCATION :OPTIONAL-FIELDS :ALLOWP
   :NON-LOCAL-ENTRY :OPTIONAL-DISPATCH :SHLVL :SBCL :SLOT-NAME-LISTS :FOR
   :BY-NAME :EXTERNAL-SYMBOLS :CONTINUE-FORMAT-CONTROL :REPORT :FRAME :NBE
   :PATTERNS :CACHE :LONG :BREAKPOINT :GR :MULTIPLE-READER-LOCKS :ALWAYS-LIVE
   :SET-TRANS :INITIAL-P :DERIVED-TYPE :SEGMENT-SAP :GUARD :TEST-FN :PRINT-NAME
   :|TextBody| :PROGRESS :TRANSLATE :FIN-FUNCTION :KEYP :SGI :SYSTEM-LITERAL
   :BITS :DOWNFROM :CONSED :DEPORT-GEN :WAIT :DELETED-BLOCK-START :|attr|
   :UNUSED :UNSURE :REHASH-SIZE :SLOT-ACCESS :EXTENT :NEXT-VECTOR
   :ANNOTATION-MODEL :POST-REST :VIRTUAL-LOCATION :RESET-FUNCTION
   :INSTRUCTION-ALIGNMENT :NOP :EXTERNAL-FORMAT :TRUENAMEP :TRACE-FILE
   :PROPAGATE :DEF :START-BREAKPOINT :T-OK :TAB :SIMPLE :PRESERVE-WHITESPACE
   :RECURSE :INDEX-VAR :ACCESSOR :|Priority| :COMMON-ID :|att| :UNIX :XPARSER
   :NT :RT :STREAM :IGNORE :REDUCE-P :LOCAL-PART-EQUAL :|Textbody|
   :FINISH-OUTPUT :IMPORT-FROM :UNINTERNED :ALIEN-STACK-SIZE :INTERNAL-ERRORS
   :PORTABLE-COMMONLOOPS :NOTINLINE :ALL :FULL-CALL :GLOBAL :INITFORM-P :RENAME
   :BOUT :READ-ONLY :SOUT :INVERT :INITIAL-BINDINGS :WALK-FUNCTION :ERROR-FILE
   :ABSOLUTE :SIGTRAP :PROCEDURES :INFO-ENVIRONMENT :NU :LANGUAGE
   :NUMBER-ENTRIES :IF-EXISTS :|xml| :RELATIVE-PACKAGE-NAMES :SPACE
   :COMPUTE-ONLY :GENERATOR-COST :ITS)

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-parameters.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-character-classes.fasl".

; 
; 
; File: /house/janson/XML-0-949-20030408T1846-CRLF/code/xquerydatamodel/xqdm-classes.lisp

; In: DEFMETHOD MAKE-INSTANCE (ABSTRACT-CLASS)

;   (XML-ERROR "instantiation precluded for class: ~s." CLASS)
; Warning: Function has an odd number of arguments in the keyword portion.
; 

; In: DEFMETHOD PRINT-OBJECT (|*-content| T)

;   (DEFMETHOD PRINT-OBJECT
;              (# STREAM &AUX EXPR NAME)
;              (SETF NAME #)
;              (COND # # # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK SETQ IF IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD VALUE (ENUMERATION-ATTR-NODE)

;   (DEFMETHOD VALUE (#) (WITH-SLOTS # NODE #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK LET SYMBOL-MACROLET LET IF IF PROGN IF "<IF Duplication>" 
; --> MULTIPLE-VALUE-BIND LET UNLESS COND IF NOT IF TYPEP LET OR LET IF OR 
; --> TYPEP C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD ENTITY-INFO (ENTITY-DELEGATE)

;   (DEFMETHOD ENTITY-INFO (#) (WITH-SLOTS # NODE #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK LET 
; --> SYMBOL-MACROLET LET MULTIPLE-VALUE-BIND LET UNLESS COND IF NOT IF TYPEP 
; --> LET OR LET TYPEP C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFGENERIC COPY-NODE

;   (DEFGENERIC COPY-NODE
;               (FROM TO)
;               (:DOCUMENTATION "copy slot values from one node to another.
;     slots with bound values are left unchanged.")
;               (:METHOD-COMBINATION PROGN :MOST-SPECIFIC-LAST) ..)
; --> PROGN PUSH LET* LET* DEFMETHOD PROGN PCL::LOAD-DEFMETHOD LIST* LAMBDA 
; --> FUNCTION MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS LET PCL::BIND-ARGS LET* 
; --> PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET BLOCK IF PROGN LET 
; --> MULTIPLE-VALUE-BIND LET UNLESS COND IF NOT IF TYPEP LET OR LET IF OR 
; --> TYPEP C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; ; [Last message occurs 2 times]


; In: DEFMETHOD (SETF CHILDREN) (SEQUENCE DOC-NODE)

;   (DEFMETHOD (SETF CHILDREN) (# #) (WITH-SLOTS # DOC # #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK LET SYMBOL-MACROLET PCL::PV-SET-SLOT-VALUE LET MULTIPLE-VALUE-BIND 
; --> LET UNLESS COND IF NOT IF TYPEP C::%INSTANCE-TYPEP AND IF AND 
; --> KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 

; In: DEFMETHOD DEF (ELEM-NODE)

;   (DEFMETHOD DEF (# &AUX DOCUMENT) (WITH-SLOTS # NODE #))
; --> PROGN PCL::LOAD-DEFMETHOD PCL::LOAD-DEFMETHOD LIST* LAMBDA FUNCTION 
; --> MACROLET PCL::FAST-LEXICAL-METHOD-FUNCTIONS 
; --> PCL::BIND-FAST-LEXICAL-METHOD-MACROS MACROLET 
; --> PCL::BIND-LEXICAL-METHOD-FUNCTIONS PCL::CALL-NEXT-METHOD-BIND LET FLET 
; --> PCL::BIND-ARGS LET* PCL::PV-BINDING PCL::PV-BINDING1 PCL::PV-ENV LET LET 
; --> BLOCK LET SYMBOL-MACROLET LET IF LET THE IF IF "<IF Duplication>" 
; --> MULTIPLE-VALUE-BIND LET UNLESS COND IF NOT IF TYPEP LET OR LET IF OR 
; --> TYPEP C::%INSTANCE-TYPEP AND IF AND KERNEL:CLASS-CELL-TYPEP 
; ==>
;   (KERNEL:LAYOUT-OF C::OBJECT)
; Note: *Inline-Expansion-Limit* (2) exceeded, probably trying to
;   inline a recursive function.
; 
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-classes.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xsd-types.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/conditions/names/conditions.fasl".


; In: LAMBDA (#:G10050 #:G10051 #:MEMF10052 #:MEMF10053 #:MEMF10054)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10061 #:G10062 #:MEMF10063 #:MEMF10064 #:MEMF10065)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10072 #:G10073 #:MEMF10074 #:MEMF10075 #:MEMF10076)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10083 #:G10084 #:MEMF10085 #:MEMF10086 #:MEMF10087 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10095 #:G10096 #:MEMF10097 #:MEMF10098 #:MEMF10099 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10107 #:G10108 #:MEMF10109 #:MEMF10110 #:MEMF10111)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/conditions/node/conditions.fasl".


; In: LAMBDA (#:G10118 #:G10119 #:MEMF10120 #:MEMF10121 #:MEMF10122)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10129 #:G10130 #:MEMF10131 #:MEMF10132 #:MEMF10133)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/conditions/model/conditions.fasl".


; In: LAMBDA (#:G10140 #:G10141 #:MEMF10142 #:MEMF10143 #:MEMF10144 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10152 #:G10153 #:MEMF10154 #:MEMF10155 #:MEMF10156 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10164 #:G10165 #:MEMF10166 #:MEMF10167 #:MEMF10168 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10176 #:G10177 #:MEMF10178 #:MEMF10179 #:MEMF10180 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10188 #:G10189 #:MEMF10190 #:MEMF10191 #:MEMF10192 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10200 #:G10201 #:MEMF10202 #:MEMF10203 #:MEMF10204)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10211 #:G10212 #:MEMF10213 #:MEMF10214 #:MEMF10215 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10223 #:G10224 #:MEMF10225 #:MEMF10226 #:MEMF10227 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10235 #:G10236 #:MEMF10237 #:MEMF10238 #:MEMF10239 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10247 #:G10248 #:MEMF10249 #:MEMF10250 #:MEMF10251 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10259 #:G10260 #:MEMF10261 #:MEMF10262 #:MEMF10263 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10271 #:G10272 #:MEMF10273 #:MEMF10274 #:MEMF10275 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10283 #:G10284 #:MEMF10285 #:MEMF10286 #:MEMF10287 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10295 #:G10296 #:MEMF10297 #:MEMF10298 #:MEMF10299 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10307 #:G10308 #:MEMF10309 #:MEMF10310 #:MEMF10311 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10319 #:G10320 #:MEMF10321 #:MEMF10322 #:MEMF10323 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10331 #:G10332 #:MEMF10333 #:MEMF10334 #:MEMF10335 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10343 #:G10344 #:MEMF10345 #:MEMF10346 #:MEMF10347 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10355 #:G10356 #:MEMF10357 #:MEMF10358 #:MEMF10359 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10367 #:G10368 #:MEMF10369 #:MEMF10370 #:MEMF10371)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10378 #:G10379 #:MEMF10380 #:MEMF10381 #:MEMF10382 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10390 #:G10391 #:MEMF10392 #:MEMF10393 #:MEMF10394 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10402 #:G10403 #:MEMF10404 #:MEMF10405 #:MEMF10406)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10413 #:G10414 #:MEMF10415 #:MEMF10416 #:MEMF10417 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10425 #:G10426 #:MEMF10427 #:MEMF10428 #:MEMF10429 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10437 #:G10438 #:MEMF10439 #:MEMF10440 #:MEMF10441 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10449 #:G10450 #:MEMF10451 #:MEMF10452 #:MEMF10453 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10461 #:G10462 #:MEMF10463 #:MEMF10464 #:MEMF10465)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10472 #:G10473 #:MEMF10474 #:MEMF10475 #:MEMF10476 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10484 #:G10485 #:MEMF10486 #:MEMF10487 #:MEMF10488 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10496 #:G10497 #:MEMF10498 #:MEMF10499 #:MEMF10500 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10508 #:G10509 #:MEMF10510 #:MEMF10511 #:MEMF10512 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10520 #:G10521 #:MEMF10522 #:MEMF10523 #:MEMF10524)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10531 #:G10532 #:MEMF10533 #:MEMF10534 #:MEMF10535)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10542 #:G10543 #:MEMF10544 #:MEMF10545 #:MEMF10546 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10554 #:G10555 #:MEMF10556 #:MEMF10557 #:MEMF10558)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10565 #:G10566 #:MEMF10567 #:MEMF10568 #:MEMF10569 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10577 #:G10578 #:MEMF10579 #:MEMF10580 #:MEMF10581 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10589 #:G10590 #:MEMF10591 #:MEMF10592 #:MEMF10593 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10601 #:G10602 #:MEMF10603 #:MEMF10604 #:MEMF10605 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10614 #:G10615 #:MEMF10616 #:MEMF10617 #:MEMF10618 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10626 #:G10627 #:MEMF10628 #:MEMF10629 #:MEMF10630 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-operators.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-validation.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/qname-resolution.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-graph.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/node-path-walk.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-walk.fasl".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-walk-accessors.fasl".


; Compilation unit finished.
;   1 warning
;   57 notes


(NIL T NIL T NIL T
 #p"/house/janson/XML-0-949-20030408T1846-CRLF/bin/cmuclfasl/code/xquerydatamodel/xqdm-classes.fasl"
 T NIL T NIL T NIL T NIL T NIL T NIL T NIL T NIL T NIL T NIL T NIL T)
(:XQDM)
* (let* ((*specialize-elem-node* t)
       (document (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>"))))

; In: LET* ((*SPECIALIZE-ELEM-NODE* T) (DOCUMENT #))

;   (LET* (# #)
;     )
; Note: Variable DOCUMENT defined but never used.
; 
NIL
* (let* ((*specialize-elem-node* t)
       (document (document-parser "<!DOCTYPE envelope [<!ELEMENT envelope ANY><!ATTLIST envelope xmlns CDATA 'XML-PARSER'>]>
    <envelope xmlns='XML-PARSER'>asd<f/></envelope>"))) document)

#<DOC-NODE <no uri> {48B3C29D}>
* (cl-user::execute-system-operations :xtests '(:load))

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/xquerydatamodel/model.lisp".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/bom.lisp".


; In: LAMBDA (#:G10691 #:G10692 #:MEMF10693 #:MEMF10694 #:MEMF10695 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; WFC: External Parsed Entity signaled:
entity identified as (SYSTEM "ent2.ent" PUBLIC NIL) does not have the form of an external parsed entity:


; In: LAMBDA (#:G10703 #:G10704 #:MEMF10705 #:MEMF10706 #:MEMF10707 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; WFC: Legal Character signaled:
character name/code error: "u+FEFF"/#xFEFF (not supported).



; In: LAMBDA (#:G10715 #:G10716 #:MEMF10717 #:MEMF10718)

;   (LET* #
;     #
;     NIL
;     #)
; Note: Variable CONDITION defined but never used.
; 
; Note: Variable STREAM defined but never used.
; parser error with-state #<XML-PARSE-STATE
                          :sources NIL :input NIL :token NIL :lexical-context |TextDecl| :source #<XML-INPUT
                                                                                                   {48AF0B15}> :term |xml|:/> :non-terminal |xml|:> :stack NIL >.

parser error with-state #<XML-PARSE-STATE
                          :sources NIL :input #\< :token NIL :lexical-context |Content| :source #<XML-INPUT
                                                                                                  {48ADDD0D}> :term |xml|:/> :non-terminal |xml|:> :stack NIL >.WFC: External Parsed Entity signaled:
entity identified as (SYSTEM "ent2x.ent" PUBLIC NIL) does not have the form of an external parsed entity:
WFC: Legal Character signaled:
character name/code error: "u+FEFF"/#xFEFF (not supported).

parser error with-state #<XML-PARSE-STATE
                          :sources NIL :input |xml|:|<?xml| :token NIL :lexical-context |TextDecl| :source #<XML-INPUT
                                                                                                             {488BA2ED}> :term |xml|:/> :non-terminal |xml|:> :stack NIL >.

parser error with-state #<XML-PARSE-STATE
                          :sources NIL :input #\< :token NIL :lexical-context |Content| :source #<XML-INPUT
                                                                                                  {488B4625}> :term |xml|:/> :non-terminal |xml|:> :stack NIL >.
((#p"/house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/doc.xml"
  #<DOC-NODE <no uri> {49B2BB2D}> :UTF-8 NIL)
 (#p"/house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/docx.xml"
  #<DOC-NODE <no uri> {49B2BB3D}> :UTF-8 NIL)
 (#p"/house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/ent.xml"
  #<DOC-NODE
    file:///house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/ent.xml
    {49B0EBA5}>
  :UTF-8 :UTF-8)
 (#p"/house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/ent2.xml"
  #<|WFC: External Parsed Entity| {48AF1D0D}>)
 (#p"/house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/ent2x.xml"
  #<|WFC: External Parsed Entity| {488BAF95}>)
 (#p"/house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/entx.xml"
  #<DOC-NODE
    file:///house/janson/XML-0-949-20030408T1846-CRLF/standards/xml/xmlconf/bomtest/entx.xml
    {488E2D55}>
  :UTF-8 :UTF-8))
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/document-internal.lisp".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/document-external.lisp".


#<DOC-NODE file://XML/TESTS/XML/CHANNEL.XML {491AE7A5}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                  {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|Channel| 1 {485E739D}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|Channel|
                         {485E5AFD}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 27 entries {491AEF7D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {491AF52D}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {491ADFC5}>
 IDS                   #<EQL hash table, 0 entries {491AFF7D}>
 NOTATIONS             #<EQL hash table, 0 entries {49ABE1D5}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|Channel| 1 {485E739D}>

#<DOC-NODE file://xml/Tests/xml/channel.xml {487BD0C5}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                  {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|Channel| 1 {48A85B0D}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|Channel|
                         {48A8126D}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 27 entries {487BD89D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {487BDE4D}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {487BC9F5}>
 IDS                   #<EQL hash table, 0 entries {487BE9AD}>
 NOTATIONS             #<EQL hash table, 0 entries {487BEF5D}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|Channel| 1 {48A85B0D}>

#<DOC-NODE file://XML/TESTS/XML/EMAIL.XML {48B93F35}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<COMMENT-NODE {48B9811D}>
                        #<ELEM-NODE :|mail| 1 {48C029A5}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|mail|
                         {48C01F45}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 9 entries {48B9470D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48B94CBD}>
 GENERAL-ENTITIES      #<EQL hash table, 7 entries {48B93865}>
 IDS                   #<EQL hash table, 0 entries {48B9581D}>
 NOTATIONS             #<EQL hash table, 0 entries {48B95DCD}>
 VERSION               "1.0"
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|mail| 1 {48C029A5}>

; In: LAMBDA (#:G10833 #:G10834 #:MEMF10835 #:MEMF10836 #:MEMF10837)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

#<DOC-NODE file://XML/TESTS/XML/LISP.XML {48C4066D}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                               {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE |lisp as xml|::LISP 1 {4859162D}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE
                         |-//mecomnet.de//DTD Lisp (sort of)//en|::LISP
                         {4858FF8D}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 43 entries {48C40E45}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48C40FBD}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {48C3FF9D}>
 IDS                   #<EQL hash table, 0 entries {48C45F5D}>
 NOTATIONS             #<EQL hash table, 0 entries {48C4650D}>
 VERSION               "1.0"
 STANDALONE            T
 ROOT                  #<ELEM-NODE |lisp as xml|::LISP 1 {4859162D}>

#<DOC-NODE file://XML/TESTS/XML/REAL-MINI-ALEPH-HET.XML {488A0475}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                              {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :DICTIONARY 1 {489C8C0D}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :DICTIONARY
                         {489C815D}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 13 entries {488A0C4D}>
 PARAMETER-ENTITIES    #<EQL hash table, 2 entries {488A11FD}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {48887DA5}>
 IDS                   #<EQL hash table, 11 entries {488A1D5D}>
 NOTATIONS             #<EQL hash table, 0 entries {488B032D}>
 VERSION               "1.0"
 STANDALONE            NIL
 ROOT                  #<ELEM-NODE :DICTIONARY 1 {489C8C0D}>

#<DOC-NODE file://XML/STANDARDS/XML/REC-XML-20001006.XML {48B2D84D}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                               {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|spec| 1 {482A6305}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|spec|
                         {482A52BD}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 157 entries {48B2DF15}>
 PARAMETER-ENTITIES    #<EQL hash table, 74 entries {48B2DF75}>
 GENERAL-ENTITIES      #<EQL hash table, 29 entries {48B2D17D}>
 IDS                   #<EQL hash table, 298 entries {48B3B145}>
 NOTATIONS             #<EQL hash table, 0 entries {48B3B6F5}>
 VERSION               "1.0"
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|spec| 1 {482A6305}>

#<DOC-NODE file://xml/standards/XML/REC-xml-20001006.xml {49B05F25}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                                                               {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|spec| 1 {483F2705}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE :|spec|
                         {483F16BD}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 157 entries {49B066FD}>
 PARAMETER-ENTITIES    #<EQL hash table, 74 entries {49B06CAD}>
 GENERAL-ENTITIES      #<EQL hash table, 29 entries {49B05855}>
 IDS                   #<EQL hash table, 298 entries {49B06F95}>
 NOTATIONS             #<EQL hash table, 0 entries {49B09DCD}>
 VERSION               "1.0"
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|spec| 1 {483F2705}>
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.
Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.

Document is an internal symbol in the XML-PARSER package.
Function: #<Function |Document| {483080C1}>
Function arguments:
  (index &aux (xml-parser::|MiscSequence| nil) (xml-parser::|Prolog| nil)
   (xml-parser::|Root| nil))
Function documentation:
  {1 } Document ::= Prolog Root MiscSequence?
(|MiscSequence| |Prolog| |Root|)
Its declared argument types are:
  (T)
Its result type is:
  (VALUES T T T)
On Tuesday, 4/8/03 01:20:27 pm EDT it was compiled from:
XML:CODE;ATN-LIB;XML-GRAMMAR.LISP
  Created: Tuesday, 4/8/03 01:20:27 pm EDT
Its :PRODUCTION property is "
{1 } Document ::= Prolog Root MiscSequence?".
   "
   {1 } Document ::= Prolog Root MiscSequence?" is a vector of length 44.
   It has no fill pointer.
   Its element type is specialized to BASE-CHAR.
Its :TERMS property is (|MiscSequence| |Prolog| |Root|).
   (|MiscSequence| |Prolog| |Root|) is a CONS.
Its :PARSETABLE property is |Document-Parsetable|.
   Document-Parsetable is an internal symbol in the XML-PARSER package.
   It is a special variable; its value is #<XML-PARSETABLE
                                            Document[ #\Tab #\Newline #\Return #\Space #\< ]
                                            {4837B53D}>.Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.


#<DOC-NODE <no uri> {49C860DD}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                          {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<COMMENT-NODE {49C89E55}> #<COMMENT-NODE {49E70485}>
                        #<COMMENT-NODE {49E704D5}> #<COMMENT-NODE {49E704C5}>
                        #<COMMENT-NODE {49E704B5}> ...)
 PARENT                NIL
 ENTITY-INFO           #<ENTITY-INFORMATION-NODE :|| {4855C435}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 0 entries {49C868B5}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {49C86E65}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {49C85A0D}>
 IDS                   #<EQL hash table, 0 entries {49C879C5}>
 NOTATIONS             #<EQL hash table, 0 entries {49C87F75}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|spec| 1 {49C8D675}>Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.

Document is an internal symbol in the XML-PARSER package.
Function: #<Function |Document| {483080C1}>
Function arguments:
  (index &aux (xml-parser::|MiscSequence| nil) (xml-parser::|Prolog| nil)
   (xml-parser::|Root| nil))
Function documentation:
  {1 } Document ::= Prolog Root MiscSequence?
(|MiscSequence| |Prolog| |Root|)
Its declared argument types are:
  (T)
Its result type is:
  (VALUES T T T)
On Tuesday, 4/8/03 01:20:27 pm EDT it was compiled from:
XML:CODE;ATN-LIB;XML-GRAMMAR.LISP
  Created: Tuesday, 4/8/03 01:20:27 pm EDT
Its :PRODUCTION property is "
{1 } Document ::= Prolog Root MiscSequence?".
   "
   {1 } Document ::= Prolog Root MiscSequence?" is a vector of length 44.
   It has no fill pointer.
   Its element type is specialized to BASE-CHAR.
Its :TERMS property is (|MiscSequence| |Prolog| |Root|).
   (|MiscSequence| |Prolog| |Root|) is a CONS.
Its :PARSETABLE property is |Document-Parsetable|.
   Document-Parsetable is an internal symbol in the XML-PARSER package.
   It is a special variable; its value is #<XML-PARSETABLE
                                            Document[ #\Tab #\Newline #\Return #\Space #\< ]
                                            {4837B53D}>.Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.


#<DOC-NODE file://XML/STANDARDS/XML/XMLCONF/XMLBENCH/BENCHMARK/DATA/MED.XML
  {484E9DFD}> is an instance of class #<STANDARD-CLASS DOC-NODE {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<COMMENT-NODE {4850B0C5}>
                        #<PI-NODE :VERBATIM '"eg" ' {4850B745}>
                        #<ELEM-NODE :|spec| 1 {4850C3BD}>
                        #<COMMENT-NODE {49DAFEA5}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE #:|spec|
                         {4850AA05}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 0 entries {484EA5D5}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {484EAB85}>
 GENERAL-ENTITIES      #<EQL hash table, 26 entries {484E972D}>
 IDS                   #<EQL hash table, 0 entries {484EAF7D}>
 NOTATIONS             #<EQL hash table, 0 entries {484EBCBD}>
 VERSION               "1.0"
 STANDALONE            NIL
 ROOT                  #<ELEM-NODE :|spec| 1 {4850C3BD}>Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.

Document is an internal symbol in the XML-PARSER package.
Function: #<Function |Document| {483080C1}>
Function arguments:
  (index &aux (xml-parser::|MiscSequence| nil) (xml-parser::|Prolog| nil)
   (xml-parser::|Root| nil))
Function documentation:
  {1 } Document ::= Prolog Root MiscSequence?
(|MiscSequence| |Prolog| |Root|)
Its declared argument types are:
  (T)
Its result type is:
  (VALUES T T T)
On Tuesday, 4/8/03 01:20:27 pm EDT it was compiled from:
XML:CODE;ATN-LIB;XML-GRAMMAR.LISP
  Created: Tuesday, 4/8/03 01:20:27 pm EDT
Its :PRODUCTION property is "
{1 } Document ::= Prolog Root MiscSequence?".
   "
   {1 } Document ::= Prolog Root MiscSequence?" is a vector of length 44.
   It has no fill pointer.
   Its element type is specialized to BASE-CHAR.
Its :TERMS property is (|MiscSequence| |Prolog| |Root|).
   (|MiscSequence| |Prolog| |Root|) is a CONS.
Its :PARSETABLE property is |Document-Parsetable|.
   Document-Parsetable is an internal symbol in the XML-PARSER package.
   It is a special variable; its value is #<XML-PARSETABLE
                                            Document[ #\Tab #\Newline #\Return #\Space #\< ]
                                            {4837B53D}>.Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.


#<DOC-NODE <no uri> {4A23D5CD}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                          {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<COMMENT-NODE {4A24134D}> #<COMMENT-NODE {4A4019AD}>
                        #<COMMENT-NODE {4A4051CD}> #<COMMENT-NODE {4A4051BD}>
                        #<COMMENT-NODE {4A4051AD}> ...)
 PARENT                NIL
 ENTITY-INFO           #<ENTITY-INFORMATION-NODE :|| {4808F295}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 0 entries {4A23DDA5}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {4A23DF1D}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {4A23CEFD}>
 IDS                   #<EQL hash table, 0 entries {4A23EEDD}>
 NOTATIONS             #<EQL hash table, 0 entries {4A23F46D}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|spec| 1 {4A244B25}>Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.

Document is an internal symbol in the XML-PARSER package.
Function: #<Function |Document| {483080C1}>
Function arguments:
  (index &aux (xml-parser::|MiscSequence| nil) (xml-parser::|Prolog| nil)
   (xml-parser::|Root| nil))
Function documentation:
  {1 } Document ::= Prolog Root MiscSequence?
(|MiscSequence| |Prolog| |Root|)
Its declared argument types are:
  (T)
Its result type is:
  (VALUES T T T)
On Tuesday, 4/8/03 01:20:27 pm EDT it was compiled from:
XML:CODE;ATN-LIB;XML-GRAMMAR.LISP
  Created: Tuesday, 4/8/03 01:20:27 pm EDT
Its :PRODUCTION property is "
{1 } Document ::= Prolog Root MiscSequence?".
   "
   {1 } Document ::= Prolog Root MiscSequence?" is a vector of length 44.
   It has no fill pointer.
   Its element type is specialized to BASE-CHAR.
Its :TERMS property is (|MiscSequence| |Prolog| |Root|).
   (|MiscSequence| |Prolog| |Root|) is a CONS.
Its :PARSETABLE property is |Document-Parsetable|.
   Document-Parsetable is an internal symbol in the XML-PARSER package.
   It is a special variable; its value is #<XML-PARSETABLE
                                            Document[ #\Tab #\Newline #\Return #\Space #\< ]
                                            {4800243D}>.Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.


#<DOC-NODE file://XML/STANDARDS/XML/XMLCONF/XMLBENCH/BENCHMARK/DATA/BIG.XML
  {48B5CB35}> is an instance of class #<STANDARD-CLASS DOC-NODE {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<COMMENT-NODE {48BB1E45}>
                        #<PI-NODE :VERBATIM '"eg" ' {48BB24C5}>
                        #<ELEM-NODE :|spec| 1 {48BB3135}>
                        #<COMMENT-NODE {48672D65}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE #:|spec|
                         {48BB1785}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 0 entries {48B5D30D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48B5D8BD}>
 GENERAL-ENTITIES      #<EQL hash table, 26 entries {48B5BF15}>
 IDS                   #<EQL hash table, 0 entries {4829A485}>
 NOTATIONS             #<EQL hash table, 0 entries {4829A4C5}>
 VERSION               "1.0"
 STANDALONE            NIL
 ROOT                  #<ELEM-NODE :|spec| 1 {48BB3135}>
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/document-specialized.lisp".

#<DOC-NODE <no uri> {48ED9985}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                          {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<ELEM-NODE :|envelope| 1 {48F669B5}>)
 PARENT                NIL
 ENTITY-INFO           #<ENTITY-INFORMATION-NODE :|| {48F6CBBD}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 0 entries {48ED9F45}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {48ED9FA5}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {48ED92B5}>
 IDS                   #<EQL hash table, 0 entries {48EE826D}>
 NOTATIONS             #<EQL hash table, 0 entries {48EE881D}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<ELEM-NODE :|envelope| 1 {48F669B5}>

#<DOC-NODE <no uri> {4905CD85}> is an instance of class #<STANDARD-CLASS DOC-NODE
                                                          {486F2D8D}>:
 The following slots have :INSTANCE allocation:
 CHILDREN              (#<|envelope| {490A785D}>)
 PARENT                NIL
 ENTITY-INFO           #<DOCUMENT-TYPE-DECLARATION-INFORMATION-NODE |envelope|
                         {490A64DD}>
 NAMESPACES            NIL
 VALIDATE              NIL
 ATTRIBUTES            NIL
 TYPES                 #<EQL hash table, 1 entry {4905D55D}>
 PARAMETER-ENTITIES    #<EQL hash table, 0 entries {4905DB0D}>
 GENERAL-ENTITIES      #<EQL hash table, 5 entries {49057F25}>
 IDS                   #<EQL hash table, 0 entries {4906566D}>
 NOTATIONS             #<EQL hash table, 0 entries {49065C1D}>
 VERSION               NIL
 STANDALONE            T
 ROOT                  #<|envelope| {490A785D}>
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/qnames.lisp".
newElement is an internal symbol in the data:,ns-a package.
Its :PREFIX property is NIL.

#<ELEM-NODE |data:,ns-a|::|newElement| {48070B35}> is an instance of class #<STANDARD-CLASS ELEM-NODE
                                                                             {486F2D9D}>:
 The following slots have :INSTANCE allocation:
 DOCUMENT      NIL
 ORDINALITY    NIL
 PARENT        NIL
 DEF           NIL
 NAME          |data:,ns-a|::|newElement|
 VALID         "unbound"
 NAMESPACES    NIL
 ATTRIBUTES    (#<QNAME-ATTR-NODE |data:,ns-a|::|test| {480705ED}>)
 CHILDREN      ("... or not. if the model is complete,"
                "operations are closed and the serialized form is NS-valid."
                "...")

; In: LAMBDA (#:G10978 #:G10979 #:MEMF10980 #:MEMF10981 #:MEMF10982 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G10990 #:G10991 #:MEMF10992 #:MEMF10993 #:MEMF10994 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/validation.lisp".


; In: LAMBDA (#:G11043 #:G11044 #:MEMF11045 #:MEMF11046 #:MEMF11047 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/namespaces.lisp".

; Loading #p"/house/janson/XML-0-949-20030408T1846-CRLF/tests/parser/oasis.lisp".

Warning:  TIME form in a non-null environment, forced to interpret.
Compiling entire form will produce more accurate times.

; In: LAMBDA (#:G11096 #:G11097 #:MEMF11098 #:MEMF11099 #:MEMF11100 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G11115 #:G11116 #:MEMF11117 #:MEMF11118 #:MEMF11119 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G11736 #:G11737 #:MEMF11738 #:MEMF11739 #:MEMF11740 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G12605 #:G12606 #:MEMF12607 #:MEMF12608)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G12743 #:G12744 #:MEMF12745 #:MEMF12746 #:MEMF12747 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 

; In: LAMBDA (#:G13111 #:G13112 #:MEMF13113 #:MEMF13114 #:MEMF13115 ...)

;   (LET* (# # #)
;     (DECLARE #)
;     NIL
;     (PROGN # #))
; Note: Variable CONDITION defined but never used.
; 
(:CASES 1812 :CONFORMANT 1739 :DISCREPANT 63 :NONCONFORMANT 10 :ERRONEOUS 0) 
(:CASES 1812 :CONFORMANT 1739 :DISCREPANT
 (63 "p04pass1.xml" "p05pass1.xml" "p11pass1.xml" "p66pass1.xml" "p06fail1.xml"
  "p08fail1.xml" "p08fail2.xml" "p16fail3.xml" "empty.xml" "id08.xml"
  "id09.xml" "not-sa01.xml" "not-sa02.xml" "not-sa03.xml" "not-sa04.xml"
  "not-sa05.xml" "not-sa06.xml" "not-sa07.xml" "not-sa08.xml" "not-sa09.xml"
  "not-sa10.xml" "not-sa11.xml" "not-sa12.xml" "not-sa13.xml" "not-sa14.xml"
  "pe01.xml" "ext01.xml" "notation01.xml" "432gewf.xml" "ibm29i01.xml"
  "ibm32i01.xml" "ibm32i02.xml" "ibm32i03.xml" "ibm32i04.xml" "ibm49i01.xml"
  "ibm50i01.xml" "ibm51i01.xml" "ibm56i08.xml" "ibm56i10.xml" "ibm02v01.xml"
  "ibm54v01.xml" "ibm58v01.xml" "ibm59v01.xml" "ibm66v01.xml" "074.xml"
  "104.xml" "115.xml" "117.xml" "119.xml" "120.xml" "181.xml" "182.xml"
  "001.xml" "002.xml" "003.xml" "006.xml" "003.xml" "012.xml" "052.xml"
  "064.xml" "076.xml" "089.xml" "090.xml")
 :NONCONFORMANT
 (10 "ibm85v01.xml" "ibm86v01.xml" "ibm87v01.xml" "ibm88v01.xml" "ibm89v01.xml"
  "014.xml" "050.xml" "051.xml" "062.xml" "063.xml")
 :ERRONEOUS (0)) 

; Compilation unit finished.
;   15 notes


(T T T NIL T T T T T)
(:XTESTS)
* (dribble)
