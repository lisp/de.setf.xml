;;; -*- Mode: lisp; Syntax: ansi-common-lisp; Base: 10; Package: xml-query; -*-

#|
<DOCUMENTATION>
 <DESCRIPTION>
  a tokenizer for XPath is implemented based on the cl reader. this performs the lexical
  transform only.
  </DESCRIPTION>
 <COPYRIGHT YEAR='2001' AUTHOR='james adam anderson' MARK='(C)'
            href='file://xml/sysdcl.lisp' />
 <CHRONOLOGY>
  <DELTA DATE='20010227' AUTHOR='jaa'>initial version, from the xpath tokenizer</DELTA>
  <DELTA DATE='20010306' AUTHOR='JAA'>consolidated XQDM,XQ,XP</DELTA>
  <DELTA DATE='20010511'>literals now eturned as quoted list to distinguish them from names</DELTA>
  <DELTA DATE='20010612'>
   <li>WD-xquery-20010607: metasymbol variations</li>
   <li>WD-xquery-20010607: context-dependent tokenization</li></DELTA>
  <DELTA DATE='20010618'>xutils:*parsetable*</DELTA>
  <DELTA DATE='20010913'>
   <ul><li>|..-reader| made non-terminating</li>
       <li>|//-reader| added to model-content context for bare path expressions</li></ul></DELTA>
  <DELTA DATE='20010913' VERSION='0.503'>changed colon and star readers to <em>not</em>
   extend the token to include star or colon, respectively. this together with grammar
   changes to the nametest.</DELTA>
  <DELTA DATE='20011220'>replaced <code>without-interrupts</code> with a lock</DELTA>
  </CHRONOLOGY>
 </DOCUMENTATION>
|#

(in-package "XML-QUERY")

#|
the XQuery language lexical domain is specified in "WD-XQuery-20010607".
the lexical analysis is implemented with reader macros.
tokens are self-bound symbols in the *token-package*.
they are generated by reader macros which simply return the respective token symbol.
everything else is read first as a string and then examined to see if it should be
converted to a number.
where state is required, the special variable *xpath-token* is consulted.
look-ahead uses peek-char

20010607 requires context-dependendant lexical processing. the contexts now include those
of an xml document entity (that is xml without declarations), plus the query expression context.
in order to prepare for further surprises, i adopted the mechanism from the complete xml parser.

|#

(defclass unbalanced-delimiter (simple-error)
  ((delimiter :initarg :delimiter :initform nil :reader condition.delimiter)))
(defMethod simple-condition-format-string ((condition unbalanced-delimiter))
  "unbalanced delimiter: ~a.")
(defMethod simple-condition-format-arguments ((condition unbalanced-delimiter))
  (with-slots (delimiter) condition
    (list delimiter)))

(defParameter *predefined-entities*
  '(("lt" . #\<) ("gt" . #\>) ("amp" . #\&) ("quot" . #\") ("apos" . #\')))
(defParameter *token-buffer* nil)
(defParameter *saved-token* nil)

(defun |_read-entity-ref-name|
       (stream char &aux (buffer (get-token-buffer)))
  (loop (when (char= char #\;)
          (when (= (length buffer) 0)
            (xml-error |WFC: [EntityRef]| :format-string "no name provided."))
          (return buffer))
        (vector-push-extend char buffer)
        (unless (if (= 1 (length buffer))
                  (xml-initial-namechar? char)
                  (xml-namechar? char))
          (xml-error |WFC: [EntityRef]|
                     :format-string "illegal entity reference name: ~s."
                     :format-arguments (list buffer)))
        (setf char (read-char stream))))

(defun |_read-character-entity-ref-name|
       (stream &aux char (is-hex nil) (buffer (get-token-buffer)))
  (setf char (read-char stream))
  (loop (when (char= char #\;)
          (when (= (length buffer) 0)
            (xml-error |WFC: [CharRef]| :format-string "no name provided."))
          (return buffer))
        (vector-push-extend char buffer)
        (unless (or (and (= 1 (length buffer))
                         (when (char= char #\x) (setf is-hex t)))
                    (digit-char-p char (if is-hex 16 10)))
          (xml-error |WFC: [CharRef]|
                     :format-string "illegal character reference: ~s"
                     :format-arguments (list buffer)))
        (setf char (read-char stream))))

(defun |_read-char-ref| (stream)
  (let ((code 0)
        (radix 10)
        (start 0)
        (buffer (|_read-character-entity-ref-name| stream)))
    (cond (buffer
           (when (char= (char buffer 0) #\x)
             (setf radix 16)
             (setf start 1))
           (setf code (ignore-errors (parse-integer buffer :radix radix :start start)))
           (cond ((and code (xml-char? code) (<-char-code-limit code))
                  (return-token-buffer buffer)
                  (code-char code))
                 (t
                  (xml-error |WFC: Legal Character| :name buffer :code code))))
          (t
           (xml-error |WFC: Legal Character| :name buffer)))))

(defun |&-reader| (stream char &aux name)
  (cond ((= #\# (setf char (read-char stream)))
         (|_read-char-ref| stream))
        ((xml-space? char)
         (|character-error| stream char))
        (t
         (setf name (|_read-entity-ref-name| stream char))
         (or (rest (assoc name *predefined-entities* :test #'string=))
             (xml-error |WFC: Entity Declared| :name name)))))

(defun |..-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((plusp (fill-pointer *token-buffer*))
         (extend-token #\.)
         nil)
        ((char= char #\.)
         (read-char stream)
         |xml|:|..|)
        ((find char "01234567879")
         (extend-token #\.)
         nil)
        (t
         |xml|:|.|)))

(defun |/>-reader| (stream char)
  ;; for use in tags
  (setf char (peek-char nil stream))
  (cond ((char= char #\>)
         (read-char stream)
         |xml|:|/>|)
        (t
         |xml|:|/|)))

(defun |{-reader| (stream char)
  (declare (ignore stream char))
  (incf |xml|:|{|)
  '|xml|:|{|)
(defun |}-reader| (stream char)
  (declare (ignore stream char))
  (when (minusp (decf |xml|:|{|))
    (error 'unbalanced-delimiter :delimiter '|xml|:|}|))
  '|xml|:|}|)
(defun |(-reader| (stream char)
  (declare (ignore stream char))
  (incf |xml|:|(|)
  '|xml|:|(|)
(defun |)-reader| (stream char)
  (declare (ignore stream char))
  (when (minusp (decf |xml|:|(|))
    (error 'unbalanced-delimiter :delimiter '|xml|:|)|))
  '|xml|:|)|)
(defun |[-reader| (stream char)
  (declare (ignore stream char))
  (incf |xml|:|[|)
  '|xml|:|[|)
(defun |]-reader| (stream char)
  (declare (ignore stream char))
  (when (minusp (decf |xml|:|[|))
    (error 'unbalanced-delimiter :delimiter '|xml|:|]|))
  '|xml|:|]|)

(defun |//-reader| (stream char)
  ;; for use in paths
  (setf char (peek-char nil stream))
  (cond ((char= char #\/)
         (read-char stream)
         |xml|:|//|)
        (t
         |xml|:|/|)))

(defun |->-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\>)
         (read-char stream)
         |xml|:|->|)
        (t
         |xml|:|-|)))

(defun |!==-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\=)
         (read-char stream)
         (setf char (peek-char nil stream))
         (cond ((char= char #\=)
                (read-char stream)
                |xml|:|!==|)
               (t
                |xml|:|!=|)))
        (t ;; return the failed token string
         "!")))

(defun |/-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\>)
         (read-char stream)
         |xml|:|/>|)
        ((char= char #\/)
         (read-char stream)
         |xml|:|//|)
        (t
         |xml|:|/|)))

(defun |?>-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\>)
         (read-char stream)
         |xml|:|?>|)
        (t
         (extend-token #\?)
         nil)))

(defun |==-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\=)
         (read-char stream)
         |xml|:|==|)
        (t
         |xml|:|=|)))

#|(defun |*:-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\:)
         (read-char stream)
         |xml|:|*:|)
        (t
         |xml|:|*|)))|#

(defun |*:-reader| (stream char)
  (declare (ignore stream char))
  (cond (t
         |xml|:|*|)))

(defun |:=-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\:)
         (read-char stream)
         |xml|:|::|)
        #|((char= char #\*)
         (read-char stream)
         |xml|:|:*|)|#
        ((char= char #\=)
         (read-char stream)
         |xml|:|:=|)
        (t
         |xml|:|:|)))

(defun |]]>-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= #\] char)
         (read-char stream)
         (loop
           (setf char (peek-char nil stream))
           (cond ((char=  #\> char)
                  (return '|xml|:|]]>|))
                 ((= #.(char-code #\]) char)
                  (extend-token #\]))
                 (t
                  (extend-token #\])
                  (extend-token #\])
                  (return)))))
        (t ;; extend with first byte, leave the next to reexamine
         (extend-token #\])
         nil)))

(defun |-->-reader| (stream char)
  (setf char (peek-char stream))
  (cond ((char= #\- char)
         (read-char stream)
         (setf char (peek-char stream))
         (cond ((char= #\> char) 
                '|xml|:|-->|)
               (t (extend-token #\-)
                  (extend-token #\-)
                  (xml-error |WFC: [Comment]| :format-string "sequence '--' in comment data."))))
        (t
         ;; if it's not '--', then extend with both bytes and continue
         (extend-token #\-) (extend-token char)
         nil)))

(defun |'-reader| (stream char)
  (declare (ignore stream char))
  (if (eq *quote-token* '|xml|:|'|)
    (shiftf *quote-token* nil)
    (if *quote-token* #\' (setf *quote-token* '|xml|:|'|))))

(defun |"-reader| (stream char)
  (declare (ignore stream char))
  ;; (print (list :quote-token *quote-token*))
  (if (eq *quote-token* '|xml|:|"|)
    (shiftf *quote-token* nil)
    (if *quote-token* #\" (setf *quote-token* '|xml|:|"|))))

;;
;; three options: uncertain context, just equations, just element content

(defun |<-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\=)
         (read-char stream)
         |xml|:|<=|)
        ((char= char #\/)
         (read-char stream)
         |xml|:|</|)
        ((char= char #\?)
         (read-char stream)
         |xml|:|<?|)
        ((char= char #\!)
         (read-char stream)
         (setf char (peek-char nil stream))
         (cond ((char= char #\-)  ;; comment start or error
                (read-char stream)
                (setf char (peek-char nil stream))
                (cond ((char= char #\-)
                       (read-char stream)
                       '|xml|:|<!--|)
                      (t ;; return the failed token string
                       (extend-token-string "<!-")
                       nil)))
               ((char= char #\[) ;; cdata start or error
                (read-char stream)
                (let ((buffer (get-token-buffer)) (char nil))
                  (map nil #'(lambda (c) (vector-push-extend c buffer)) "<![")
                  (cond ((do ((i 3 (1+ i)))
                             ((>= i 9) t)
                           (setf char (read-char stream))
                           (vector-push-extend char buffer)
                           (unless (char= char (schar "<![CDATA[" i))
                             (return nil)))
                         (setf (fill-pointer buffer) 0)
                         '|xml|:|<![CDATA[|)
                        (t ;; return the failed token string
                         (vector-push-extend char buffer)
                         buffer))))
               (t ;; return the failed token string
                "<!")))
        (t |xml|:|<|)))

(defun |<=-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\=)
         (read-char stream)
         |xml|:|<=|)
        (t |xml|:|<|)))

(defun |<![CDATA[-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\/)
         (read-char stream)
         |xml|:|</|)
        ((char= char #\?)
         (read-char stream)
         |xml|:|<?|)
        ((char= char #\!)
         (read-char stream)
         (setf char (peek-char nil stream))
         (cond ((char= char #\-)  ;; comment start or error
                (read-char stream)
                (setf char (peek-char nil stream))
                (cond ((char= char #\-)
                       (read-char stream)
                       '|xml|:|<!--|)
                      (t ;; return the failed token string
                       (extend-token-string "<!-")
                       nil)))
               ((char= char #\[) ;; cdata start or error
                (read-char stream)
                (let ((buffer (get-token-buffer)) (char nil))
                  (map nil #'(lambda (c) (vector-push-extend c buffer)) "<![")
                  (cond ((do ((i 3 (1+ i)))
                             ((>= i 9) t)
                           (setf char (read-char stream))
                           (vector-push-extend char buffer)
                           (unless (char= char (schar "<![CDATA[" i))
                             (return nil)))
                         (setf (fill-pointer buffer) 0)
                         '|xml|:|<![CDATA[|)
                        (t ;; return the failed token string
                         (vector-push-extend char buffer)
                         buffer))))
               (t ;; return the failed token string
                "<!")))
        (t |xml|:|<|)))

(defun |>=-reader| (stream char)
  (setf char (peek-char nil stream))
  (cond ((char= char #\=)
         (read-char stream)
         |xml|:|>=|)
        (t |xml|:|>|)))

(defun |character-error| (stream char)
  (declare (ignore stream))
  (xml-error |WFC: Character Context| :character char))

(defun |ignore-whitespace-reader| (stream char)
  (loop (setf char (peek-char nil stream nil nil))
        (unless (and (characterp char) (xml-space? char))
          ;; indicate break current token
          (return t))
        (read-char stream)))

(defun |tokenize-whitespace-reader| (stream char)
  (declare (ignore char))
  (loop (unless (xml-space? (peek-char nil stream))
          (return '|xml|:| |))
        (read-char stream)))

;;

(defMethod compute-parser-macros ((property (eql 'attribute-value)))
  '(( #\< . |character-error| )
    ( #\{ . |{-reader| )
    ( #\} . |}-reader| )
    ( #\& . |&-reader| )))

(defMethod compute-parser-macros ((property (eql 'cdata-character-data)))
  '(( #\] . |]]>-reader| )))


(defMethod compute-parser-macros ((property (eql 'comment-char-sequence)))
  '(( #\- . |-->-reader|)))

(defMethod compute-parser-macros ((property (eql 'element-character-data)))
  '(( #\< . |<![CDATA[-reader| )
    ( #\& . |&-reader| )
    ( #\{ . |{-reader| )
    ( #\} . |}-reader| )))

(defMethod compute-parser-macros ((property (eql 'expr-character-data)))
  '(( #\< . |<=-reader| )
    ( #\> . |>=-reader| )
    ( #\! . |!==-reader| )
    ( #\= . |==-reader| )
    ( #\* . |*:-reader| )
    ( #\{ . |{-reader| )
    ( #\( . |(-reader| )
    ( #\[ . |[-reader| )
    ( #\} . |}-reader| )
    ( #\) . |)-reader| )
    ( #\] . |]-reader| )
    ( #\/ . |//-reader| )
    ( #\. . |..-reader| )
    ( #\: . |:=-reader| )
    #\$ #\& #\@ #\, #\; #\? #\^ #\+ #\|))

(defMethod compute-parser-macros ((property (eql 'module-content)))
  '(( #\< . |<-reader| )
    ( #\{ . |{-reader| )
    ( #\( . |(-reader| )
    ( #\[ . |[-reader| )
    ( #\} . |}-reader| )
    ( #\) . |)-reader| )
    ( #\] . |]-reader| )
    ( #\/ . |//-reader| )
    ( #\. . |..-reader| )
    #\$ #\& #\@ #\, #\; #\? #\^ #\+ #\| #\> #\! #\= #\*))

(defMethod compute-parser-macros ((property (eql 'pi-char-sequence)))
  '(( #\? . |?>-reader|)))

(defMethod compute-parser-macros ((property (eql 'query-character-data)))
  '(( #\< . |<-reader| )
    ( #\& . |&-reader| )
    ( #\{ . |{-reader| )
    ( #\} . |}-reader| )))

(defMethod compute-parser-macros ((property (eql 'quote)))
  ;; indicates a context where an initial quote is permitted and
  ;; a matching close quote is expected.
  '(( #\' . |'-reader| )
    ( #\" . |"-reader| )))

(defMethod compute-parser-macros ((property (eql 'quote-inner)))
  ;; indicates a context where an initial quote is permitted and
  ;; a matching close quote is expected.
  '(( #\' . |'-reader| )
    ( #\" . |"-reader| )))

(defMethod compute-parser-macros ((property (eql 'tag-content)))
  '(#\=
    ( #\} . |}-reader| )
    ( #\{ . |{-reader| )
    ( #\/ . |/>-reader|)
    ( #\* . |*:-reader| )
    #\>))

(defMethod compute-parser-macros ((property (eql 'tokenized-whitespace)))
  (mapcar #'(lambda (c) (cons c '|tokenize-whitespace-reader|))
          '(#\space #\return #\linefeed #\tab)))

(defMethod compute-parser-macros ((property (eql 'ignored-whitespace)))
  (mapcar #'(lambda (c) (cons c '|ignore-whitespace-reader|))
          '(#\space #\return #\linefeed #\tab)))


(defClass xql-parsetable (parsetable) ())

(clear-parsetables 'xql-parsetable)
(def-parsetable (|Attribute|             xql-parsetable)   tag-content quote tokenized-whitespace)
(def-parsetable (|AttributeValueContent| xql-parsetable)   quote attribute-value)
(def-parsetable (|CdataSection|          xql-parsetable)   cdata-character-data)
(def-parsetable (|ElementContent|        xql-parsetable)   element-character-data)
(def-parsetable (|Expr|                  xql-parsetable)   quote expr-character-data ignored-whitespace)
(def-parsetable (|CommentConstructor|    xql-parsetable)   comment-char-sequence)
(def-parsetable (|PiConstructor|         xql-parsetable)   pi-char-sequence)
(def-parsetable (|QueryModule|           xql-parsetable)   quote module-content ignored-whitespace)
(def-parsetable (|EndTag|                xql-parsetable)   #\> tokenized-whitespace)
;; (def-parsetable (|StringLiteral|         xql-parsetable)   quote-inner)
(def-parsetable (|StringLiteralData|         xql-parsetable)   quote-inner)
(def-parsetable (|StartTag|              xql-parsetable)   tag-content tokenized-whitespace)

(defParameter *token-buffers* (make-array 0 :adjustable t :fill-pointer 0))
(defParameter *token-buffers-lock*
  (www-utils:make-lock "token buffers" :type :multiple-reader-single-writer))
(defun get-token-buffer ()
  (www-utils:with-lock-held (*token-buffers-lock* :write "get buffer")
     (if (> (fill-pointer *token-buffers*) 0)
       (vector-pop *token-buffers*)
       (make-array 8 :fill-pointer 0 :adjustable t :element-type 'character))))
(defun return-token-buffer (buffer)
  (www-utils:with-lock-held (*token-buffers-lock* :write "get buffer")
     (setf (fill-pointer buffer) 0)
     (vector-push-extend buffer *token-buffers*)))
(defun make-token-string (buffer)
  (prog1 (make-array (length buffer) :element-type 'character
                     :initial-contents buffer)
    (return-token-buffer buffer)))




;(with-input-from-string (s "asasass]]> ") (read-cdata-char-data s))
                      
(defun eol-normalize-input  (char stream &aux next-char)
  (declare (optimize (speed 3) (safety 0))
           (type character char next-char))
  (when (xml-initial-eolchar? char)
    (when (char= char #.(code-char #x0d))
      (when (and (setf next-char (peek-char nil stream nil nil))
                 (char= next-char #.(code-char #x0a)))
        (read-char stream))
      (setf char #.(code-char #x0a))))
  char)
    
(defun extend-token (char)
  (vector-push-extend char *token-buffer*))
(defun extend-token-string (string)
  (dotimes (x (length string))
    (vector-push-extend (char string x) *token-buffer*)))

(defun token-reader
       (stream &aux char byte token)
  (unless *parsetable* (error "no parsetable."))
  ; (print *parsetable*)
  (let* ((macros (table.macros *parsetable*))
         (macro-table-size (length macros))
         (macro nil)
         (*token-buffer* (get-token-buffer)))
    (declare (optimize (speed 3) (safety 0))
             (type fixnum position macro-table-size byte)
             (type character char)
             (type simple-vector macros))
    (when bnfp::*atn-trace*
      (format *trace-output* " (token-reader: ~@[in context ~s~])" *parsetable*))
    (multiple-value-bind (reader arg) (stream-reader stream)
      (loop
        ; (format *trace-output* "(input ~s) " *input-datum*)
        (typecase *saved-token*
          (null
           (setf char (funcall reader arg))
           (typecase char
             (character
              (setf byte (char-code char))
              (setf macro (when (< byte macro-table-size)
                            (svref macros byte)))
              (cond (macro
                     #|(format *trace-output* " (dispatching with ~s using ~a(~s)->~a)"
                               *token-buffer* (table.name *parsetable*)
                               char macro)|#
                     (when bnfp::*atn-trace*
                       (format *trace-output* " (dispatching with ~s using ~a(~s)->~a)"
                               *token-buffer* (table.name *parsetable*)
                               char macro))
                     (setf token (funcall macro stream char))
                     #+mcl (when (control-key-p) (print (list :macro-> token)))
                     (case token
                       ((t) (when (> (fill-pointer *token-buffer*) 0)
                              (return (make-token-string *token-buffer*))))
                       ((nil))
                       (t (setf *saved-token* token))))
                    (t
                     (extend-token (eol-normalize-input char stream)))))
             (t ;; null input implies end-of-file, which yields an in-progress string or NIL
              (return (when (> (fill-pointer *token-buffer*) 0)
                        (make-token-string *token-buffer*))))))
          (character
           (extend-token (shiftf *saved-token* nil)))
          ;; reader macros replace input with token symbols
          ((or symbol string)
           (return (if (> (fill-pointer *token-buffer*) 0)
                     (make-token-string *token-buffer*)
                     (shiftf *saved-token* nil))))
          ;; separate multiple values
          (cons
           (return (if (> (fill-pointer *token-buffer*) 0)
                     (make-token-string *token-buffer*)
                     (pop *saved-token*))))
          (t
           (warn "unrecognized input ignored: ~s." *saved-token*)
           (setf *saved-token* nil)))))))

#|
(defun tokenize (stream &aux (result nil) token
                        (|xml|:|{| 0) (|xml|:|(| 0) (|xml|:|[| 0))
  (loop (setf token (xq-token-reader stream))
        (unless token (return (nreverse result)))
        (push token result)))

;; tokenize the use cases
(pprint
 (mapcar #'(lambda (s) (with-input-from-string (s s) (tokenize s)))
         '("let $x <element pre:name ='asdf'>\"11111\"</element>"
           "document(\"zoo.xml\")/chapter[2]//figure[caption = \"Tree Frogs\"]" ;; Q1
           "document(\"zoo.xml\")/chapter[RANGE 2 TO 5]//figure" ;; Q2
           ;; 1.9.4.1
           

           
|#

:EOF
